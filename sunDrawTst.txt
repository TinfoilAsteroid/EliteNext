# file opened: sunDrawTst.asm
   1  0000               DEVICE ZXSPECTRUMNEXT
   2  0000
   3  0000               CSPECTMAP sunDrawTst.map
   4  0000               OPT --zxnext=cspect --syntax=a --reversepop
   5  0000
   6  0000              DEBUGSEGSIZE   equ 1
   7  0000              DEBUGLOGSUMMARY equ 1
   8  0000              ;DEBUGLOGDETAIL equ 1
   9  0000
  10  0000              ;----------------------------------------------------------------------------------------------------------------------------------
  11  0000              ; Game Defines
  12  0000              ScreenLocal     EQU 0
  13  0000              ScreenGalactic  EQU ScreenLocal + 1
  14  0000              ScreenMarket    EQU ScreenGalactic + 1
  15  0000              ScreenMarketDsp EQU ScreenMarket + 1
  16  0000              ScreenStatus    EQU ScreenMarketDsp + 1
  17  0000              ScreenInvent    EQU ScreenStatus + 1
  18  0000              ScreenPlanet    EQU ScreenInvent + 1
  19  0000              ScreenEquip     EQU ScreenPlanet + 1
  20  0000              ScreenLaunch    EQU ScreenEquip + 1
  21  0000              ScreenFront     EQU ScreenLaunch + 1
  22  0000              ScreenAft       EQU ScreenFront+1
  23  0000              ScreenLeft      EQU ScreenAft+2
  24  0000              ScreenRight     EQU ScreenLeft+3
  25  0000              ;----------------------------------------------------------------------------------------------------------------------------------
  26  0000              ; Colour Defines
  27  0000                  INCLUDE "./Hardware/L2ColourDefines.asm"
# file opened: ./Hardware/L2ColourDefines.asm
   1+ 0000              L2ColourBLACK           EQU   0
   2+ 0000              L2ColourRED_1           EQU 224                 ; RGB 255,  0,  0
   3+ 0000              L2ColourRED_2           EQU 192                 ; RGB 218,  0,  0
   4+ 0000              L2ColourRED_3           EQU 160                 ; RGB 182,  0,  0
   5+ 0000              L2ColourRED_4           EQU 128                 ; RGB 145,  0,  0
   6+ 0000              L2ColourRED_5           EQU  96                 ; RGB 109,  0,  0
   7+ 0000              L2ColourRED_6           EQU  64                 ; RGB  72,  0,  0
   8+ 0000              L2ColourRED_7           EQU  32                 ; RGB  36,  0,  0
   9+ 0000              L2ColourYELLOW_1        EQU 252                 ; RGB 255,255,  0
  10+ 0000              L2ColourYELLOW_2        EQU 216                 ; RGB 218,218,  0
  11+ 0000              L2ColourYELLOW_3        EQU 180                 ; RGB 182,182,  0
  12+ 0000              L2ColourYELLOW_4        EQU 144                 ; RGB 145,145,  0
  13+ 0000              L2ColourYELLOW_5        EQU 108                 ; RGB 109.109,  0
  14+ 0000              L2ColourYELLOW_6        EQU  72                 ; RGB  72, 72,  0
  15+ 0000              L2ColourYELLOW_7        EQU  36                 ; RGB  36, 36,  0
  16+ 0000              L2ColourGREEN_1		    EQU  28                 ; RGB   0,255,  0
  17+ 0000              L2ColourGREEN_2		    EQU  24                 ; RGB   0,218,  0
  18+ 0000              L2ColourGREEN_3		    EQU  16                 ; RGB   0,145,  0
  19+ 0000              L2ColourGREEN_4         EQU  12                 ; RGB   0,109,  0
  20+ 0000              L2ColourGREEN_5         EQU   8                 ; RGB   0, 72,  0
  21+ 0000              L2ColourGREEN_6         EQU   4                 ; RGB   0, 36,  0
  22+ 0000              L2ColourBLUE_1          EQU   3                 ; RGB 0,0,255
  23+ 0000              L2ColourBLUE_2          EQU   2                 ; RGB 0,0,170
  24+ 0000              L2ColourBLUE_3          EQU   1                 ; RGB 0,0,85
  25+ 0000
  26+ 0000
  27+ 0000              L2ColourWHITE_1         EQU 255                 ; RGB 255,255,255
  28+ 0000              L2ColourWHITE_2         EQU 146
  29+ 0000              L2ColourGREY_1		    EQU L2ColourWHITE_2
  30+ 0000              L2ColourGREY_2		    EQU 109
  31+ 0000              L2ColourGREY_3		    EQU  73
  32+ 0000              L2ColourGREY_4		    EQU  37
  33+ 0000
  34+ 0000              L2ColourGREEN_MB        EQU  29                 ;RGB 0,255,85
  35+ 0000              L2ColourGREEN_MR        EQU 124                 ;RGB 109.255,0
  36+ 0000              L2ColourCREAM_1         EQU 218                 ; RGB 218,218,170
  37+ 0000              L2ColourCREAM_2         EQU 182                 ; RGB 182,182,170
  38+ 0000              L2ColourCREAM_3         EQU 146                 ; RGB 145,145,170
  39+ 0000
  40+ 0000              L2ColourTRANSPARENT     EQU 227                 ; RGB 255,  0,255
  41+ 0000              L2ColourMAGENTA_1       EQU 162                 ; RGB 182,  0,170
  42+ 0000              L2ColourMAGENTA_2       EQU 130                 ; RGB 145,  0,170
  43+ 0000              L2ColourMAGENTA_3       EQU  97                 ; RGB 109,  0, 85
  44+ 0000              L2ColourMAGENTA_4       EQU  65                 ; RGB  72,  0, 85
  45+ 0000              L2ColourORANGE_1        EQU 236                 ; RGB
  46+ 0000              L2ColourORANGE_2        EQU 168                 ; RGB
  47+ 0000              L2ColourORANGE_3        EQU  68                 ; RGB
  48+ 0000              L2ColourCYAN_1          EQU  31                 ; RGB   0,255, 255
  49+ 0000              L2ColourCYAN_2          EQU  18                 ; RGB
  50+ 0000              L2ColourCYAN_3          EQU   9                 ; RGB
  51+ 0000              L2ColourPURPLE_1        EQU 109                 ; RGB
  52+ 0000              L2ColourPURPLE_2        EQU  66                 ; RGB
  53+ 0000              L2ColourPURPLE_3        EQU  33                 ; RGB
  54+ 0000              L2ColourPINK_1		    EQU 231                 ; RGB
  55+ 0000              L2ColourPINK_2		    EQU 226                 ; RGB
  56+ 0000              L2ColourPINK_3		    EQU 225                 ; RGB
  57+ 0000              L2ColourPINK_4		    EQU 224                 ; RGB
  58+ 0000
# file closed: ./Hardware/L2ColourDefines.asm
  28  0000                  INCLUDE "./Hardware/L1ColourDefines.asm"
# file opened: ./Hardware/L1ColourDefines.asm
   1+ 0000
   2+ 0000              L1ColourInkBlack        EQU %00000000
   3+ 0000              L1ColourInkBlue         EQU %00000001
   4+ 0000              L1ColourInkRed          EQU %00000010
   5+ 0000              L1ColourInkMagenta      EQU %00000011
   6+ 0000              L1ColourInkGreen        EQU %00000100
   7+ 0000              L1ColourInkCyan         EQU %00000101
   8+ 0000              L1ColourInkYellow       EQU %00000110
   9+ 0000              L1ColourInkWhite        EQU %00000111
  10+ 0000              L1ColourPaperBlack      EQU %00000000
  11+ 0000              L1ColourPaperBlue       EQU %00001000
  12+ 0000              L1ColourPaperRed        EQU %00010000
  13+ 0000              L1ColourPaperMagenta    EQU %00011000
  14+ 0000              L1ColourPaperGreen      EQU %00100000
  15+ 0000              L1ColourPaperCyan       EQU %00101000
  16+ 0000              L1ColourPaperYellow     EQU %00110000
  17+ 0000              L1ColourPaperWhite      EQU %00111000
  18+ 0000              L1ColourFlash           EQU %10000000
  19+ 0000              L1ColourBright          EQU %01000000
  20+ 0000              ;----------------------------------------------------------------------------------------------------------------------------------
  21+ 0000              ; Screen Specific Colour Defines
  22+ 0000              L1InvHighlight          EQU L1ColourBright | L1ColourPaperRed   | L1ColourInkYellow
  23+ 0000              L1InvLowlight           EQU                  L1ColourPaperBlack | L1ColourInkWhite
# file closed: ./Hardware/L1ColourDefines.asm
  29  0000              ; Just to make assmebly work
  30  0000 00 00        UBnKxlo         DW 0
  31  0002 00 00        UBnKxsgn         DW 0
  32  0004 00 00        UBnKzlo         DW 0
  33  0006 00 00        UBnKzsgn         DW 0
  34  0008              ;----------------------------------------------------------------------------------------------------------------------------------
  35  0008
  36  0008              N0equN1byN2div256:      MACRO param1,param2,param3
  37  0008 ~                                    ld      a,param3                        ;
  38  0008 ~                                    ld      e,a                         ; use e as var Q = value of XX15 [n] lo
  39  0008 ~                                    ld      a,param2                        ; A = XX16 element
  40  0008 ~                                    ld      d,a
  41  0008 ~                                    mul
  42  0008 ~                                    ld      a,d                         ; we get only the high byte which is like doing a /256 if we think of a as low
  43  0008 ~                                    ld      (param1),a                      ; Q         ; result variable = XX16[n] * XX15[n]/256
  44  0008                                      ENDM
  45  0008
  46  0008              AequN1xorN2:            MACRO  param1,param2
  47  0008 ~                                    ld      a,(param1)
  48  0008 ~                                    xor     param2
  49  0008                                      ENDM
  50  0008                  INCLUDE "./Hardware/register_defines.asm"
# file opened: ./Hardware/register_defines.asm
   1+ 0008              IO_LAYER2_PORT                          EQU $123B
   2+ 0008              IO_EXT_BANK_PORT 			            EQU $DFFD ; 57341
   3+ 0008              IO_BANK_PORT                            EQU $7FFD ; 32765
   4+ 0008              REGISTER_NUMBER_PORT					EQU $243B
   5+ 0008              REGISTER_VALUE_PORT						EQU $253B
   6+ 0008              SPRITE_SLOT_PORT						EQU $303B
   7+ 0008              SPRITE_INFO_PORT                        EQU $0057
   8+ 0008              SPRITE_PATTERN_UPLOAD_PORT				EQU $005B
   9+ 0008
  10+ 0008              MACHINE_ID_REGISTER						EQU 0
  11+ 0008              VERSION_REGISTER						EQU 1
  12+ 0008              RESET_REGISTER		    				EQU 2
  13+ 0008              MACHINE_TYPE_REGISTER					EQU 3
  14+ 0008              PAGE_RAM_REGISTER						EQU 4
  15+ 0008              PERIPHERAL_1_REGISTER					EQU 5
  16+ 0008              PERIPHERAL_2_REGISTER					EQU 6
  17+ 0008              TURBO_MODE_REGISTER						EQU 7
  18+ 0008              PERIPHERAL_3_REGISTER					EQU 8
  19+ 0008              ANTI_BRICK_SYSTEM_REGISTER				EQU 10
  20+ 0008              LAYER2_RAM_PAGE_REGISTER				EQU 18
  21+ 0008              LAYER2_RAM_SHADOW_REGISTER      		EQU 19
  22+ 0008              TRANSPARENCY_COLOUR_REGISTER			EQU 20
  23+ 0008              SPRITE_LAYERS_SYSTEM_REGISTER			EQU 21
  24+ 0008              LAYER2_OFFSET_X_REGISTER				EQU 22
  25+ 0008              LAYER2_OFFSET_Y_REGISTER				EQU 23
  26+ 0008              CLIP_WINDOW_LAYER2_REGISTER				EQU 24
  27+ 0008              CLIP_WINDOW_SPRITES_REGISTER			EQU 25
  28+ 0008              CLIP_WINDOW_ULA_REGISTER				EQU 26
  29+ 0008              CLIP_WINDOW_CONTROL_REGISTER			EQU 28
  30+ 0008              ACTIVE_VIDEO_LINE_MSB_REGISTER			EQU 30
  31+ 0008              ACTIVE_VIDEO_LINE_LSB_REGISTER			EQU 31
  32+ 0008              LINE_INTERRUPT_CONTROL_REGISTER			EQU 34
  33+ 0008              LINE_INTERRUPT_VALUE_LSB_REGISTER		EQU 35
  34+ 0008              KEYMAP_HIGH_ADDRESS_REGISTER			EQU 40
  35+ 0008              KEYMAP_LOW_ADDRESS_REGISTER				EQU 41
  36+ 0008              KEYMAP_HIGH_DATA_REGISTER				EQU 42
  37+ 0008              KEYMAP_LOW_DATA_REGISTER				EQU 43
  38+ 0008              DAC_B_MIRROR_REGISTER                   EQU 44
  39+ 0008              DAC_AB_MIRROR_REGISTER                  EQU 45
  40+ 0008              DAC_C_MORROR_REGISTER                   EQU 46
  41+ 0008              TILEMAP_OFFSET_XMSB_REGISTER            EQU 47
  42+ 0008              TILEMAP_OFFSET_XLSB_REGISTER            EQU 48
  43+ 0008              TILEMAP_OFFSET_YMSB_REGISTER            EQU 49
  44+ 0008              LORES_OFFSET_X_REGISTER					EQU 50
  45+ 0008              LORES_OFFSET_Y_REGISTER					EQU 51
  46+ 0008              SPRITE_PORT_INDEX_REGISTER              EQU 52
  47+ 0008              SPRITE_PORT_ATTR0_REGISTER              EQU 53
  48+ 0008              SPRITE_PORT_ATTR1_REGISTER              EQU 54
  49+ 0008              SPRITE_PORT_ATTR2_REGISTER              EQU 55
  50+ 0008              SPRITE_PORT_ATTR3_REGISTER              EQU 56
  51+ 0008              SPRITE_PORT_ATTR4_REGISTER              EQU 57
  52+ 0008              PALETTE_INDEX_REGISTER					EQU 64
  53+ 0008              PALETTE_VALUE_8BIT_REGISTER				EQU 65
  54+ 0008              PALETTE_FORMAT_REGISTER					EQU 66
  55+ 0008              PALETTE_CONTROL_REGISTER				EQU 67
  56+ 0008              PALETTE_VALUE_9BIT_REGISTER				EQU 68
  57+ 0008              MMU_SLOT_0_REGISTER						EQU 80
  58+ 0008              MMU_SLOT_1_REGISTER						EQU 81
  59+ 0008              MMU_SLOT_2_REGISTER						EQU 82
  60+ 0008              MMU_SLOT_3_REGISTER						EQU 83
  61+ 0008              MMU_SLOT_4_REGISTER						EQU 84
  62+ 0008              MMU_SLOT_5_REGISTER						EQU 85
  63+ 0008              MMU_SLOT_6_REGISTER						EQU 86
  64+ 0008              MMU_SLOT_7_REGISTER						EQU 87
  65+ 0008              COPPER_DATA_REGISTER					EQU 96
  66+ 0008              COPPER_CONTROL_LOW_REGISTER				EQU 97
  67+ 0008              COPPER_CONTROL_HIGH_REGISTER			EQU 98
  68+ 0008              DISPLAY_CONTROL_1_REGISTER              EQU 105
  69+ 0008              LAYER_2_CONTROL_REGISTER                EQU 112
  70+ 0008              LAYER_2_X_OFFSET_MSB_REGISTER           EQU 113
  71+ 0008              DEBUG_LEDS_REGISTER						EQU 255
  72+ 0008
  73+ 0008
  74+ 0008              GetNextReg:	MACRO register
  75+ 0008 ~                        push bc
  76+ 0008 ~                            ld bc,$243B
  77+ 0008 ~                                ld a,register
  78+ 0008 ~                                out (c),a
  79+ 0008 ~                                inc b
  80+ 0008 ~                            in a,(c)
  81+ 0008 ~                        pop bc
  82+ 0008                          ENDM
  83+ 0008
# file closed: ./Hardware/register_defines.asm
  51  0008                  INCLUDE "./Layer2Graphics/layer2_defines.asm"
# file opened: ./Layer2Graphics/layer2_defines.asm
   1+ 0008
   2+ 0008
   3+ 0008              LAYER2_SHIFTED_SCREEN_TOP  	 equ 0
   4+ 0008              LAYER2_SHIFTED_SCREEN_MIDDLE equ $40
   5+ 0008              LAYER2_SHIFTED_SCREEN_BOTTOM equ $80
   6+ 0008
   7+ 0008              ; note hi byte is not decoded on DMA port so can out OUTIR
   8+ 0008              IO_DATAGEAR_DMA_PORT 		 equ 107
   9+ 0008              IO_SPRITE_SLOT_PORT 		 equ 12347
  10+ 0008              IO_SPRITE_PATTERN_PORT       equ 91
  11+ 0008              IO_SPRITE_ATTRIBUTES_PORT    equ 87
  12+ 0008
  13+ 0008              LAYER2_VISIBLE_MASK 		equ $02
  14+ 0008              ; DEBUG 0 for always write to primary 08 for double buffering
  15+ 0008                  IFDEF DOUBLEBUFFER
  16+ 0008 ~            LAYER2_SHADOW_SCREEN_MASK 	equ $08
  17+ 0008                  ELSE
  18+ 0008              LAYER2_SHADOW_SCREEN_MASK 	equ $00
  19+ 0008                  ENDIF
  20+ 0008              LAYER2_READ_ENABLE_MASK 	equ %00000100
  21+ 0008              LAYER2_WRITE_ENABLE_MASK 	equ %00000001
  22+ 0008              LAYER2_READ_WRITE_MASK      equ %00000101
  23+ 0008              LAYER2_SCREEN_SECTION_MASK 	equ $03
  24+ 0008              LAYER2_SCREEN_SECTION_SHIFT equ 6
  25+ 0008
  26+ 0008              LAYER2_DISABLE_MEM_WRITE    equ %11111110
  27+ 0008              LAYER2_DISABLE_MEM_READ     equ %11111011
  28+ 0008              LAYER2_DISABLE_MEM_ACCESS   equ %11111010
  29+ 0008
  30+ 0008              LAYER2_SCREEN_BANK1          equ 8
  31+ 0008              LAYER2_SCREEN_BANK2          equ 9
  32+ 0008              LAYER2_SCREEN_BANK3          equ 10
  33+ 0008              LAYER2_SHADOW_BANK1          equ 11
  34+ 0008              LAYER2_SHADOW_BANK2          equ 12
  35+ 0008              LAYER2_SHADOW_BANK3          equ 13
  36+ 0008
  37+ 0008              SCREEN_HEIGHT 				 equ 192
  38+ 0008              SCREEN_RAM_BASE				 equ $0000
  39+ 0008              SCREEN_HOZ_MIN_PIX		     equ 10
  40+ 0008
  41+ 0008              SPRITES_VISIBLE_MASK         equ $01
  42+ 0008              SPRITES_ON_BORDER_MASK       equ $02
  43+ 0008              LAYER_PRIORITIES_MASK        equ $07
  44+ 0008              LORES_MODE_MASK              equ $80
  45+ 0008              LAYER_PRIORITIES_SHIFT       equ 2
  46+ 0008
  47+ 0008              LAYER_PRIORITIES_S_L_U 		equ 0
  48+ 0008              LAYER_PRIORITIES_L_S_U 		equ 1
  49+ 0008              LAYER_PRIORITIES_S_U_L  	equ 2
  50+ 0008              LAYER_PRIORITIES_L_U_S 		equ 3
  51+ 0008              LAYER_PRIORITIES_U_S_L 		equ 4
  52+ 0008              LAYER_PRIORITIES_U_L_S 		equ 5
  53+ 0008
  54+ 0008              DMA_WRO_BLOCK_PORTA_A2B_XFR  equ $7D
  55+ 0008              DMA_WRO_BLOCK_PORTA_B2A_XFR  equ $79
  56+ 0008              DMA_WR1_P1FIXED_MEMORY       equ $24
  57+ 0008              DMA_WR1_P1DEC_MEMORY         equ $04
  58+ 0008              DMA_WR1_P1INC_MEMORY         equ $14
  59+ 0008              DMA_WR2_P2FIXED_MEMORY       equ $20
  60+ 0008              DMA_WR2_P2DEC_MEMORY         equ $00
  61+ 0008              DMA_WR2_P2INC_MEMORY         equ $10
  62+ 0008              DMA_WR4_CONT_MODE            equ $AD
  63+ 0008              DMA_RESET                    equ $c3
  64+ 0008              DMA_RESET_PORT_A_TIMING      equ $c7
  65+ 0008              DMA_RESET_PORT_B_TIMING      equ $cb
  66+ 0008              DMA_LOAD                     equ $cf
  67+ 0008              DMA_CONTINUE                 equ $d3
  68+ 0008              DMA_DISABLE_INTERUPTS        equ $af
  69+ 0008              DMA_ENABLE_INTERUPTS         equ $ab
  70+ 0008              DMA_RESET_DISABLE_INTERUPTS  equ $a3
  71+ 0008              DMA_ENABLE_AFTER_RETI        equ $b7
  72+ 0008              DMA_READ_STATUS_BYTE         equ $bf
  73+ 0008              DMA_REINIT_STATUS_BYTE       equ $8b
  74+ 0008              DMA_START_READ_SEQUENCE      equ $a7
  75+ 0008              DMA_FORCE_READY              equ $b3
  76+ 0008              DMA_STOP_AT_END			     equ $82
  77+ 0008              DMA_DISABLE                  equ $83
  78+ 0008              DMA_ENABLE                   equ $87
  79+ 0008              DMA_WRITE_REGISTER_COMMAND   equ $bb
  80+ 0008              DMA_BURST                    equ $cd
  81+ 0008              DMA_CONTINUOUS               equ $ad
  82+ 0008              ZXN_DMA_PORT                 equ $6b
  83+ 0008
  84+ 0008
  85+ 0008              COLOUR_TRANSPARENT			 equ $E3
  86+ 0008
  87+ 0008
  88+ 0008
  89+ 0008
# file closed: ./Layer2Graphics/layer2_defines.asm
  52  0008                  INCLUDE	"./Hardware/memory_bank_defines.asm"
# file opened: ./Hardware/memory_bank_defines.asm
   1+ 0008
   2+ 0008              membanksize			    equ	$1FFF
   3+ 0008
   4+ 0008              StartOfBank     	    equ $0000
   5+ 0008
   6+ 0008              membank0 			    equ $0000
   7+ 0008              dmaCopySrcAddr		    equ	$0000
   8+ 0008              membank1 			    equ $2000
   9+ 0008              membank2 			    equ $4000
  10+ 0008              membank3 			    equ $6000
  11+ 0008              membank4 			    equ $8000
  12+ 0008              membank5 			    equ $a000
  13+ 0008              membank6 			    equ $c000
  14+ 0008              ScreenBank              equ $c000
  15+ 0008              MenuGalChtAddr          equ $c000
  16+ 0008              MenuEquipSAddr          equ $c000
  17+ 0008              MenuInventAddr          equ $c000
  18+ 0008              MenuMarketAddr          equ $c000
  19+ 0008              DispMarketAddr          equ $c000
  20+ 0008              MenuShrChtAddr          equ $c000
  21+ 0008              MenuStatusAddr          equ $c000
  22+ 0008              MenuSystemAddr          equ $c000
  23+ 0008              ViewFrontAddr           equ $c000
  24+ 0008              SunBankAddr             equ $c000
  25+ 0008              PlanetBankAddr          equ $c000
  26+ 0008              UniverseBankAddr	    equ $c000
  27+ 0008              LaunchShipAddr          equ $c000
  28+ 0008              membank7 			    equ $e000
  29+ 0008              L1membankAddr   	    equ $e000
  30+ 0008              L2membankAddr   	    equ $e000
  31+ 0008              ShipModelsAddr	        equ $e000
  32+ 0008              SpritemembankAddr       equ $e000
  33+ 0008              ResetUniverseAddr       equ $e000
  34+ 0008              StockTableAddr	        equ $e000
  35+ 0008              CommanderAddr           equ $e000
  36+ 0008              LAYER2Addr              equ $e000
  37+ 0008              LAYER1Addr              equ $e000
  38+ 0008              SPRITEAddr              equ $e000
  39+ 0008              ConsoleImageAddr        equ $e000
  40+ 0008              GalaxyDataAddr          equ $e000
  41+ 0008
  42+ 0008              EXSDOSMMU0              equ MMU_SLOT_0_REGISTER
  43+ 0008              EXSDOSMMU1              equ MMU_SLOT_1_REGISTER
  44+ 0008              DMACpySourceMMU		    equ	MMU_SLOT_0_REGISTER
  45+ 0008              SunMMU 		            equ MMU_SLOT_6_REGISTER
  46+ 0008              PlanetMMU 		        equ MMU_SLOT_6_REGISTER
  47+ 0008              UniverseMMU 		    equ MMU_SLOT_6_REGISTER
  48+ 0008              ScreenBankMMU           equ MMU_SLOT_6_REGISTER
  49+ 0008              MenuEquipSMMU           equ MMU_SLOT_6_REGISTER
  50+ 0008              MenuShrChtMMU           equ MMU_SLOT_6_REGISTER
  51+ 0008              MenuGalChtMMU           equ MMU_SLOT_6_REGISTER
  52+ 0008              MenuInventMMU           equ MMU_SLOT_6_REGISTER
  53+ 0008              MenuSystemMMU           equ MMU_SLOT_6_REGISTER
  54+ 0008              MenuMarketMMU           equ MMU_SLOT_6_REGISTER
  55+ 0008              DispMarketMMU           equ MMU_SLOT_6_REGISTER
  56+ 0008              MenuStatusMMU           equ MMU_SLOT_6_REGISTER
  57+ 0008              LaunchShipMMU           equ MMU_SLOT_6_REGISTER
  58+ 0008              L1memMMU       		    equ MMU_SLOT_7_REGISTER
  59+ 0008              L2memMMU       		    equ MMU_SLOT_7_REGISTER
  60+ 0008              SpritememMMU   		    equ MMU_SLOT_7_REGISTER
  61+ 0008              ShipModelMMU  		    equ MMU_SLOT_7_REGISTER
  62+ 0008              ResetUniverseMMU	    equ MMU_SLOT_7_REGISTER
  63+ 0008              CommanderMMU	        equ MMU_SLOT_7_REGISTER
  64+ 0008              StockTableMMU		    equ MMU_SLOT_7_REGISTER
  65+ 0008              ConsoleImageDataMMU	    equ MMU_SLOT_7_REGISTER
  66+ 0008              GalaxyDataMMU	        equ MMU_SLOT_7_REGISTER
  67+ 0008
  68+ 0008              BankResetUniv           equ 49
  69+ 0008              BankMenuShrCht          equ 50
  70+ 0008              BankMenuGalCht          equ 51
  71+ 0008              BankMenuInvent          equ 52
  72+ 0008              BankMenuSystem          equ 53
  73+ 0008              BankMenuMarket          equ 54
  74+ 0008              BankStockTable          equ 55
  75+ 0008              BankCommander           equ 56
  76+ 0008              BankLAYER2              equ 57
  77+ 0008              BankLAYER1              equ 58
  78+ 0008              BankShipModels1         equ 59
  79+ 0008              BankSPRITE              equ 60
  80+ 0008              BankConsole             equ 61
  81+ 0008              BankFrontView           equ 62
  82+ 0008              BankMenuStatus          equ 63
  83+ 0008              BankMenuEquipS          equ 64
  84+ 0008              BankLaunchShip          equ 65
  85+ 0008              BankDispMarket          equ 66
  86+ 0008              BankShipModels2         equ 67
  87+ 0008              BankShipModels3         equ 68
  88+ 0008              BankShipModels4         equ 69
  89+ 0008
  90+ 0008              BankUNIVDATA0           equ 70
  91+ 0008              BankUNIVDATA1           equ 71
  92+ 0008              BankUNIVDATA2           equ 72
  93+ 0008              BankUNIVDATA3           equ 73
  94+ 0008              BankUNIVDATA4           equ 74
  95+ 0008              BankUNIVDATA5           equ 75
  96+ 0008              BankUNIVDATA6           equ 76
  97+ 0008              BankUNIVDATA7           equ 77
  98+ 0008              BankUNIVDATA8           equ 78
  99+ 0008              BankUNIVDATA9           equ 79
 100+ 0008              BankUNIVDATA10          equ 80
 101+ 0008              BankUNIVDATA11          equ 81
 102+ 0008              BankUNIVDATA12          equ 82
 103+ 0008              BankSunData             equ 83
 104+ 0008              BankPlanetData          equ 84
 105+ 0008
 106+ 0008              BankGalaxyData0         equ 91
 107+ 0008              BankGalaxyData1         equ 92
 108+ 0008              BankGalaxyData2         equ 93
 109+ 0008              BankGalaxyData3         equ 94
 110+ 0008              BankGalaxyData4         equ 95
 111+ 0008              BankGalaxyData5         equ 96
 112+ 0008              BankGalaxyData6         equ 97
 113+ 0008              BankGalaxyData7         equ 98
 114+ 0008
 115+ 0008              BankROM                 equ 255
 116+ 0008
# file closed: ./Hardware/memory_bank_defines.asm
  53  0008                  INCLUDE "./Hardware/screen_equates.asm"
# file opened: ./Hardware/screen_equates.asm
   1+ 0008              ScreenHeight 		equ 192
   2+ 0008              ScreenLastRow       equ ScreenHeight -1
   3+ 0008              ScreenWidth  		equ 256
   4+ 0008              ScreenLastCol       equ ScreenWidth -1
   5+ 0008              ScreenHeightHalf	equ 96
   6+ 0008              ScreenWidthHalf  	equ 128
   7+ 0008              ScreenCenterY		equ 96
   8+ 0008              ScreenCenterX       equ 128
   9+ 0008              ViewHeight          equ 128
  10+ 0008              ViewHeightPlus1     equ 128+1
  11+ 0008              ViewLastRow       	equ ViewHeight -1
  12+ 0008              ViewWidth  			equ 256
  13+ 0008              ViewLastCol         equ ViewWidth -1
  14+ 0008              ViewHeightHalf      equ 63
  15+ 0008              ViewWidthHalf       equ 127
  16+ 0008              ViewCenterY         equ 64
  17+ 0008              ViewCenterX         equ 128
  18+ 0008              ShipColour			equ $FF		; place holder for debugging TODO
  19+ 0008              ScreenL1Bottom      equ $5000
  20+ 0008              ScreenL1BottomLen   equ 32 * 8 * 8
  21+ 0008              ScreenL1AttrBtm     equ $5A00
  22+ 0008              ScreenL1AttrBtmLen  equ 32 * 8
  23+ 0008
# file closed: ./Hardware/screen_equates.asm
  54  0008
  55  0008                                      INCLUDE "./Macros/graphicsMacros.asm"
# file opened: ./Macros/graphicsMacros.asm
   1+ 0008              ; General Graphics macros
   2+ 0008              DoubleBufferIfPossible: MACRO
   3+ 0008 ~                                    IFDEF DOUBLEBUFFER
   4+ 0008 ~                                        MMUSelectLayer2
   5+ 0008 ~                                        call  l2_cls
   6+ 0008 ~                                        call  l2_flip_buffers
   7+ 0008 ~                                    ENDIF
   8+ 0008                                      ENDM
# file closed: ./Macros/graphicsMacros.asm
  56  0008                                      INCLUDE "./Macros/callMacros.asm"
# file opened: ./Macros/callMacros.asm
   1+ 0008
   2+ 0008              CallIfAEqNusng:         MACRO   reg,target
   3+ 0008 ~                                    cp      reg
   4+ 0008 ~                                    call	z,target
   5+ 0008                                      ENDM
   6+ 0008
   7+ 0008              CallIfAGTENusng:        MACRO   reg,target
   8+ 0008 ~                                    cp      reg
   9+ 0008 ~                                    call	nc,target
  10+ 0008                                      ENDM
  11+ 0008
  12+ 0008              CallIfAGTEMemusng:      MACRO   reg,target
  13+ 0008 ~                                    ld      hl,reg
  14+ 0008 ~                                    cp      (hl)
  15+ 0008 ~                                    call	nc,target
  16+ 0008                                      ENDM
  17+ 0008
  18+ 0008              CallIfALTNusng:         MACRO   reg,target
  19+ 0008 ~                                    cp      reg
  20+ 0008 ~                                    call	c,target
  21+ 0008                                      ENDM
  22+ 0008
  23+ 0008              CallIfMemEqMemusng:     MACRO mem, address, target
  24+ 0008 ~                                    ld   a,(mem)
  25+ 0008 ~                                    ld   hl,address
  26+ 0008 ~                                    cp   (hl)
  27+ 0008 ~                                    call    z,target
  28+ 0008                                      ENDM
  29+ 0008
  30+ 0008              CallIfMemEqNusng:       MACRO mem, value, target
  31+ 0008 ~                                    ld   a,(mem)
  32+ 0008 ~                                    cp   value
  33+ 0008 ~                                    call    z,target
  34+ 0008                                      ENDM
  35+ 0008
  36+ 0008              CallIfMemTrue:          MACRO mem, target
  37+ 0008 ~                                    ld      a,(mem)
  38+ 0008 ~                                    and     a
  39+ 0008 ~                                    call    z, target
  40+ 0008                                      ENDM
  41+ 0008
  42+ 0008              CallIfMemFalse:         MACRO mem, target
  43+ 0008 ~                                    ld      a,(mem)
  44+ 0008 ~                                    and     a
  45+ 0008 ~                                    call    nz, target
  46+ 0008                                      ENDM
  47+ 0008
  48+ 0008              CallIfATrue:            MACRO target
  49+ 0008 ~                                    and     a
  50+ 0008 ~                                    call    z, target
  51+ 0008                                      ENDM
  52+ 0008
  53+ 0008              CallIfAFalse:           MACRO target
  54+ 0008 ~                                    and     a
  55+ 0008 ~                                    call    nz, target
  56+ 0008                                      ENDM
# file closed: ./Macros/callMacros.asm
  57  0008                                      INCLUDE "./Macros/carryFlagMacros.asm"
# file opened: ./Macros/carryFlagMacros.asm
   1+ 0008
   2+ 0008              SetCarryFlag:           MACRO
   3+ 0008 ~                                    scf
   4+ 0008                                      ENDM
   5+ 0008
   6+ 0008              ClearCarryFlag:	        MACRO
   7+ 0008 ~                                    or a
   8+ 0008                                      ENDM
   9+ 0008
  10+ 0008              FlipCarryFlag:          MACRO
  11+ 0008 ~                                    ccf
  12+ 0008                                      ENDM
  13+ 0008
# file closed: ./Macros/carryFlagMacros.asm
  58  0008                                      INCLUDE "./Macros/CopyByteMacros.asm"
# file opened: ./Macros/CopyByteMacros.asm
   1+ 0008              CopyByteAtHLixToA:		MACRO memloc
   2+ 0008 ~            						ex          de,hl                               ; save hl
   3+ 0008 ~            						ld          hl,memloc
   4+ 0008 ~            						add         hl,a
   5+ 0008 ~            						ld          a,(hl)                              ; get XX2[x]
   6+ 0008 ~            						ex          de,hl                               ; get hl back as we need it in loop
   7+ 0008              						ENDM
   8+ 0008
   9+ 0008              ; Increments IYL
  10+ 0008              ; Increments IHL
  11+ 0008              ; Gets value at hl and loads into Parameter 1 address
  12+ 0008
  13+ 0008              CopyByteAtNextHLiyl: 	MACRO memloc
  14+ 0008 ~            						inc         iyl                                 ;
  15+ 0008 ~            						inc         hl                                  ; vertex byte#1
  16+ 0008 ~            						ld          a,(hl)                              ;
  17+ 0008 ~            						ld          (memloc),a                     ; XX15+2 = (V),Y
  18+ 0008              						ENDM
  19+ 0008
  20+ 0008              ;------------------------------------------------------------------------------------------------------------------------------
  21+ 0008              CopyByteAtNextHL:   MACRO targetaddr
  22+ 0008 ~                                inc         hl                                  ; vertex byte#1
  23+ 0008 ~                                ld          a,(hl)                              ;
  24+ 0008 ~                                ld          (targetaddr),a                     ; SunXX15+2 = (V),Y
  25+ 0008                                  ENDM
# file closed: ./Macros/CopyByteMacros.asm
  59  0008                                      INCLUDE "./Macros/ldCopyMacros.asm"
# file opened: ./Macros/ldCopyMacros.asm
   1+ 0008              ZeroA:		            MACRO
   2+ 0008 ~                                    xor a
   3+ 0008                                      ENDM
   4+ 0008
   5+ 0008              SetATrue:               MACRO
   6+ 0008 ~                                    xor     a
   7+ 0008                                      ENDM
   8+ 0008
   9+ 0008              SetAFalse:              MACRO
  10+ 0008 ~                                    ld      a,$FF
  11+ 0008                                      ENDM
  12+ 0008
  13+ 0008              SetMemFalse             MACRO   mem
  14+ 0008 ~                                    ld      a,$FF
  15+ 0008 ~                                    ld      (mem),a
  16+ 0008                                      ENDM
  17+ 0008
  18+ 0008              SetMemTrue              MACRO   mem
  19+ 0008 ~                                    xor     a
  20+ 0008 ~                                    ld      (mem),a
  21+ 0008                                      ENDM
  22+ 0008
  23+ 0008              SetMemToN:              MACRO   mem,value
  24+ 0008 ~                                    ld      a,value
  25+ 0008 ~                                    ld      (mem),a
  26+ 0008                                      ENDM
  27+ 0008
  28+ 0008              ldCopyStringLen:        MACRO   source, target, strlen
  29+ 0008 ~                                    ld      hl,source
  30+ 0008 ~                                    ld      de, target
  31+ 0008 ~                                    ld      bc, strlen
  32+ 0008 ~                                    ldir
  33+ 0008                                      ENDM
  34+ 0008
  35+ 0008              ldCopyTextAtHLtoDE:     MACRO
  36+ 0008 ~            .CopyLoop:              ld      a,(hl)
  37+ 0008 ~                                    ld      (de),a
  38+ 0008 ~                                    cp      0
  39+ 0008 ~                                    jp      z,.DoneCopy
  40+ 0008 ~                                    inc     hl
  41+ 0008 ~                                    inc     de
  42+ 0008 ~                                    jr      .CopyLoop
  43+ 0008 ~            .DoneCopy:
  44+ 0008                                      ENDM
  45+ 0008
  46+ 0008              ldClearTextLoop:        MACRO   TextSize
  47+ 0008 ~                                    ld      b,a
  48+ 0008 ~                                    ld      a,TextSize
  49+ 0008 ~            .ClearLoop:             ld      (hl),a
  50+ 0008 ~                                    inc     hl
  51+ 0008 ~                                    djnz    .ClearLoop
  52+ 0008                                      ENDM
  53+ 0008
  54+ 0008              ldCopyByte:             MACRO memfrom, memto
  55+ 0008 ~                                    ld       a,(memfrom)
  56+ 0008 ~                                    ld       (memto),a
  57+ 0008                                      ENDM
  58+ 0008
  59+ 0008
  60+ 0008              ldCopyByteABS:          MACRO memfrom, memto
  61+ 0008 ~                                    ld       a,(memfrom)
  62+ 0008 ~                                    and		$7F
  63+ 0008 ~                                    ld       (memto),a
  64+ 0008                                      ENDM
  65+ 0008
  66+ 0008              ldAtHLtoMem:            MACRO   memto
  67+ 0008 ~                                    ld      a,(hl)
  68+ 0008 ~                                    ld      (memto),a
  69+ 0008                                      ENDM
  70+ 0008
  71+ 0008              ldCopy2Byte             MACRO  memfrom, memto
  72+ 0008 ~                                    ld       hl,(memfrom)
  73+ 0008 ~                                    ld       (memto),hl
  74+ 0008                                      ENDM
  75+ 0008
  76+ 0008              ldWriteConst            MACRO  memfrom, memto
  77+ 0008 ~                                    ld       a,memfrom
  78+ 0008 ~                                    ld       (memto),a
  79+ 0008                                      ENDM
  80+ 0008
  81+ 0008              ldWriteZero             MACRO  memto
  82+ 0008 ~                                    xor      a
  83+ 0008 ~                                    ld       (memto),a
  84+ 0008                                      ENDM
  85+ 0008
  86+ 0008              ldIXLaFromN:	        MACRO memfrom
  87+ 0008 ~                                    ld		a,(memfrom)
  88+ 0008 ~                                    ld		ixl,a
  89+ 0008                                      ENDM
  90+ 0008
  91+ 0008              ldIXHaFromN:	        MACRO memfrom
  92+ 0008 ~                                    ld		a,(memfrom)
  93+ 0008 ~                                    ld		ixh,a
  94+ 0008                                      ENDM
  95+ 0008
  96+ 0008              ldIYLaFromN:	        MACRO memfrom
  97+ 0008 ~                                    ld		a,(memfrom)
  98+ 0008 ~                                    ld		iyl,a
  99+ 0008                                      ENDM
 100+ 0008
 101+ 0008              ldIYHaFromN:	        MACRO memfrom
 102+ 0008 ~                                    ld		a,(memfrom)
 103+ 0008 ~                                    ld		iyh,a
 104+ 0008                                      ENDM
 105+ 0008
 106+ 0008              ldhlde:			        MACRO
 107+ 0008 ~                                    ld		h,d
 108+ 0008 ~                                    ld		l,e
 109+ 0008                                      ENDM
 110+ 0008
 111+ 0008              ldhlbc:			        MACRO
 112+ 0008 ~                                    ld		h,b
 113+ 0008 ~                                    ld		l,c
 114+ 0008                                      ENDM
 115+ 0008
 116+ 0008              ldbcde:			        MACRO
 117+ 0008 ~                                    ld		b,d
 118+ 0008 ~                                    ld		c,e
 119+ 0008                                      ENDM
 120+ 0008
 121+ 0008              lddebc:			        MACRO
 122+ 0008 ~                                    ld		d,b
 123+ 0008 ~                                    ld		e,c
 124+ 0008                                      ENDM
 125+ 0008
 126+ 0008              ldbchl:			        MACRO
 127+ 0008 ~                                    ld		b,h
 128+ 0008 ~                                    ld		c,l
 129+ 0008                                      ENDM
 130+ 0008
 131+ 0008              lddeiy:			        MACRO
 132+ 0008 ~                                    ld		d,iyh
 133+ 0008 ~                                    ld		e,iyl
 134+ 0008                                      ENDM
 135+ 0008
 136+ 0008              ldiyde:			        MACRO
 137+ 0008 ~                                    ld		iyh,d
 138+ 0008 ~                                    ld		iyl,e
 139+ 0008                                      ENDM
 140+ 0008
 141+ 0008
 142+ 0008              FourLDIInstrunctions:   MACRO
 143+ 0008 ~                                    ldi
 144+ 0008 ~                                    ldi
 145+ 0008 ~                                    ldi
 146+ 0008 ~                                    ldi
 147+ 0008                                      ENDM
 148+ 0008
 149+ 0008              FiveLDIInstrunctions:   MACRO
 150+ 0008 ~                                    ldi
 151+ 0008 ~                                    ldi
 152+ 0008 ~                                    ldi
 153+ 0008 ~                                    ldi
 154+ 0008 ~                                    ldi
 155+ 0008                                      ENDM
 156+ 0008
 157+ 0008              SixLDIInstrunctions:    MACRO
 158+ 0008 ~                                    ldi
 159+ 0008 ~                                    ldi
 160+ 0008 ~                                    ldi
 161+ 0008 ~                                    ldi
 162+ 0008 ~                                    ldi
 163+ 0008 ~                                    ldi
 164+ 0008                                      ENDM
 165+ 0008
 166+ 0008              EightLDIInstrunctions:  MACRO
 167+ 0008 ~            		                ldi
 168+ 0008 ~            		                ldi
 169+ 0008 ~            		                ldi
 170+ 0008 ~            		                ldi
 171+ 0008 ~            		                ldi
 172+ 0008 ~            		                ldi
 173+ 0008 ~            		                ldi
 174+ 0008 ~            		                ldi
 175+ 0008                                      ENDM
 176+ 0008
 177+ 0008              NineLDIInstrunctions:  MACRO
 178+ 0008 ~            		                ldi
 179+ 0008 ~            		                ldi
 180+ 0008 ~            		                ldi
 181+ 0008 ~            		                ldi
 182+ 0008 ~            		                ldi
 183+ 0008 ~            		                ldi
 184+ 0008 ~            		                ldi
 185+ 0008 ~            		                ldi
 186+ 0008 ~            		                ldi
 187+ 0008                                      ENDM
# file closed: ./Macros/ldCopyMacros.asm
  60  0008                                      INCLUDE "./Macros/ldIndexedMacros.asm"
# file opened: ./Macros/ldIndexedMacros.asm
   1+ 0008              GetByteAInTable:    MACRO table
   2+ 0008 ~                                ld          hl,table
   3+ 0008 ~                                add         hl,a
   4+ 0008 ~                                ld          a,(hl)
   5+ 0008                                  ENDM
   6+ 0008
   7+ 0008              HLWordAInTable:     MACRO table
   8+ 0008 ~                                ld          hl,table
   9+ 0008 ~                                sla         a
  10+ 0008 ~                                add         hl,a
  11+ 0008 ~                                ld          a,(hl)
  12+ 0008 ~                                inc         hl
  13+ 0008 ~                                ld          h,(hl)
  14+ 0008 ~                                ld          l,a
  15+ 0008                                  ENDM
  16+ 0008
  17+ 0008
  18+ 0008              ldAToHLixl:			MACRO value
  19+ 0008 ~            					ld          hl,value
  20+ 0008 ~            					ex          af,af'
  21+ 0008 ~            					ld          a,ixl
  22+ 0008 ~            					add         hl,a
  23+ 0008 ~            					ex          af,af'
  24+ 0008 ~            					ld          (hl),a
  25+ 0008              					ENDM
  26+ 0008
  27+ 0008              ldAToHLiyl:			MACRO value
  28+ 0008 ~            					ld          hl,value
  29+ 0008 ~            					ex          af,af'
  30+ 0008 ~            					ld          a,iyl
  31+ 0008 ~            					add         hl,a
  32+ 0008 ~            					ex          af,af'
  33+ 0008 ~            					ld          (hl),a
  34+ 0008              					ENDM
  35+ 0008
  36+ 0008
  37+ 0008              ldHLixlToA:         MACRO value
  38+ 0008 ~                                ld          hl,value
  39+ 0008 ~                                ex          af,af'
  40+ 0008 ~                                ld          a,ixl
  41+ 0008 ~                                add         hl,a
  42+ 0008 ~                                ld          a,(hl)
  43+ 0008                                  ENDM
  44+ 0008
  45+ 0008              ldHLiylToA:         MACRO value
  46+ 0008 ~                                ld          hl,value
  47+ 0008 ~                                ex          af,af'
  48+ 0008 ~                                ld          a,iyl
  49+ 0008 ~                                add         hl,a
  50+ 0008 ~                                ld          a,(hl)
  51+ 0008                                  ENDM
  52+ 0008
  53+ 0008              ldHLIdxAToA:        MACRO value
  54+ 0008 ~                                ld          hl,value
  55+ 0008 ~                                add         hl,a
  56+ 0008 ~                                ld          a,(hl)
  57+ 0008                                  ENDM
  58+ 0008
  59+ 0008              HLEquAddrAtHLPlusA: MACRO
  60+ 0008 ~                                sla         a
  61+ 0008 ~                                add         hl,a
  62+ 0008 ~                                ld          a,(hl)
  63+ 0008 ~                                inc         hl
  64+ 0008 ~                                ld          h,(hl)
  65+ 0008 ~                                ld          l,a
  66+ 0008                                  ENDM
# file closed: ./Macros/ldIndexedMacros.asm
  61  0008                                      INCLUDE "./Macros/jumpMacros.asm"
# file opened: ./Macros/jumpMacros.asm
   1+ 0008              JumpIfPositive:	        MACRO target
   2+ 0008 ~                                    jp		p, target
   3+ 0008                                      ENDM
   4+ 0008
   5+ 0008              JumpIfNegative:	        MACRO target
   6+ 0008 ~                                    jp		m, target
   7+ 0008                                      ENDM
   8+ 0008
   9+ 0008
  10+ 0008              JumpIfUnderflow:	    MACRO target
  11+ 0008 ~                                    jp		po, target
  12+ 0008                                      ENDM
  13+ 0008
  14+ 0008              JumpIfOverflow:	        MACRO target
  15+ 0008 ~                                    jp		po, target
  16+ 0008                                      ENDM
  17+ 0008
  18+ 0008
  19+ 0008              JumpIfNotZero:	        MACRO target
  20+ 0008 ~                                    jp	nz,target
  21+ 0008                                      ENDM
  22+ 0008
  23+ 0008              JumpIfZero:	            MACRO target
  24+ 0008 ~                                    jp	z,target
  25+ 0008                                      ENDM
  26+ 0008
  27+ 0008              ;.. Bit routines
  28+ 0008              JumpOnLeadSignSet:      MACRO   reg, target
  29+ 0008 ~                                    ld      a,reg
  30+ 0008 ~                                    and     SignOnly8Bit
  31+ 0008 ~                                    jp      nz,target
  32+ 0008                                      ENDM
  33+ 0008
  34+ 0008              JumpOnLeadSignClear:    MACRO   reg, target
  35+ 0008 ~                                    ld      a,reg
  36+ 0008 ~                                    and     SignOnly8Bit
  37+ 0008 ~                                    jp      z,target
  38+ 0008                                      ENDM
  39+ 0008
  40+ 0008              JumpOnLeadSignSetA:     MACRO   target
  41+ 0008 ~                                    and     SignOnly8Bit
  42+ 0008 ~                                    jp      nz,target
  43+ 0008                                      ENDM
  44+ 0008
  45+ 0008              JumpOnLeadSignClearA:   MACRO   target
  46+ 0008 ~                                    and     SignOnly8Bit
  47+ 0008 ~                                    jp      z,target
  48+ 0008                                      ENDM
  49+ 0008
  50+ 0008              JumpOnMemBitSet:        MACRO mem, bitnbr, target
  51+ 0008 ~                                    ld      a,(mem)
  52+ 0008 ~                                    bit 	bitnbr,a
  53+ 0008 ~                                    jp      nz,target
  54+ 0008                                      ENDM
  55+ 0008
  56+ 0008              JumpOnMemBitClear:      MACRO mem, bitnbr, target
  57+ 0008 ~                                    ld      a,(mem)
  58+ 0008 ~                                    bit 	bitnbr,a
  59+ 0008 ~                                    jp      z,target
  60+ 0008                                      ENDM
  61+ 0008
  62+ 0008              JumpOnABit5Set:         MACRO   target
  63+ 0008 ~                                    and     Bit5Only
  64+ 0008 ~                                    jp      nz,target
  65+ 0008                                      ENDM
  66+ 0008
  67+ 0008              JumpOnABit5Clear:       MACRO   target
  68+ 0008 ~                                    and     Bit5Only
  69+ 0008 ~                                    jp      z,target
  70+ 0008                                      ENDM
  71+ 0008
  72+ 0008              JumpOnBitMaskSet:       MACRO   bitmask, target
  73+ 0008 ~                                    and     bitmask
  74+ 0008 ~                                    jp      nz,target
  75+ 0008                                      ENDM
  76+ 0008
  77+ 0008              JumpOnBitMaskClear:     MACRO   bitmask, target
  78+ 0008 ~                                    and     bitmask
  79+ 0008 ~                                    jp      z,target
  80+ 0008                                      ENDM
  81+ 0008
  82+ 0008              JumpOnBitSet:           MACRO  reg, bitnbr, target
  83+ 0008 ~                                    bit 	bitnbr,reg
  84+ 0008 ~                                    jp      nz,target
  85+ 0008                                      ENDM
  86+ 0008
  87+ 0008              JumpOnBitClear:         MACRO  reg, bitnbr, target
  88+ 0008 ~                                    bit 	bitnbr,reg
  89+ 0008 ~                                    jp      z,target
  90+ 0008                                      ENDM
  91+ 0008
  92+ 0008              ; Comparison Routines
  93+ 0008              JumpIfAGTEusng:         MACRO
  94+ 0008 ~                                    jp		nc,target
  95+ 0008                                      ENDM
  96+ 0008
  97+ 0008              JumpIfAGTENusng:        MACRO reg,target
  98+ 0008 ~                                    cp     reg
  99+ 0008 ~                                    jp		nc,target
 100+ 0008                                      ENDM
 101+ 0008
 102+ 0008              JumpIfAGTEMemusng:      MACRO mem,target
 103+ 0008 ~                                    ld      hl,mem
 104+ 0008 ~                                    cp      (hl)
 105+ 0008 ~                                    jp		nc,target
 106+ 0008                                      ENDM
 107+ 0008
 108+ 0008              JumpIfALTMemusng:       MACRO mem,target
 109+ 0008 ~                                    ld      hl,mem
 110+ 0008 ~                                    cp      (hl)
 111+ 0008 ~                                    jp		c,target
 112+ 0008                                      ENDM
 113+ 0008
 114+ 0008              JumpIfMemGTENusng:      MACRO mem, value, target
 115+ 0008 ~                                    ld     a,(mem)
 116+ 0008 ~                                    cp     value
 117+ 0008 ~                                    jp	  nc,target
 118+ 0008                                      ENDM
 119+ 0008
 120+ 0008              JumpIfMemGTEMemusng:    MACRO mem, address, target
 121+ 0008 ~                                    ld   a,(mem)
 122+ 0008 ~                                    ld   hl,address
 123+ 0008 ~                                    cp   (hl)
 124+ 0008 ~                                    jp	  nc,target
 125+ 0008                                      ENDM
 126+ 0008
 127+ 0008              JumpIfMemEqMemusng:     MACRO mem, address, target
 128+ 0008 ~                                    ld   a,(mem)
 129+ 0008 ~                                    ld   hl,address
 130+ 0008 ~                                    cp   (hl)
 131+ 0008 ~                                    jp	  z,target
 132+ 0008                                      ENDM
 133+ 0008
 134+ 0008              JumpIfMemNeMemusng:     MACRO mem, address, target
 135+ 0008 ~                                    ld   a,(mem)
 136+ 0008 ~                                    ld   hl,address
 137+ 0008 ~                                    cp   (hl)
 138+ 0008 ~                                    jp	  nz,target
 139+ 0008                                      ENDM
 140+ 0008
 141+ 0008              JumpIfMemTrue:          MACRO mem, target
 142+ 0008 ~                                    ld      a,(mem)
 143+ 0008 ~                                    and     a
 144+ 0008 ~                                    jp      z, target
 145+ 0008                                      ENDM
 146+ 0008
 147+ 0008              JumpIfMemFalse:         MACRO mem, target
 148+ 0008 ~                                    ld      a,(mem)
 149+ 0008 ~                                    and     a
 150+ 0008 ~                                    jp      nz, target
 151+ 0008                                      ENDM
 152+ 0008
 153+ 0008              JumpIfATrue:            MACRO target
 154+ 0008 ~                                    and     a
 155+ 0008 ~                                    jp      z, target
 156+ 0008                                      ENDM
 157+ 0008
 158+ 0008              JumpIfAFalse:           MACRO target
 159+ 0008 ~                                    and     a
 160+ 0008 ~                                    jp      nz, target
 161+ 0008                                      ENDM
 162+ 0008
 163+ 0008              JumpIfALTusng:          MACRO target
 164+ 0008 ~                                    jp		c,target
 165+ 0008                                      ENDM
 166+ 0008
 167+ 0008              JumpIfALTNusng:         MACRO value, target
 168+ 0008 ~                                    cp      value
 169+ 0008 ~                                    jp		c, target
 170+ 0008                                      ENDM
 171+ 0008
 172+ 0008              JumpIfMemLTNusng:       MACRO mem, value, target
 173+ 0008 ~                                    ld      a,(mem)
 174+ 0008 ~                                    cp      value
 175+ 0008 ~                                    jp	  c,target
 176+ 0008                                      ENDM
 177+ 0008
 178+ 0008              JumpIfMemLTMemusng:     MACRO mem, value, target
 179+ 0008 ~                                    ld    a,(mem)
 180+ 0008 ~                                    ld    hl,value
 181+ 0008 ~                                    cp    (hl)
 182+ 0008 ~                                    jp	  c,target
 183+ 0008                                      ENDM
 184+ 0008
 185+ 0008              JumpIfMemEqNusng:       MACRO mem,value,target
 186+ 0008 ~                                    ld  a,(mem)
 187+ 0008 ~                                    cp  value
 188+ 0008 ~                                    jp  z,target
 189+ 0008                                      ENDM
 190+ 0008
 191+ 0008              JumpIfMemNeNusng:       MACRO mem,value,target
 192+ 0008 ~                                    ld  a,(mem)
 193+ 0008 ~                                    cp  value
 194+ 0008 ~                                    jp  nz,target
 195+ 0008                                      ENDM
 196+ 0008
 197+ 0008              JumpIfMemZero:          MACRO mem,target
 198+ 0008 ~                                    ld  a,(mem)
 199+ 0008 ~                                    and a
 200+ 0008 ~                                    jp  z,target
 201+ 0008                                      ENDM
 202+ 0008
 203+ 0008              JumpIfMemNotZero:       MACRO mem,target
 204+ 0008 ~                                    ld  a,(mem)
 205+ 0008 ~                                    and a
 206+ 0008 ~                                    jp  nz,target
 207+ 0008                                      ENDM
 208+ 0008
 209+ 0008              JumpIfALTMemHLusng:     MACRO target
 210+ 0008 ~                                    cp    (hl)
 211+ 0008 ~                                    jp	  c,target
 212+ 0008                                      ENDM
 213+ 0008
 214+ 0008              JumpIfANENusng:         MACRO value, target
 215+ 0008 ~                                    cp     value
 216+ 0008 ~                                    jp      nz,target
 217+ 0008                                      ENDM
 218+ 0008
 219+ 0008              JumpIfANEMemusng:       MACRO  value, target
 220+ 0008 ~                                    ld    hl,value
 221+ 0008 ~                                    cp    (hl)
 222+ 0008 ~                                    jp      nz,target
 223+ 0008                                      ENDM
 224+ 0008
 225+ 0008              JumpIfAEqNusng:         MACRO value, target
 226+ 0008 ~                                    cp     value
 227+ 0008 ~                                    jp      z,target
 228+ 0008                                      ENDM
 229+ 0008
 230+ 0008              JumpIfAIsZero:	        MACRO target
 231+ 0008 ~                                    and a   ; cp 0 - changed to and a for optimisation but affects other flags
 232+ 0008 ~                                    jp	z, target
 233+ 0008                                      ENDM
 234+ 0008
 235+ 0008              JumpIfAIsNotZero:       MACRO target
 236+ 0008 ~                                    cp	0
 237+ 0008 ~                                    jp	nz,target
 238+ 0008                                      ENDM
 239+ 0008
 240+ 0008              IfResultZeroGoto:	    MACRO target
 241+ 0008 ~                                    jp	z,target
 242+ 0008                                      ENDM
 243+ 0008
 244+ 0008              IfResultNotZeroGoto:    MACRO target
 245+ 0008 ~                                    jp	nz,target
 246+ 0008                                      ENDM
 247+ 0008
# file closed: ./Macros/jumpMacros.asm
  62  0008                                      INCLUDE "./Macros/MathsMacros.asm"
# file opened: ./Macros/MathsMacros.asm
   1+ 0008
   2+ 0008
   3+ 0008              ApplyMyRollToVector:    MACRO angle, vectorX, vectorY
   4+ 0008 ~                                    ldCopyByte angle,varQ               ; Set Q = a = alpha (the roll angle to rotate through)
   5+ 0008 ~                                    ldCopy2Byte vectorY, varR           ; RS =  nosev_y
   6+ 0008 ~                                    ldCopyByte  vectorX, varP           ; set P to nosevX lo (may be redundant)
   7+ 0008 ~                                    ld a,(vectorX+1)                    ; Set A = -nosev_x_hi
   8+ 0008 ~                                    xor $80                             ;
   9+ 0008 ~                                    call  madXAequQmulAaddRS            ; Set (A X) = Q * A + (S R) = = alpha * -nosev_x_hi + nosev_y
  10+ 0008 ~                                    ld  (vectorY),de                    ; nosev_y = nosev_y - alpha * nosev_x_hi
  11+ 0008 ~                                    ldCopy2Byte vectorX, varR           ; Set (S R) = nosev_x
  12+ 0008 ~                                    ld  a,(vectorY+1)                   ;  Set A = nosev_y_hi
  13+ 0008 ~                                    call madXAequQmulAaddRS             ; Set (A X) = Q * A + (S R)
  14+ 0008 ~                                    ld  (vectorX),de                    ; nosev_x = nosev_x + alpha * nosev_y_hi
  15+ 0008                                      ENDM
  16+ 0008
  17+ 0008              SignedHLTo2C:           MACRO
  18+ 0008 ~                                    bit     7,h
  19+ 0008 ~                                    jr      z,.Done2c
  20+ 0008 ~                                    ld      a,h
  21+ 0008 ~                                    and     SignMask8Bit
  22+ 0008 ~                                    ld      h,a
  23+ 0008 ~                                    NegHL
  24+ 0008 ~            .Done2c:
  25+ 0008                                      ENDM
  26+ 0008
  27+ 0008              MemSignedTo2C:          MACRO   memfrom
  28+ 0008 ~                                    ld      hl,(memfrom)
  29+ 0008 ~                                    bit     7,h
  30+ 0008 ~                                    jr      z,.Done2c
  31+ 0008 ~                                    ld      a,h
  32+ 0008 ~                                    and     SignMask8Bit
  33+ 0008 ~                                    ld      h,a
  34+ 0008 ~            .Done2c:                ld      (memfrom),hl
  35+ 0008                                      ENDM
  36+ 0008
  37+ 0008
  38+ 0008                  ;returns result in H
  39+ 0008              EDiv10Inline:           MACRO
  40+ 0008 ~                                    ld      d,0
  41+ 0008 ~                                    ld      hl,de
  42+ 0008 ~                                    add     hl,hl
  43+ 0008 ~                                    add     hl,de
  44+ 0008 ~                                    add     hl,hl
  45+ 0008 ~                                    add     hl,hl
  46+ 0008 ~                                    add     hl,de
  47+ 0008 ~                                    add     hl,hl
  48+ 0008                                      ENDM
  49+ 0008
# file closed: ./Macros/MathsMacros.asm
  63  0008                                      INCLUDE "./Macros/MMUMacros.asm"
# file opened: ./Macros/MMUMacros.asm
   1+ 0008              MMUSelectROMS:       MACRO
   2+ 0008 ~                                 nextreg EXSDOSMMU0,        BankROM
   3+ 0008 ~                                 nextreg EXSDOSMMU1,        BankROM
   4+ 0008                                   ENDM
   5+ 0008
   6+ 0008              MMUSelectSpriteBank: MACRO
   7+ 0008 ~            					 nextreg SpritememMMU,	    BankSPRITE
   8+ 0008              					 ENDM
   9+ 0008
  10+ 0008              MMUSelectConsoleBank: MACRO
  11+ 0008 ~            					 nextreg ConsoleImageDataMMU,  BankConsole
  12+ 0008              					 ENDM
  13+ 0008
  14+ 0008              MMUSelectLayer1: 	 MACRO
  15+ 0008 ~            					 nextreg L1memMMU,		    BankLAYER1
  16+ 0008              					 ENDM
  17+ 0008
  18+ 0008              MMUSelectLayer2: 	 MACRO
  19+ 0008 ~            					 nextreg L2memMMU,		    BankLAYER2
  20+ 0008              					 ENDM
  21+ 0008
  22+ 0008              MMUSelectResetUniv:  MACRO
  23+ 0008 ~                                 nextreg  ResetUniverseMMU, BankResetUniv
  24+ 0008                                   ENDM
  25+ 0008
  26+ 0008              MMUSelectShipBank1:  MACRO
  27+ 0008 ~            					 nextreg ShipModelMMU,	    BankShipModels1
  28+ 0008              					 ENDM
  29+ 0008              MMUSelectShipBank2:  MACRO
  30+ 0008 ~            					 nextreg ShipModelMMU,	    BankShipModels2
  31+ 0008              					 ENDM
  32+ 0008              MMUSelectShipBank3:  MACRO
  33+ 0008 ~            					 nextreg ShipModelMMU,	    BankShipModels3
  34+ 0008              					 ENDM
  35+ 0008              MMUSelectShipBank4:  MACRO
  36+ 0008 ~            					 nextreg ShipModelMMU,	    BankShipModels4
  37+ 0008              					 ENDM
  38+ 0008
  39+ 0008              MMUSelectShipBankA   MACRO
  40+ 0008 ~            					 nextreg ShipModelMMU,	    a
  41+ 0008              					 ENDM
  42+ 0008
  43+ 0008              MMUSelectShipBankN:  MACRO value
  44+ 0008 ~            					 nextreg ShipModelMMU,	    value
  45+ 0008              					 ENDM
  46+ 0008
  47+ 0008              MMUSelectCommander:	 MACRO
  48+ 0008 ~                                 nextreg CommanderMMU,       BankCommander
  49+ 0008              					 ENDM
  50+ 0008
  51+ 0008              MMUSelectStockTable: MACRO
  52+ 0008 ~                                 nextreg StockTableMMU,     BankStockTable
  53+ 0008              					 ENDM
  54+ 0008
  55+ 0008              MMUSelectCpySrcA:    MACRO
  56+ 0008 ~                                 nextreg DMACpySourceMMU,	a
  57+ 0008              					 ENDM
  58+ 0008
  59+ 0008              MMUSelectCpySrcN:    MACRO value
  60+ 0008 ~                                 nextreg DMACpySourceMMU,	value
  61+ 0008              					 ENDM
  62+ 0008
  63+ 0008              MMUSelectSun:        MACRO
  64+ 0008 ~                                 nextreg SunMMU,            BankSunData
  65+ 0008                                   ENDM
  66+ 0008
  67+ 0008              MMUSelectPlanet:     MACRO
  68+ 0008 ~                                 nextreg PlanetMMU,         PlanetBankAddr
  69+ 0008                                   ENDM
  70+ 0008
  71+ 0008              MMUSelectUniverseA:  MACRO
  72+ 0008 ~                                 add    a,BankUNIVDATA0
  73+ 0008 ~                                 nextreg UniverseMMU,       a
  74+ 0008                                   ENDM
  75+ 0008
  76+ 0008              MMUSelectUniverseN:  MACRO value
  77+ 0008 ~                                 nextreg UniverseMMU,       BankUNIVDATA0+value
  78+ 0008                                   ENDM
  79+ 0008
  80+ 0008              MMUSelectGalaxyA:    MACRO
  81+ 0008 ~                                 nextreg GalaxyDataMMU,       a
  82+ 0008                                   ENDM
  83+ 0008
  84+ 0008              MMUSelectGalaxyN:    MACRO value
  85+ 0008 ~                                 nextreg GalaxyDataMMU,     BankGalaxyData0+value
  86+ 0008                                   ENDM
  87+ 0008              MMUSelectGalaxyACopy:MACRO
  88+ 0008 ~                                 nextreg UniverseMMU,       a
  89+ 0008                                   ENDM
  90+ 0008
  91+ 0008              MMUSelectUniverseAbs:MACRO value
  92+ 0008 ~                                 nextreg UniverseMMU,       value
  93+ 0008                                   ENDM
  94+ 0008
  95+ 0008              MMUSelectMenuGalCht: MACRO
  96+ 0008 ~                                 nextreg MenuGalChtMMU,		BankMenuGalCht
  97+ 0008              					 ENDM
  98+ 0008
  99+ 0008              MMUSelectMenuShrCht: MACRO
 100+ 0008 ~            					 nextreg MenuShrChtMMU,		BankMenuShrCht
 101+ 0008              					 ENDM
 102+ 0008
 103+ 0008              MMUSelectMenuInvent: MACRO
 104+ 0008 ~                                 nextreg MenuInventMMU,		BankMenuInvent
 105+ 0008              					 ENDM
 106+ 0008
 107+ 0008              MMUSelectMenuSystem: MACRO
 108+ 0008 ~                                 nextreg MenuSystemMMU,		BankMenuSystem
 109+ 0008              					 ENDM
 110+ 0008
 111+ 0008              MMUSelectMenuMarket: MACRO
 112+ 0008 ~                                 nextreg MenuMarketMMU,		BankMenuMarket
 113+ 0008              					 ENDM
 114+ 0008
 115+ 0008              MMUSelectMenuStatus: MACRO
 116+ 0008 ~                                 nextreg MenuStatusMMU,		BankMenuStatus
 117+ 0008              					 ENDM
 118+ 0008
 119+ 0008              MMUSelectViewFront:  MACRO
 120+ 0008 ~                                 nextreg ScreenBankMMU,		BankFrontView
 121+ 0008              					 ENDM
 122+ 0008
 123+ 0008              MMUSelectScreenA:    MACRO
 124+ 0008 ~                                 nextreg ScreenBankMMU,		a
 125+ 0008              					 ENDM
 126+ 0008
# file closed: ./Macros/MMUMacros.asm
  64  0008                                      INCLUDE "./Macros/NegateMacros.asm"
# file opened: ./Macros/NegateMacros.asm
   1+ 0008
   2+ 0008              NegIY:			    MACRO
   3+ 0008 ~                                xor a
   4+ 0008 ~                                sub iyl
   5+ 0008 ~                                ld iyl,a
   6+ 0008 ~                                sbc a,a
   7+ 0008 ~                                sub iyh
   8+ 0008 ~                                ld iyh,a
   9+ 0008                                  ENDM
  10+ 0008
  11+ 0008              NegHL:			    MACRO
  12+ 0008 ~                                xor a
  13+ 0008 ~                                sub l
  14+ 0008 ~                                ld l,a
  15+ 0008 ~                                sbc a,a
  16+ 0008 ~                                sub h
  17+ 0008 ~                                ld h,a
  18+ 0008                                  ENDM
  19+ 0008
  20+ 0008              NegDE:			    MACRO
  21+ 0008 ~                                xor a
  22+ 0008 ~                                sub e
  23+ 0008 ~                                ld e,a
  24+ 0008 ~                                sbc a,a
  25+ 0008 ~                                sub d
  26+ 0008 ~                                ld d,a
  27+ 0008                                  ENDM
  28+ 0008
  29+ 0008              NegBC:			    MACRO
  30+ 0008 ~                                xor a
  31+ 0008 ~                                sub c
  32+ 0008 ~                                ld c,a
  33+ 0008 ~                                sbc a,a
  34+ 0008 ~                                sub  b
  35+ 0008 ~                                ld b,a
  36+ 0008                                  ENDM
  37+ 0008
  38+ 0008              NegH                MACRO
  39+ 0008 ~                                ld      a,h
  40+ 0008 ~                                neg
  41+ 0008 ~                                ld      h,a
  42+ 0008                                  ENDM
  43+ 0008
  44+ 0008              NegD                MACRO
  45+ 0008 ~                                ld      a,d
  46+ 0008 ~                                neg
  47+ 0008 ~                                ld      d,a
  48+ 0008                                  ENDM
  49+ 0008
  50+ 0008              NegB                MACRO
  51+ 0008 ~                                ld      a,b
  52+ 0008 ~                                neg
  53+ 0008 ~                                ld      b,a
  54+ 0008                                  ENDM
  55+ 0008
# file closed: ./Macros/NegateMacros.asm
  65  0008                                      INCLUDE "./Macros/returnMacros.asm"
# file opened: ./Macros/returnMacros.asm
   1+ 0008              ReturnOnBitSet:         MACRO  reg, bitnbr,
   2+ 0008 ~                                    bit 	bitnbr,reg
   3+ 0008 ~                                    ret     nz
   4+ 0008                                      ENDM
   5+ 0008
   6+ 0008              ReturnOnMemBitSet:      MACRO mem, bitnbr
   7+ 0008 ~                                    ld   a,(mem)
   8+ 0008 ~                                    bit 	bitnbr,a
   9+ 0008 ~                                    ret     nz
  10+ 0008                                      ENDM
  11+ 0008
  12+ 0008              ReturnOnBitClear:       MACRO reg, bitnbr
  13+ 0008 ~                                    bit 	bitnbr,reg
  14+ 0008 ~                                    ret		z
  15+ 0008                                      ENDM
  16+ 0008
  17+ 0008              ReturnOnMemBitClear:    MACRO mem, bitnbr
  18+ 0008 ~                                    ld     a,(mem)
  19+ 0008 ~                                    bit 	bitnbr,a
  20+ 0008 ~                                    ret		z
  21+ 0008                                      ENDM
  22+ 0008
  23+ 0008              ReturnIfMemFalse:       MACRO   mem
  24+ 0008 ~                                    ld      a,(mem)
  25+ 0008 ~                                    and     a
  26+ 0008 ~                                    ret     nz
  27+ 0008                                      ENDM
  28+ 0008
  29+ 0008              ReturnIfMemTrue:        MACRO   mem
  30+ 0008 ~                                    ld      a,(mem)
  31+ 0008 ~                                    and     a
  32+ 0008 ~                                    ret     z
  33+ 0008                                      ENDM
  34+ 0008
  35+ 0008              ReturnIfAIsZero:        MACRO
  36+ 0008 ~                                    and     a
  37+ 0008 ~                                    ret     z
  38+ 0008                                      ENDM
  39+ 0008
  40+ 0008              ReturnIfMemisZero:      MACRO mem
  41+ 0008 ~                                    ld   a,(mem)
  42+ 0008 ~                                    and a
  43+ 0008 ~                                    ret    z
  44+ 0008                                      ENDM
  45+ 0008
  46+ 0008              ReturnIfBitMaskClear    MACRO   bitmask
  47+ 0008 ~                                    and     bitmask
  48+ 0008 ~                                    ret     z
  49+ 0008                                      ENDM
  50+ 0008
  51+ 0008              ReturnIfBitMaskSet      MACRO   bitmask
  52+ 0008 ~                                    and     bitmask
  53+ 0008 ~                                    ret     nz
  54+ 0008                                      ENDM
  55+ 0008
  56+ 0008              ReturnIfMemEquN:        MACRO mem, value
  57+ 0008 ~                                    ld     a,(mem)
  58+ 0008 ~                                    cp     value
  59+ 0008 ~                                    ret    nz
  60+ 0008                                      ENDM
  61+ 0008
  62+ 0008              ReturnIfMemNeNusng:     MACRO mem, value
  63+ 0008 ~                                    ld   a,(mem)
  64+ 0008 ~                                    cp     value
  65+ 0008 ~                                    ret    z
  66+ 0008                                      ENDM
  67+ 0008
  68+ 0008              ReturnIfRegNotZero:     MACRO reg
  69+ 0008 ~                                    ld      a, reg
  70+ 0008 ~                                    and     a
  71+ 0008 ~                                    ret     nz
  72+ 0008                                      ENDM
  73+ 0008
  74+ 0008              ReturnIfANotZero:       MACRO
  75+ 0008 ~                                    and     a
  76+ 0008 ~                                    ret     nz
  77+ 0008                                      ENDM
  78+ 0008
  79+ 0008              ReturnIfNotZero:        MACRO
  80+ 0008 ~                                    ret     nz
  81+ 0008                                      ENDM
  82+ 0008
  83+ 0008
  84+ 0008              ReturnIfNegative:       MACRO
  85+ 0008 ~                                    ret     m
  86+ 0008                                      ENDM
  87+ 0008
  88+ 0008
  89+ 0008              ReturnIfMemNotZero:     MACRO mem
  90+ 0008 ~                                    ld     a,(mem)
  91+ 0008 ~                                    and     a
  92+ 0008 ~                                    ret    nz
  93+ 0008                                      ENDM
  94+ 0008
  95+ 0008              ReturnIfAGTEusng:       MACRO value
  96+ 0008 ~                                    cp    value
  97+ 0008 ~                                    ret	 nc
  98+ 0008                                      ENDM
  99+ 0008
 100+ 0008              ReturnIfALTNusng:       MACRO value
 101+ 0008 ~                                    cp    value
 102+ 0008 ~                                    ret	 c
 103+ 0008                                      ENDM
 104+ 0008
 105+ 0008              ReturnIfAGTENusng:      MACRO value
 106+ 0008 ~                                    cp    value
 107+ 0008 ~                                    ret	 nc
 108+ 0008                                      ENDM
 109+ 0008
 110+ 0008              ReturnIfAGTEMemusng:    MACRO value
 111+ 0008 ~                                    ld      hl,value
 112+ 0008 ~                                    cp      (hl)
 113+ 0008 ~                                    ret	    nc
 114+ 0008                                      ENDM
 115+ 0008
 116+ 0008              ReturnIfANENusng:       MACRO value
 117+ 0008 ~                                    cp      value
 118+ 0008 ~                                    ret     nz
 119+ 0008                                      ENDM
 120+ 0008
 121+ 0008              ReturnIfAEqNusng:       MACRO value
 122+ 0008 ~                                    cp      value
 123+ 0008 ~                                    ret     z
 124+ 0008                                      ENDM
 125+ 0008
# file closed: ./Macros/returnMacros.asm
  66  0008                                      INCLUDE "./Macros/ShiftMacros.asm"
# file opened: ./Macros/ShiftMacros.asm
   1+ 0008              ShiftIYRight1: MACRO
   2+ 0008 ~            			   ld 	a,iyh
   3+ 0008 ~            			   srl 	a
   4+ 0008 ~            			   ld	iyh,a
   5+ 0008 ~            			   ld 	a,iyl
   6+ 0008 ~            			   rra
   7+ 0008 ~            			   ld	iyl,a
   8+ 0008              			   ENDM
   9+ 0008
  10+ 0008              ShiftHLRight1: MACRO
  11+ 0008 ~            			   srl h
  12+ 0008 ~            			   rr  l
  13+ 0008              			   ENDM
  14+ 0008
  15+ 0008              ShiftDERight1: MACRO
  16+ 0008 ~            			   srl d
  17+ 0008 ~            			   rr  e
  18+ 0008              			   ENDM
  19+ 0008
  20+ 0008              ShiftBCRight1: MACRO
  21+ 0008 ~            			   srl b
  22+ 0008 ~            			   rr  c
  23+ 0008              			   ENDM
  24+ 0008
  25+ 0008
  26+ 0008
  27+ 0008              ShiftHLDiv8:   MACRO
  28+ 0008 ~            			   srl h
  29+ 0008 ~            			   rr  l
  30+ 0008 ~            			   srl h
  31+ 0008 ~            			   rr  l
  32+ 0008 ~            			   srl h
  33+ 0008 ~            			   rr  l
  34+ 0008              			   ENDM
  35+ 0008
  36+ 0008              ShiftHLLeft1:  MACRO
  37+ 0008 ~            			   sla l
  38+ 0008 ~            			   rl  h
  39+ 0008              			   ENDM
  40+ 0008
  41+ 0008              ShiftDELeft1:  MACRO
  42+ 0008 ~            			   sla e
  43+ 0008 ~            			   rl  d
  44+ 0008              			   ENDM
  45+ 0008
  46+ 0008
  47+ 0008              RollDELeft1:   MACRO
  48+ 0008 ~                           rl  e
  49+ 0008 ~                           rl  d
  50+ 0008                             ENDM
  51+ 0008
  52+ 0008              ShiftBCLeft1:  MACRO
  53+ 0008 ~            			   sla c
  54+ 0008 ~            			   rl  b
  55+ 0008              			   ENDM
  56+ 0008
  57+ 0008
  58+ 0008              ShiftMem16Right1:   MACRO memaddr
  59+ 0008 ~                                ld    hl,(memaddr)
  60+ 0008 ~                                srl   h
  61+ 0008 ~                                rr    l
  62+ 0008 ~                                ld    (memaddr),hl
  63+ 0008                                  ENDM
  64+ 0008
  65+ 0008              ShiftMem8Right1:    MACRO memaddr
  66+ 0008 ~                                ld      a,(memaddr)
  67+ 0008 ~                                srl     a
  68+ 0008 ~                                ld      (memaddr),a
  69+ 0008                                  ENDM
  70+ 0008
  71+ 0008
  72+ 0008              ShiftMem8Left1A:    MACRO memaddr
  73+ 0008 ~                                ld      a,(memaddr)
  74+ 0008 ~                                sla     a
  75+ 0008 ~                                ld      (memaddr),a
  76+ 0008                                  ENDM
  77+ 0008
# file closed: ./Macros/ShiftMacros.asm
  67  0008                                      INCLUDE "./Macros/signBitMacros.asm"
# file opened: ./Macros/signBitMacros.asm
   1+ 0008              ClearSignBitMem:        MACRO mem
   2+ 0008 ~                                    ld      a,(mem)
   3+ 0008 ~                                    and     SignMask8Bit
   4+ 0008 ~                                    ld      (mem),a
   5+ 0008                                      ENDM
   6+ 0008
   7+ 0008              SetSignBitMem:          MACRO   mem
   8+ 0008 ~                                    ld      a,(mem)
   9+ 0008 ~                                    or      SignOnly8Bit
  10+ 0008 ~                                    ld      (mem),a
  11+ 0008                                      ENDM
  12+ 0008
  13+ 0008              FlipSignMem:            MACRO mem
  14+ 0008 ~                                    ld  a,(mem)
  15+ 0008 ~                                    xor SignOnly8Bit
  16+ 0008 ~                                    ld  (mem),a
  17+ 0008                                      ENDM
  18+ 0008
  19+ 0008              ClearSignBit:           MACRO reg
  20+ 0008 ~                                    ld      a,reg
  21+ 0008 ~                                    and     SignMask8Bit
  22+ 0008 ~                                    ld      reg,a
  23+ 0008                                      ENDM
  24+ 0008
  25+ 0008              SetSignBit:             MACRO   reg
  26+ 0008 ~                                    ld      a,reg
  27+ 0008 ~                                    or      SignOnly8Bit
  28+ 0008 ~                                    ld      reg,a
  29+ 0008                                      ENDM
  30+ 0008
  31+ 0008              FlipSignBit:            MACRO   reg
  32+ 0008 ~                                    ld      a,reg
  33+ 0008 ~                                    xor     SignOnly8Bit
  34+ 0008 ~                                    ld      reg,a
  35+ 0008                                      ENDM
  36+ 0008
  37+ 0008              ClearSignBitA:          MACRO
  38+ 0008 ~                                    and     SignMask8Bit
  39+ 0008                                      ENDM
  40+ 0008
  41+ 0008              SetSignBitA:            MACRO
  42+ 0008 ~                                    or      SignOnly8Bit
  43+ 0008                                      ENDM
  44+ 0008
  45+ 0008              FlipSignBitA:           MACRO
  46+ 0008 ~                                    xor     SignOnly8Bit
  47+ 0008                                      ENDM
  48+ 0008
# file closed: ./Macros/signBitMacros.asm
  68  0008                  INCLUDE "./Variables/general_variables_macros.asm"
# file opened: ./Variables/general_variables_macros.asm
   1+ 0008              ; limited to 255 character length
   2+ 0008              CountLengthHL:          MACRO   Limiter
   3+ 0008 ~                                    ld      de,hl
   4+ 0008 ~                                    ld      bc,Limiter
   5+ 0008 ~                                    xor     a
   6+ 0008 ~                                    cpir
   7+ 0008 ~                                    ClearCarryFlag
   8+ 0008 ~                                    sbc     hl,de
   9+ 0008 ~                                    ld      a,l
  10+ 0008 ~                                    ret
  11+ 0008                                      ENDM
  12+ 0008
  13+ 0008              HalfLengthHL:           MACRO
  14+ 0008 ~                                    ld      b,0
  15+ 0008 ~            .CountLenLoop:          ld      a,(hl)
  16+ 0008 ~                                    cp      0
  17+ 0008 ~                                    jr      z,.DoneCount
  18+ 0008 ~                                    inc     b
  19+ 0008 ~                                    inc     hl
  20+ 0008 ~                                    jr      .CountLenLoop
  21+ 0008 ~            .DoneCount:             ld      a,32
  22+ 0008 ~                                    sub     b
  23+ 0008 ~                                    sra     a
  24+ 0008                                      ENDM
  25+ 0008
  26+ 0008              MakeInnocentMacro:		MACRO
  27+ 0008 ~            						xor		a
  28+ 0008 ~            						ld		(FugitiveInnocentStatus),a
  29+ 0008              						ENDM
  30+ 0008
  31+ 0008              NoEscapePodMacro:		MACRO
  32+ 0008 ~            						xor		a
  33+ 0008 ~            						ld		(EscapePod),a
  34+ 0008              						ENDM
  35+ 0008
  36+ 0008              MaxFuelLevel            EQU     70              ; 7.0 light years max
  37+ 0008              MaxFuelMacro:			MACRO
  38+ 0008 ~            						ld		a,MaxFuelLevel
  39+ 0008 ~            						ld		(Fuel),a
  40+ 0008              						ENDM
  41+ 0008
  42+ 0008              MaxThrottle:            MACRO
  43+ 0008 ~                                    ld      a,(SHIPMAXSPEED)
  44+ 0008 ~                                    ld      (DELTA),a
  45+ 0008 ~                                    ld      d,a
  46+ 0008 ~                                    ld      e,4
  47+ 0008 ~                                    mul
  48+ 0008 ~                                    ld      (DELT4Lo),de
  49+ 0008                                      ENDM
  50+ 0008
  51+ 0008              ZeroThrottle:           MACRO
  52+ 0008 ~                                    xor     a
  53+ 0008 ~                                    ld      (DELTA),a
  54+ 0008 ~                                    ld      (DELT4Lo),a
  55+ 0008 ~                                    ld      (DELT4Lo+1),a
  56+ 0008                                      ENDM
  57+ 0008
  58+ 0008              ZeroPitch:              MACRO
  59+ 0008 ~                                    xor     a
  60+ 0008 ~                                    ld      (BET2),a
  61+ 0008 ~                                    ld      (BET2FLIP),a
  62+ 0008 ~                                    ld      (JSTY),a
  63+ 0008 ~                                    ld      (BETA),a
  64+ 0008                                      ENDM
  65+ 0008
  66+ 0008              ZeroRoll:               MACRO
  67+ 0008 ~                                    xor     a                              ; zero roll and climb
  68+ 0008 ~                                    ld      (ALP2),a
  69+ 0008 ~                                    ld      (ALP2FLIP),a
  70+ 0008 ~                                    ld      (JSTX),a
  71+ 0008 ~                                    ld      (ALPHA),a
  72+ 0008                                      ENDM
  73+ 0008
  74+ 0008              CorrectPostJumpFuel:    MACRO
  75+ 0008 ~                                    ld      a,(Fuel)
  76+ 0008 ~                                    ld      hl,Distance
  77+ 0008 ~                                    sub     a,(hl)
  78+ 0008 ~                                    ld      (Fuel),a
  79+ 0008                                      ENDM
  80+ 0008
  81+ 0008              AnyMissilesLeft:        MACRO
  82+ 0008 ~                                    ld      a,(NbrMissiles)
  83+ 0008 ~                                    and     a
  84+ 0008                                      ENDM
  85+ 0008
  86+ 0008              SetMissileTargetA:      MACRO
  87+ 0008 ~                                    ld      (MissileTarget),a
  88+ 0008                                      ENDM
  89+ 0008
  90+ 0008              IsMissileLockedOn:      MACRO
  91+ 0008 ~                                    ld      a,(MissileTarget)
  92+ 0008 ~                                    cp      $FF
  93+ 0008 ~                                    ret     z
  94+ 0008 ~                                    ReturnIfSlotAEmpty                  ; if target slot is empty
  95+ 0008 ~                                    ret                                 ; will return as nz now
  96+ 0008                                      ENDM
  97+ 0008
  98+ 0008              ClearMissileTarget:     MACRO
  99+ 0008 ~                                    xor     a                           ; Set missile target to FF
 100+ 0008 ~                                    dec     a
 101+ 0008 ~                                    ld      (MissileTarget),a
 102+ 0008 ~                                    SetMemFalse MissileLaunchFlag
 103+ 0008                                      ENDM
 104+ 0008
 105+ 0008              ClearECM:               MACRO
 106+ 0008 ~                                    xor     a
 107+ 0008 ~                                    ld      (ECMLoopA),a
 108+ 0008 ~                                    ld      (ECMLoopB),a
 109+ 0008                                      ENDM
 110+ 0008
 111+ 0008              ChargeEnergyAndShields: MACRO
 112+ 0008 ~                                    ld      a,$FF
 113+ 0008 ~                                    ld      (PlayerEnergy),a
 114+ 0008 ~                                    ld      (ForeShield),a
 115+ 0008 ~                                    ld      (AftShield),a
 116+ 0008                                      ENDM
 117+ 0008
 118+ 0008              CopyPresentSystemToTarget: MACRO
 119+ 0008 ~                                    ld      hl,(PresentSystemX)
 120+ 0008 ~                                    ld      (TargetSystemX),hl
 121+ 0008                                      ENDM
 122+ 0008
 123+ 0008              CopyTargetSystemToPresent: MACRO
 124+ 0008 ~                                    ld      hl,(TargetSystemX)
 125+ 0008 ~                                    ld      (PresentSystemX),hl
 126+ 0008                                      ENDM
 127+ 0008
 128+ 0008              HalveFugitiveStatus:    MACRO
 129+ 0008 ~                                    ld      hl,FugitiveInnocentStatus
 130+ 0008 ~                                    srl     (hl)
 131+ 0008                                      ENDM
 132+ 0008
 133+ 0008              ClearForceTransition    MACRO
 134+ 0008 ~                                    ld      a,$FF
 135+ 0008 ~                                    ld      (ScreenTransitionForced),a
 136+ 0008                                      ENDM
 137+ 0008
 138+ 0008              ForceTransition:        MACRO newScreen
 139+ 0008 ~                                    ld      a,newScreen
 140+ 0008 ~                                    ld      (ScreenTransitionForced), a
 141+ 0008                                      ENDM
 142+ 0008
 143+ 0008              IsSpaceStationPresent:  MACRO
 144+ 0008 ~                                    ld      a,(SpaceStationSafeZone)
 145+ 0008 ~                                    and     a
 146+ 0008                                      ENDM
 147+ 0008
 148+ 0008              SetSafeZone:            MACRO
 149+ 0008 ~                                    xor     a
 150+ 0008 ~                                    ld      (SpaceStationSafeZone),a
 151+ 0008                                      ENDM
 152+ 0008
 153+ 0008              ClearSafeZone:          MACRO
 154+ 0008 ~                                    ld      a,$FF
 155+ 0008 ~                                    ld      (SpaceStationSafeZone),a
 156+ 0008                                      ENDM
 157+ 0008
 158+ 0008              ClearTemperatures:      MACRO
 159+ 0008 ~                                    xor     a
 160+ 0008 ~                                    ld      (CabinTemperature),a
 161+ 0008 ~                                    ld      (GunTemperature),a
 162+ 0008                                      ENDM
 163+ 0008
 164+ 0008              CoolCabin:              MACRO
 165+ 0008 ~                                    ld      a,(CabinTemperature)
 166+ 0008 ~                                    and     a
 167+ 0008 ~                                    jr      z,.AlreadyCool
 168+ 0008 ~                                    dec     a
 169+ 0008 ~                                    ld      (CabinTemperature),a
 170+ 0008 ~            .AlreadyCool:
 171+ 0008                                      ENDM
 172+ 0008
 173+ 0008              CoolLasers:             MACRO
 174+ 0008 ~                                    ld      a,(GunTemperature)
 175+ 0008 ~                                    and     a
 176+ 0008 ~                                    jr      z,.AlreadyCool
 177+ 0008 ~                                    dec     a
 178+ 0008 ~                                    ld      (GunTemperature),a
 179+ 0008 ~            .AlreadyCool:
 180+ 0008                                      ENDM
 181+ 0008
 182+ 0008              ; type 255 is "not fitted"
 183+ 0008
 184+ 0008
 185+ 0008              InitEventCounter:       MACRO
 186+ 0008 ~                                    xor     a
 187+ 0008 ~                                    ld      (EventCounter),a
 188+ 0008                                      ENDM
 189+ 0008
 190+ 0008              ClearMissJump:          MACRO
 191+ 0008 ~                                    ld      a,$FF
 192+ 0008 ~                                    ld      (MissJumpFlag),a
 193+ 0008                                      ENDM
 194+ 0008
 195+ 0008
 196+ 0008              DrainSystem:            MACRO   SystemMem, DrainMem
 197+ 0008 ~                                    ld      a,(DrainMem)
 198+ 0008 ~                                    ld      b,a
 199+ 0008 ~                                    ld      a,(SystemMem)
 200+ 0008 ~                                    sub     a,b
 201+ 0008 ~                                    ld      (SystemMem),a
 202+ 0008 ~                                    jr      c,.ZeroSystem
 203+ 0008 ~                                    jp      .ExitPoint
 204+ 0008 ~            .ZeroSystem:            ZeroA
 205+ 0008 ~                                    ld      (SystemMem),a
 206+ 0008 ~            .ExitPoint
 207+ 0008                                      ENDM
 208+ 0008
 209+ 0008              BoostSystem:            MACRO   SystemMem, BoostMem
 210+ 0008 ~                                    ld      a,(BoostMem)
 211+ 0008 ~                                    ld      b,a
 212+ 0008 ~                                    ld      a,(SystemMem)
 213+ 0008 ~                                    add     b
 214+ 0008 ~                                    ld      (SystemMem),a
 215+ 0008 ~                                    jr      c, .MaxSystem
 216+ 0008 ~                                    jp      .ExitPoint
 217+ 0008 ~            .MaxSystem:             ld      a,255
 218+ 0008 ~                                    ld      (SystemMem),a
 219+ 0008 ~            .ExitPoint
 220+ 0008                                      ENDM
 221+ 0008
# file closed: ./Variables/general_variables_macros.asm
  69  0008
  70  0008              charactersetaddr		equ 15360
  71  0008              STEPDEBUG               equ 1
  72  0008
  73  0008
  74  0008                                      ORG         $8000
  75  8000 F3                                   di
  76  8001                                      ; "STARTUP"
  77  8001                                      MMUSelectLayer1
  77  8001 ED 91 57 3A >					 nextreg L1memMMU,		    BankLAYER1
  78  8005 CD 80 E0                             call		l1_cls
  79  8008 3E 07                                ld			a,7
  80  800A CD 9B E0                             call		l1_attr_cls_to_a
  81  800D 3E FF                                ld          a,$FF
  82  800F CD A5 E0                             call        l1_set_border
  83  8012              Initialise:             MMUSelectLayer2
  83  8012 ED 91 57 39 >					 nextreg L2memMMU,		    BankLAYER2
  84  8016 CD FA E0                             call 		l2_initialise
  85  8019 CD 03 E0                             call        asm_l2_double_buffer_on
  86  801C              ;..................................................................................................................................
  87  801C              SunLoop:                MMUSelectLayer2
  87  801C ED 91 57 39 >					 nextreg L2memMMU,		    BankLAYER2
  88  8020 CD F3 E0                             call		l2_cls
  89  8023                                      MMUSelectSun
  89  8023 ED 91 56 53 >                     nextreg SunMMU,            BankSunData
  90  8027 21 81 00                             ld          hl,$0081
  91  802A 22 10 C0                             ld          (SBnKxlo),hl
  92  802D 21 01 00                             ld          hl,$0001
  93  8030 22 13 C0                             ld          (SBnKylo),hl
  94  8033 21 60 01                             ld          hl,$0160
  95  8036 22 16 C0                             ld          (SBnKzlo),hl
  96  8039 3E 80                                ld          a,$80
  97  803B 32 12 C0                             ld          (SBnKxsgn),a
  98  803E                                      ZeroA
  98  803E AF          >                        xor a
  99  803F 32 15 C0                             ld          (SBnKysgn),a
 100  8042 32 18 C0                             ld          (SBnKzsgn),a
 101  8045 CD 3E C6                             call        SunUpdateAndRender
 102  8048                                     ; ld          hl, 300
 103  8048                                     ; ld          (SunScrnX),hl
 104  8048                                     ; ld          hl, 170
 105  8048                                     ; ld          (SunScrnY),hl
 106  8048                                      MMUSelectLayer2
 106  8048 ED 91 57 39 >					 nextreg L2memMMU,		    BankLAYER2
 107  804C                                    ;  call        SunCalculateRadius
 108  804C                                     ; call        YOnScreen
 109  804C CD 07 E1                             call        l2_flip_buffers
 110  804F C3 1C 80                             jp          SunLoop
 111  8052              ;..................................................................................................................................
 112  8052
 113  8052
 114  8052                  INCLUDE	"./Hardware/memfill_dma.asm"
# file opened: ./Hardware/memfill_dma.asm
   1+ 8052
   2+ 8052 00           memfillvalue		DB 0
   3+ 8053 83 C3 C7 CB  memfill        		DB DMA_DISABLE,  DMA_RESET, DMA_RESET_PORT_A_TIMING, DMA_RESET_PORT_B_TIMING ,DMA_WRO_BLOCK_PORTA_A2B_XFR
   3+ 8057 7D
   4+ 8058 52 80        memfill_astrt  		DW memfillvalue
   5+ 805A 00 40        memfill_length 		DB $00,$40
   6+ 805C 24 10 AD     					DB DMA_WR1_P1FIXED_MEMORY ,DMA_WR2_P2INC_MEMORY ,DMA_WR4_CONT_MODE
   7+ 805F 00 00        memfill_bstrt  		DB $00,$00
   8+ 8061 82 CF B3 87  					DB DMA_STOP_AT_END, DMA_LOAD, DMA_FORCE_READY, DMA_ENABLE
   9+ 8065              memfill_cmd_len	  	EQU $ - memfill
  10+ 8065
  11+ 8065              memfill_dma:
  12+ 8065              ; "memfill_dma, hl = address to fill, a = value, de = length"
  13+ 8065              .set_fill_value:
  14+ 8065 32 52 80     	ld 		(memfillvalue),a
  15+ 8068              .set_target:
  16+ 8068 22 5F 80     	ld		(memfill_bstrt),hl
  17+ 806B              .set_length:
  18+ 806B ED 53 5A 80  	ld		(memfill_length),de
  19+ 806F              .write_dma:
  20+ 806F 21 53 80     	ld 		hl, memfill
  21+ 8072 06 12        	ld 		b, memfill_cmd_len
  22+ 8074 0E 6B        	ld		c,IO_DATAGEAR_DMA_PORT
  23+ 8076 ED B3        	otir
  24+ 8078 C9           	ret
  25+ 8079
# file closed: ./Hardware/memfill_dma.asm
 115  8079                  INCLUDE	"./Hardware/memcopy_dma.asm"
# file opened: ./Hardware/memcopy_dma.asm
   1+ 8079
   2+ 8079 83 C3 C7 CB  memcopy        		DB DMA_DISABLE,  DMA_RESET, DMA_RESET_PORT_A_TIMING, DMA_RESET_PORT_B_TIMING ,DMA_WRO_BLOCK_PORTA_A2B_XFR
   2+ 807D 7D
   3+ 807E 00 00        memcopy_astrt  		DB $00,$00
   4+ 8080 00 40        memcopy_length 		DB $00,$40
   5+ 8082 14 10 AD     					DB DMA_WR1_P1INC_MEMORY ,DMA_WR2_P2INC_MEMORY ,DMA_WR4_CONT_MODE
   6+ 8085 00 00        memcopy_bstrt  		DB $00,$00
   7+ 8087 82 CF B3 87  					DB DMA_STOP_AT_END, DMA_LOAD, DMA_FORCE_READY, DMA_ENABLE
   8+ 808B              memcopy_cmd_len	  	equ $ - memcopy
   9+ 808B
  10+ 808B              memcopy_dma:
  11+ 808B              ; "memcopy_dma, hl = target address de = source address to copy, bc = length"
  12+ 808B              .set_target:
  13+ 808B 22 85 80     	ld		(memcopy_bstrt),hl
  14+ 808E              .set_source:
  15+ 808E ED 53 7E 80  	ld		(memcopy_astrt),de
  16+ 8092              .set_length:
  17+ 8092 ED 43 80 80  	ld		(memcopy_length),bc
  18+ 8096              .write_dma:
  19+ 8096 21 79 80     	ld 		hl, memcopy
  20+ 8099 06 12        	ld 		b, memcopy_cmd_len
  21+ 809B 0E 6B        	ld		c,IO_DATAGEAR_DMA_PORT
  22+ 809D ED B3        	otir
  23+ 809F C9           	ret
  24+ 80A0
# file closed: ./Hardware/memcopy_dma.asm
 116  80A0                  INCLUDE "./Hardware/keyboard.asm"
# file opened: ./Hardware/keyboard.asm
   1+ 80A0              ;
   2+ 80A0              ; $FEFE;65278 V, C, X, Z, Caps Shifts       4  3  2  1  0
   3+ 80A0              ; $FDFE;65022 G, F, D, S, A                 9  8  7  6  5
   4+ 80A0              ; $FBFE;64510 T, R, E, W, Q                14 13 12 11 10
   5+ 80A0              ; $F7FE;63486 5, 4, 3, 2, 1                19 18 17 16 15
   6+ 80A0              ; $EFFE;61438 6, 7, 8, 9, 0                24 23 22 23 20
   7+ 80A0              ; $DFFE;57342 Y, U, I, O, P                29 28 27 26 25
   8+ 80A0              ; $BFFE;49150 H, J, K, L, Enter            34 33 32 31 30
   9+ 80A0              ; $7FFE;32766 B, N, M, Symbol Shift, Space 39 38 37 36 35
  10+ 80A0              ;
  11+ 80A0              ; Keyboard
  12+ 80A0              ;
  13+ 80A0              ;   0      1       2       3       4       5        6       7       8       9
  14+ 80A0              ;  VK_CAPS, VK_Z,  VK_X,   VK_C,   VK_V,   VK_A,    VK_S,   VK_D,   VK_F,   VK_G
  15+ 80A0              ;   10     11      12      13      14      15       16      17      18      19
  16+ 80A0              ;  VK_Q,   VK_W,   VK_E,   VK_R,   VK_T,   VK_1,    VK_2,   VK_3,   VK_4,   VK_5
  17+ 80A0              ;   20     21      22      23      24      25       26      27      28      29
  18+ 80A0              ;  VK_0    VK_9,   VK_8,   VK_7,   VK_6,   VK_P ,    VK_O,  VK_I,   VK_U,   VK_Y
  19+ 80A0              ;   30     31      32      33      34      35       36      37      38      39
  20+ 80A0              ; VK_ENTER VK_L,   VK_K,   VK_J,   VK_H,   VK_SPACE VK_SYM, VK_M,   VK_N,   VK_B
  21+ 80A0              ;
  22+ 80A0              ; Default map
  23+ 80A0              ;-----------------------------------------------------------------------------------------------------------------------------------
  24+ 80A0              ;   0          1           2             3              4           5           6           7           8           9
  25+ 80A0              ;   VK_CAPS    VK_Z        VK_X,         VK_C,          VK_V,       VK_A        VK_S,       VK_D,       VK_F,       VK_G
  26+ 80A0              ;              GameSkip                  Equip          SelLCargo   Climb       Decelerate  Recentre    FireM       HomeCursor
  27+ 80A0              ;                                                                                                       Find System
  28+ 80A0              ;-----------------------------------------------------------------------------------------------------------------------------------
  29+ 80A0              ;   10         11          12            13             14          15          16          17          18          19
  30+ 80A0              ;   VK_Q       VK_W,       VK_E,         VK_R,          VK_T,       VK_1        VK_2        VK_3        VK_4        VK_5
  31+ 80A0              ;   Dive       Accelerate  ECM           UnarmMissile   TargetM     FrontV      AftV        LeftV       RightV      GalacticChart
  32+ 80A0              ;-----------------------------------------------------------------------------------------------------------------------------------
  33+ 80A0              ;   20         Accel       22            23             24          25          26          27          28          29
  34+ 80A0              ;   VK_0       VK_9,       VK_8,         VK_7,          VK_6,       VK_P ,      VK_O,       VK_I,       VK_U,       VK_Y
  35+ 80A0              ;   EscapePod  Inventory   Status        MarketPrices   LocalChart  RollRight   RolLLeft                EnergyBomb  Quit
  36+ 80A0              ;   PlanetData                                                      PauseGame   SaveGame
  37+ 80A0              ;-----------------------------------------------------------------------------------------------------------------------------------
  38+ 80A0              ;   30         31          32            33             34          Right       36          37          EnergyBomb  39
  39+ 80A0              ;   VK_ENTER   VK_L,       VK_K,         VK_J,          VK_H,       VK_SPACE    VK_SYM,     VK_M,       VK_N,       VK_B
  40+ 80A0              ;              Launch                    Distance       Hyperspace  Laser                               DockComp    BuyCargo
  41+ 80A0              ;              ResumeGame
  42+ 80A0
  43+ 80A0              ; You can read address to check keystate by address KeyboardMap + c_Pressed corresponding key. There is also an addr_ helper too
  44+ 80A0
  45+ 80A0              c_Pressed_Front         equ 0  * 2
  46+ 80A0              c_Pressed_Aft           equ 1  * 2
  47+ 80A0              c_Pressed_Left          equ 2  * 2
  48+ 80A0              c_Pressed_Right         equ 3  * 2
  49+ 80A0              c_Pressed_RollLeft      equ 4  * 2
  50+ 80A0              c_Pressed_RollRight     equ 5  * 2
  51+ 80A0              c_Pressed_Dive          equ 6  * 2
  52+ 80A0              c_Pressed_Climb         equ 7  * 2
  53+ 80A0              c_Pressed_Accellerate   equ 8  * 2
  54+ 80A0              c_Pressed_Decellerate   equ 9  * 2
  55+ 80A0              c_Pressed_FireLaser     equ 10 * 2
  56+ 80A0              c_Pressed_TargetMissle  equ 11 * 2
  57+ 80A0              c_Pressed_FireMissile   equ 12 * 2
  58+ 80A0              c_Pressed_UnarmMissile  equ 13 * 2
  59+ 80A0              c_Pressed_ECM           equ 14 * 2
  60+ 80A0              c_Pressed_EnergyBomb    equ 15 * 2
  61+ 80A0              c_Pressed_EscapePod     equ 16 * 2
  62+ 80A0              c_Pressed_DockingComp   equ 17 * 2
  63+ 80A0              c_Pressed_Hyperspace    equ 18 * 2
  64+ 80A0              c_Pressed_Distance      equ 19 * 2
  65+ 80A0              c_Pressed_HomeCursor    equ 20 * 2
  66+ 80A0              c_Pressed_Launch        equ 21 * 2
  67+ 80A0              c_Pressed_BuyCargo      equ 22 * 2
  68+ 80A0              c_Pressed_SellCargo     equ 23 * 2
  69+ 80A0              c_Pressed_Equip         equ 24 * 2
  70+ 80A0              c_Pressed_GalacticChrt  equ 25 * 2
  71+ 80A0              c_Pressed_LocalChart    equ 26 * 2
  72+ 80A0              c_Pressed_MarketPrices  equ 27 * 2
  73+ 80A0              c_Pressed_Status        equ 28 * 2
  74+ 80A0              c_Pressed_Inventory     equ 29 * 2
  75+ 80A0              c_Pressed_GameSkip      equ 30 * 2
  76+ 80A0              c_Pressed_Save          equ 31 * 2
  77+ 80A0              c_Pressed_Freeze        equ 32 * 2
  78+ 80A0              c_Pressed_Resume        equ 33 * 2
  79+ 80A0              c_Pressed_Recentre      equ 34 * 2
  80+ 80A0              c_Pressed_Quit          equ 35 * 2
  81+ 80A0              c_Pressed_PlanetData    equ 36 * 2
  82+ 80A0              c_Pressed_CursorUp      equ 37 * 2
  83+ 80A0              c_Pressed_CursorDown    equ 38 * 2
  84+ 80A0              c_Pressed_Find          equ 39 * 2
  85+ 80A0              c_Pressed_Yes           equ 40 * 2
  86+ 80A0              c_Pressed_No            equ 41 * 2
  87+ 80A0
  88+ 80A0
  89+ 80A0              ; half row 1
  90+ 80A0              VK_CAPS  				equ 0
  91+ 80A0              VK_Z  					equ 1
  92+ 80A0              VK_X  					equ 2
  93+ 80A0              VK_C  					equ 3
  94+ 80A0              VK_V  					equ 4
  95+ 80A0              ; half row 2
  96+ 80A0              VK_A  					equ 5
  97+ 80A0              VK_S  					equ 6
  98+ 80A0              VK_D  					equ 7
  99+ 80A0              VK_F  					equ 8
 100+ 80A0              VK_G  					equ 9
 101+ 80A0              ; half row 3
 102+ 80A0              VK_Q  					equ 10
 103+ 80A0              VK_W  					equ 11
 104+ 80A0              VK_E  					equ 12
 105+ 80A0              VK_R  					equ 13
 106+ 80A0              VK_T  					equ 14
 107+ 80A0              ; half row 4
 108+ 80A0              VK_1  					equ 15
 109+ 80A0              VK_2  					equ 16
 110+ 80A0              VK_3  					equ 17
 111+ 80A0              VK_4  					equ 18
 112+ 80A0              VK_5  					equ 19
 113+ 80A0              ; half row 5
 114+ 80A0              VK_0 					equ 20
 115+ 80A0              VK_9 					equ 21
 116+ 80A0              VK_8 					equ 22
 117+ 80A0              VK_7 					equ 23
 118+ 80A0              VK_6 					equ 24
 119+ 80A0              ; half row 6
 120+ 80A0              VK_P  					equ 25
 121+ 80A0              VK_O  					equ 26
 122+ 80A0              VK_I  					equ 27
 123+ 80A0              VK_U  					equ 28
 124+ 80A0              VK_Y  					equ 29
 125+ 80A0              ; half row 7
 126+ 80A0              VK_ENTER 				equ 30
 127+ 80A0              VK_L  					equ 31
 128+ 80A0              VK_K  					equ 32
 129+ 80A0              VK_J  					equ 33
 130+ 80A0              VK_H  					equ 34
 131+ 80A0              ; half row 8
 132+ 80A0              VK_SPACE 				equ 35
 133+ 80A0              VK_SYM  				equ 36
 134+ 80A0              VK_M  					equ 37
 135+ 80A0              VK_N  					equ 38
 136+ 80A0              VK_B  					equ 39
 137+ 80A0
 138+ 80A0              ;KeyboardMapping
 139+ 80A0              KeyCode_Front        	equ VK_1
 140+ 80A0              KeyCode_Aft          	equ VK_2
 141+ 80A0              KeyCode_Left         	equ VK_3
 142+ 80A0              KeyCode_Right        	equ VK_4
 143+ 80A0              KeyCode_RollLeft     	equ VK_O
 144+ 80A0              KeyCode_RollRight    	equ VK_P
 145+ 80A0              KeyCode_Dive         	equ VK_Q
 146+ 80A0              KeyCode_Climb        	equ VK_A
 147+ 80A0              KeyCode_Accellerate  	equ VK_W
 148+ 80A0              KeyCode_Decellerate  	equ VK_S
 149+ 80A0              KeyCode_FireLaser    	equ VK_SPACE
 150+ 80A0              KeyCode_TargetMissle 	equ VK_T
 151+ 80A0              KeyCode_FireMissile  	equ VK_F
 152+ 80A0              KeyCode_Find        	equ VK_F
 153+ 80A0              KeyCode_UnarmMissile 	equ VK_R
 154+ 80A0              KeyCode_ECM          	equ VK_E
 155+ 80A0              KeyCode_EnergyBomb   	equ VK_U
 156+ 80A0              KeyCode_EscapePod    	equ VK_CAPS
 157+ 80A0              KeyCode_DockingComp  	equ VK_N
 158+ 80A0              KeyCode_Hyperspace   	equ VK_H
 159+ 80A0              KeyCode_Distance     	equ VK_J
 160+ 80A0              KeyCode_HomeCursor   	equ VK_G
 161+ 80A0              KeyCode_Launch       	equ VK_L
 162+ 80A0              KeyCode_BuyCargo     	equ VK_B
 163+ 80A0              KeyCode_SellCargo    	equ VK_V
 164+ 80A0              KeyCode_Equip        	equ VK_C
 165+ 80A0              KeyCode_GalacticChrt 	equ VK_5
 166+ 80A0              KeyCode_LocalChart   	equ VK_6
 167+ 80A0              KeyCode_MarketPrices 	equ VK_7
 168+ 80A0              KeyCode_Status       	equ VK_8
 169+ 80A0              KeyCode_Inventory    	equ VK_9
 170+ 80A0              KeyCode_GameSkip     	equ VK_Z
 171+ 80A0              KeyCode_Save         	equ VK_O
 172+ 80A0              KeyCode_Freeze       	equ VK_B
 173+ 80A0              KeyCode_Resume       	equ VK_L
 174+ 80A0              KeyCode_Recentre     	equ VK_D
 175+ 80A0              KeyCode_Quit         	equ VK_Y
 176+ 80A0              KeyCode_PlanetData   	equ VK_0
 177+ 80A0              KeyCode_CursorUp        equ VK_Q
 178+ 80A0              KeyCode_CursorDown      equ VK_A
 179+ 80A0              KeyCode_PressedYes      equ VK_Y
 180+ 80A0              KeyCode_PressedNo       equ VK_N
 181+ 80A0
 182+ 80A0 00 00 00...  Keys					DS	40          ; This is the list of key states for all the VK keys presssed i.e. VK_CAPS through to VK_B
 183+ 80C8              c_KeyBoardLen 			equ $ - Keys
 184+ 80C8 00 00 00...  RawKeys					DS	8
 185+ 80D0 FE FD FB F7  KeyAddrTab				DB	$FE, $FD, $FB, $F7, $EF, $DF, $BF, $7F
 185+ 80D4 EF DF BF 7F
 186+ 80D8              ; Now keyboard map lists each game key and the corresponding address in the Keys table to get the value. This way redefining keys is just a case
 187+ 80D8              ; of updating this table with the respective location to look up
 188+ 80D8              ; key list sequence is in table above
 189+ 80D8 AF 80 B0 80  KeyboardMap             DW  Keys+KeyCode_Front        ,Keys+KeyCode_Aft          ,Keys+KeyCode_Left         ,Keys+KeyCode_Right        ,Keys+KeyCode_RollLeft
 189+ 80DC B1 80 B2 80
 189+ 80E0 BA 80
 190+ 80E2 B9 80 AA 80                          DW  Keys+KeyCode_RollRight    ,Keys+KeyCode_Dive         ,Keys+KeyCode_Climb        ,Keys+KeyCode_Accellerate  ,Keys+KeyCode_Decellerate
 190+ 80E6 A5 80 AB 80
 190+ 80EA A6 80
 191+ 80EC C3 80 AE 80                          DW  Keys+KeyCode_FireLaser    ,Keys+KeyCode_TargetMissle ,Keys+KeyCode_FireMissile  ,Keys+KeyCode_UnarmMissile ,Keys+KeyCode_ECM
 191+ 80F0 A8 80 AD 80
 191+ 80F4 AC 80
 192+ 80F6 BC 80 A0 80                          DW  Keys+KeyCode_EnergyBomb   ,Keys+KeyCode_EscapePod    ,Keys+KeyCode_DockingComp  ,Keys+KeyCode_Hyperspace   ,Keys+KeyCode_Distance
 192+ 80FA C6 80 C2 80
 192+ 80FE C1 80
 193+ 8100 A9 80 BF 80                          DW  Keys+KeyCode_HomeCursor   ,Keys+KeyCode_Launch       ,Keys+KeyCode_BuyCargo     ,Keys+KeyCode_SellCargo    ,Keys+KeyCode_Equip
 193+ 8104 C7 80 A4 80
 193+ 8108 A3 80
 194+ 810A B3 80 B8 80                          DW  Keys+KeyCode_GalacticChrt ,Keys+KeyCode_LocalChart   ,Keys+KeyCode_MarketPrices ,Keys+KeyCode_Status       ,Keys+KeyCode_Inventory
 194+ 810E B7 80 B6 80
 194+ 8112 B5 80
 195+ 8114 A1 80 BA 80                          DW  Keys+KeyCode_GameSkip     ,Keys+KeyCode_Save         ,Keys+KeyCode_Freeze       ,Keys+KeyCode_Resume       ,Keys+KeyCode_Recentre
 195+ 8118 C7 80 BF 80
 195+ 811C A7 80
 196+ 811E BD 80 B4 80                          DW  Keys+KeyCode_Quit         ,Keys+KeyCode_PlanetData   ,Keys+KeyCode_CursorUp     ,Keys+KeyCode_CursorDown   ,Keys+KeyCode_Find
 196+ 8122 AA 80 A5 80
 196+ 8126 A8 80
 197+ 8128 BD 80 C6 80                          DW  Keys+KeyCode_PressedYes   ,Keys+KeyCode_PressedNo
 198+ 812C
 199+ 812C 23 5A 58 43  ASCII_Map:              DB "#","Z","X","C","V"
 199+ 8130 56
 200+ 8131 41 53 44 46                          DB "A","S","D","F","G"
 200+ 8135 47
 201+ 8136 51 57 45 52                          DB "Q","W","E","R","T"
 201+ 813A 54
 202+ 813B 31 32 33 34                          DB "1","2","3","4","5"
 202+ 813F 35
 203+ 8140 30 39 38 37                          DB "0","9","8","7","6"
 203+ 8144 36
 204+ 8145 50 4F 49 55                          DB "P","O","I","U","Y"
 204+ 8149 59
 205+ 814A 3E 4C 4B 4A                          DB ">","L","K","J","H"
 205+ 814E 48
 206+ 814F 20 5E 4D 4E                          DB " ","^","M","N","B"
 206+ 8153 42
 207+ 8154
 208+ 8154              ; mapping of a code to the lookup table Keyboard map. So if you are using an addr_Pressed you can then fetch from KeyboardMap the address in Keys
 209+ 8154              ; for the raw key press status
 210+ 8154              addr_Pressed_Front         equ KeyboardMap+c_Pressed_Front
 211+ 8154              addr_Pressed_Aft           equ KeyboardMap+c_Pressed_Aft
 212+ 8154              addr_Pressed_Left          equ KeyboardMap+c_Pressed_Left
 213+ 8154              addr_Pressed_Right         equ KeyboardMap+c_Pressed_Right
 214+ 8154              addr_Pressed_RollLeft      equ KeyboardMap+c_Pressed_RollLeft
 215+ 8154              addr_Pressed_RollRight     equ KeyboardMap+c_Pressed_RollRight
 216+ 8154              addr_Pressed_Dive          equ KeyboardMap+c_Pressed_Dive
 217+ 8154              addr_Pressed_Climb         equ KeyboardMap+c_Pressed_Climb
 218+ 8154              addr_Pressed_Accellerate   equ KeyboardMap+c_Pressed_Accellerate
 219+ 8154              addr_Pressed_Decellerate   equ KeyboardMap+c_Pressed_Decellerate
 220+ 8154              addr_Pressed_FireLaser     equ KeyboardMap+c_Pressed_FireLaser
 221+ 8154              addr_Pressed_TargetMissle  equ KeyboardMap+c_Pressed_TargetMissle
 222+ 8154              addr_Pressed_FireMissile   equ KeyboardMap+c_Pressed_FireMissile
 223+ 8154              addr_Pressed_UnarmMissile  equ KeyboardMap+c_Pressed_UnarmMissile
 224+ 8154              addr_Pressed_ECM           equ KeyboardMap+c_Pressed_ECM
 225+ 8154              addr_Pressed_EnergyBomb    equ KeyboardMap+c_Pressed_EnergyBomb
 226+ 8154              addr_Pressed_EscapePod     equ KeyboardMap+c_Pressed_EscapePod
 227+ 8154              addr_Pressed_DockingComp   equ KeyboardMap+c_Pressed_DockingComp
 228+ 8154              addr_Pressed_Hyperspace    equ KeyboardMap+c_Pressed_Hyperspace
 229+ 8154              addr_Pressed_Distance      equ KeyboardMap+c_Pressed_Distance
 230+ 8154              addr_Pressed_HomeCursor    equ KeyboardMap+c_Pressed_HomeCursor
 231+ 8154              addr_Pressed_Launch        equ KeyboardMap+c_Pressed_Launch
 232+ 8154              addr_Pressed_BuyCargo      equ KeyboardMap+c_Pressed_BuyCargo
 233+ 8154              addr_Pressed_SellCargo     equ KeyboardMap+c_Pressed_SellCargo
 234+ 8154              addr_Pressed_Equip         equ KeyboardMap+c_Pressed_Equip
 235+ 8154              addr_Pressed_GalacticChrt  equ KeyboardMap+c_Pressed_GalacticChrt
 236+ 8154              addr_Pressed_LocalChart    equ KeyboardMap+c_Pressed_LocalChart
 237+ 8154              addr_Pressed_MarketPrices  equ KeyboardMap+c_Pressed_MarketPrices
 238+ 8154              addr_Pressed_Status        equ KeyboardMap+c_Pressed_Status
 239+ 8154              addr_Pressed_Inventory     equ KeyboardMap+c_Pressed_Inventory
 240+ 8154              addr_Pressed_GameSkip      equ KeyboardMap+c_Pressed_GameSkip
 241+ 8154              addr_Pressed_Save          equ KeyboardMap+c_Pressed_Save
 242+ 8154              addr_Pressed_Freeze        equ KeyboardMap+c_Pressed_Freeze
 243+ 8154              addr_Pressed_Resume        equ KeyboardMap+c_Pressed_Resume
 244+ 8154              addr_Pressed_Recentre      equ KeyboardMap+c_Pressed_Recentre
 245+ 8154              addr_Pressed_Quit          equ KeyboardMap+c_Pressed_Quit
 246+ 8154              addr_Pressed_PlanetData    equ KeyboardMap+c_Pressed_PlanetData
 247+ 8154              addr_Pressed_CursorUp      equ KeyboardMap+c_Pressed_CursorUp
 248+ 8154              addr_Pressed_CursorDown    equ KeyboardMap+c_Pressed_CursorDown
 249+ 8154              addr_Pressed_Find          equ KeyboardMap+c_Pressed_Find
 250+ 8154
 251+ 8154
 252+ 8154              MIsKeyPressed:          MACRO   keyaddress, misstarget
 253+ 8154 ~                                    ld      hl,(keyaddress)
 254+ 8154 ~                                    ld      a,(hl)
 255+ 8154 ~                                    JumpIfAIsZero   misstarget
 256+ 8154                                      ENDM
 257+ 8154
 258+ 8154 21 A0 80     init_keyboard:          ld		hl,Keys                         ; no key s are pressed by default
 259+ 8157 11 28 00                             ld		de, c_KeyBoardLen               ;
 260+ 815A 3E 00                                ld		a,0                             ;
 261+ 815C CD 65 80                             call	memfill_dma                     ;
 262+ 815F C9                                   ret                                     ;
 263+ 8160
 264+ 8160
 265+ 8160
 266+ 8160 DD 21 C8 80  scan_keyboard:          ld		ix,RawKeys                      ; hl = table of raw IO port readings
 267+ 8164 21 D0 80                             ld		hl,KeyAddrTab                   ; de = table of IO ports to read
 268+ 8167 0E 08                                ld		c,8                             ; 8 ports to ready
 269+ 8169 11 A0 80                             ld      de,Keys                         ; ix = table of key states from raw read
 270+ 816C 7E           .PortReadLoop:          ld		a,(hl)							; Set up port to read as (hl)$FE
 271+ 816D DB FE                                in		a,($FE)							; read port to a
 272+ 816F DD 77 00                             ld      (ix+0),a                        ; save raw scan
 273+ 8172 DD 23                                inc     ix
 274+ 8174 23                                   inc		hl                              ; and ready for next read
 275+ 8175 06 05        .ProcessInputBits:      ld		b,5								; loop all bits (there are only 5 keys to a group)
 276+ 8177 1F           .ProcessBitsLoop:       rra                                     ; shit bit 0 into carry
 277+ 8178 CB 47                                bit		0,a								; is bit set
 278+ 817A 30 08                                jr      nc,.SetKeyPressed               ; low bit means it was pressed
 279+ 817C FD 6F                                ld      iyl,a
 280+ 817E                                      ZeroA
 280+ 817E AF          >                        xor a
 281+ 817F C3 8C 81                             jp      .SetKey
 282+ 8182 20 0B                                jr		nz,.SkipKeySet
 283+ 8184 FD 6F        .SetKeyPressed:	        ld      iyl,a                           ; save current input byte
 284+ 8186 1A                                   ld      a,(de)                          ; get current keystate
 285+ 8187 FE 02                                cp      2
 286+ 8189 28 02                                jr      z,.AlreadyHeld
 287+ 818B 3C                                   inc     a                               ; and increment by 1 as its moved from previous state
 288+ 818C 12           .SetKey:                ld		(de),a				  	        ; save key Pressed state
 289+ 818D FD 7D        .AlreadyHeld:           ld      a,iyl                           ; and retrieve the current input byte
 290+ 818F 13           .SkipKeySet:	        inc		de								; move to next key
 291+ 8190 10 E5                                djnz	.ProcessBitsLoop				; Process all key group bits
 292+ 8192 0D                                   dec     c                               ; thats one row of bits all processed
 293+ 8193 20 D7                                jr      nz,.PortReadLoop				; Read next input port
 294+ 8195 C9                                   ret
 295+ 8196
 296+ 8196
 297+ 8196
 298+ 8196              GetKeyStateAddressDE:   MACRO
 299+ 8196 ~                                    ld      hl,KeyboardMap                  ; work our address to read from
 300+ 8196 ~                                    add     hl,a
 301+ 8196 ~                                    ld      e,(hl)
 302+ 8196 ~                                    inc     hl
 303+ 8196 ~                                    ld      d,(hl)                          ; now de = address in keypress list
 304+ 8196                                      ENDM
 305+ 8196
 306+ 8196              GetKeyStateAddressHL:   MACRO
 307+ 8196 ~                                    ld      hl,KeyboardMap                  ; work our address to read from
 308+ 8196 ~                                    add     hl,a
 309+ 8196 ~                                    ld      a,(hl)
 310+ 8196 ~                                    inc     hl
 311+ 8196 ~                                    ld      h,(hl)                          ; now hl = address in keypress list
 312+ 8196 ~                                    ld      l,a
 313+ 8196                                      ENDM
 314+ 8196
 315+ 8196
 316+ 8196              ;;old debug codeCurrentX            DB 0
 317+ 8196              ;;old debug codeCurrentY            DB 0
 318+ 8196              ;;old debug code
 319+ 8196              ;;old debug codedisplayKeyStatus:       xor         a
 320+ 8196              ;;old debug code                        ld          (CurrentX),a
 321+ 8196              ;;old debug code                        ld          hl,RawKeys
 322+ 8196              ;;old debug code                        ld          a,(hl)
 323+ 8196              ;;old debug code                        and         %00011111
 324+ 8196              ;;old debug code                        ld          b,5
 325+ 8196              ;;old debug code.displayLoop:           push        bc,,hl
 326+ 8196              ;;old debug code                        rra
 327+ 8196              ;;old debug code                        jr          c,.displayNoPress
 328+ 8196              ;;old debug code.displayPress:          push        af
 329+ 8196              ;;old debug code                        ld          a,(CurrentX)
 330+ 8196              ;;old debug code                        ld          e,a
 331+ 8196              ;;old debug code                        ld          a,(CurrentY)
 332+ 8196              ;;old debug code                        ld          d,a
 333+ 8196              ;;old debug code                        ld          a,'*'
 334+ 8196              ;;old debug code                        MMUSelectLayer1
 335+ 8196              ;;old debug code                        call        l1_print_char
 336+ 8196              ;;old debug code                        ld          a,(CurrentX)
 337+ 8196              ;;old debug code                        add         a,8
 338+ 8196              ;;old debug code                        ld          (CurrentX),a
 339+ 8196              ;;old debug code                        pop         af
 340+ 8196              ;;old debug code                        pop         bc,,hl
 341+ 8196              ;;old debug code                        djnz        .displayLoop
 342+ 8196              ;;old debug code                        ret
 343+ 8196              ;;old debug code.displayNoPress:        push        af
 344+ 8196              ;;old debug code                        ld          a,(CurrentX)
 345+ 8196              ;;old debug code                        ld          e,a
 346+ 8196              ;;old debug code                        ld          a,(CurrentY)
 347+ 8196              ;;old debug code                        ld          d,a
 348+ 8196              ;;old debug code                        ld          a,'O'
 349+ 8196              ;;old debug code                        MMUSelectLayer1
 350+ 8196              ;;old debug code                        call        l1_print_char
 351+ 8196              ;;old debug code                        ld          a,(CurrentX)
 352+ 8196              ;;old debug code                        add         a,8
 353+ 8196              ;;old debug code                        ld          (CurrentX),a
 354+ 8196              ;;old debug code                        pop         af
 355+ 8196              ;;old debug code                        pop         bc,,hl
 356+ 8196              ;;old debug code                        djnz        .displayLoop
 357+ 8196              ;;old debug code                        ret
 358+ 8196              ;;old debug code
 359+ 8196              ;;old debug codedisplayDownStatus:      ld  a,(Keys+      KeyCode_CursorUp)
 360+ 8196              ;;old debug code                        cp  0
 361+ 8196              ;;old debug code                        jr      z,.displayNoUp
 362+ 8196              ;;old debug code                        cp  1
 363+ 8196              ;;old debug code                        jr      z,.displayUp
 364+ 8196              ;;old debug code.displayHeld:           ld      de,8*15
 365+ 8196              ;;old debug code                        ld      a,"*"
 366+ 8196              ;;old debug code                        MMUSelectLayer1
 367+ 8196              ;;old debug code                        call        l1_print_char
 368+ 8196              ;;old debug code                        ret
 369+ 8196              ;;old debug code.displayUp:             ld      de,8*15
 370+ 8196              ;;old debug code                        ld      a,"+"
 371+ 8196              ;;old debug code                        MMUSelectLayer1
 372+ 8196              ;;old debug code                        call        l1_print_char
 373+ 8196              ;;old debug code                        ret
 374+ 8196              ;;old debug code.displayNoUp:             ld      de,8*15
 375+ 8196              ;;old debug code                        ld      a,"O"
 376+ 8196              ;;old debug code                        MMUSelectLayer1
 377+ 8196              ;;old debug code                        call        l1_print_char
 378+ 8196              ;;old debug code                        ret
 379+ 8196              ;;old debug code
 380+ 8196
 381+ 8196
 382+ 8196              ; call with a = c_Pressed key, will then read mapping does this with keyboard scan, waits until key gets to state 1, if it was already held then#
 383+ 8196              ; it will have to be let go to reset of 0 and scan again
 384+ 8196              ; Deprecated as not used as yet
 385+ 8196              ;;;;;;wait_for_key_a_press:   GetKeyStateAddressHL
 386+ 8196              ;;;;;;                        push    hl
 387+ 8196              ;;;;;;.wait_loop:             call    scan_keyboard
 388+ 8196              ;;;;;;                        pop     hl                              ; get key address into hl
 389+ 8196              ;;;;;;                        push    hl
 390+ 8196              ;;;;;;                        ld      a,(hl)
 391+ 8196              ;;;;;;                        JumpIfANENusng  1,.wait_loop             ; will also loop if held down when entering this routine
 392+ 8196              ;;;;;;                        pop     hl                              ; tidy up rogue push, less t states than detecting if we want to push or not
 393+ 8196              ;;;;;;                        ret
 394+ 8196              ;;;;;;; call with a = c_Pressed key, will then read mapping does this with keyboard scan waits until key gets to state 2
 395+ 8196              ;;;;;;wait_for_key_a_held:    GetKeyStateAddressDE
 396+ 8196              ;;;;;;                        push    hl
 397+ 8196              ;;;;;;.wait_loop:             call    scan_keyboard
 398+ 8196              ;;;;;;                        pop     hl
 399+ 8196              ;;;;;;                        push    hl
 400+ 8196              ;;;;;;                        ld      a,(hl)
 401+ 8196              ;;;;;;                        JumpIfALTNusng  2, .wait_loop
 402+ 8196              ;;;;;;                        pop     hl
 403+ 8196              ;;;;;;                        ret
 404+ 8196
 405+ 8196              ; Gets the current keystate of the c_Pressed Key in a register
 406+ 8196              get_key_a_state:        GetKeyStateAddressHL                    ; reads a mapped key and sets a to key staus, e.g. 0 1 or >=2 DOES NOT SCAN KEYBOARD
 406+ 8196 21 D8 80    >                        ld      hl,KeyboardMap                  ; work our address to read from
 406+ 8199 ED 31       >                        add     hl,a
 406+ 819B 7E          >                        ld      a,(hl)
 406+ 819C 23          >                        inc     hl
 406+ 819D 66          >                        ld      h,(hl)                          ; now hl = address in keypress list
 406+ 819E 6F          >                        ld      l,a
 407+ 819F 7E                                   ld      a,(hl)                          ; a = keystate
 408+ 81A0 C9                                   ret
 409+ 81A1
 410+ 81A1              ; sets they keystate of c pressed key in a register to 1 (pressed)
 411+ 81A1              force_key_press:        GetKeyStateAddressHL                    ; read key locations
 411+ 81A1 21 D8 80    >                        ld      hl,KeyboardMap                  ; work our address to read from
 411+ 81A4 ED 31       >                        add     hl,a
 411+ 81A6 7E          >                        ld      a,(hl)
 411+ 81A7 23          >                        inc     hl
 411+ 81A8 66          >                        ld      h,(hl)                          ; now hl = address in keypress list
 411+ 81A9 6F          >                        ld      l,a
 412+ 81AA 3E 01                                ld      a,1
 413+ 81AC 77                                   ld      (hl),a
 414+ 81AD C9                                   ret
 415+ 81AE
 416+ 81AE              is_key_up_state:        GetKeyStateAddressHL
 416+ 81AE 21 D8 80    >                        ld      hl,KeyboardMap                  ; work our address to read from
 416+ 81B1 ED 31       >                        add     hl,a
 416+ 81B3 7E          >                        ld      a,(hl)
 416+ 81B4 23          >                        inc     hl
 416+ 81B5 66          >                        ld      h,(hl)                          ; now hl = address in keypress list
 416+ 81B6 6F          >                        ld      l,a
 417+ 81B7 7E                                   ld      a,(hl)
 418+ 81B8 FE 00                                cp      0
 419+ 81BA C9                                   ret
 420+ 81BB
 421+ 81BB              ; returns z is set if c_ key is pressed
 422+ 81BB              is_key_pressed:         GetKeyStateAddressHL
 422+ 81BB 21 D8 80    >                        ld      hl,KeyboardMap                  ; work our address to read from
 422+ 81BE ED 31       >                        add     hl,a
 422+ 81C0 7E          >                        ld      a,(hl)
 422+ 81C1 23          >                        inc     hl
 422+ 81C2 66          >                        ld      h,(hl)                          ; now hl = address in keypress list
 422+ 81C3 6F          >                        ld      l,a
 423+ 81C4 7E                                   ld      a,(hl)                          ; a = keystate
 424+ 81C5 FE 01                                cp      1                               ; we cant just test bit 0 as this may have been held long
 425+ 81C7 C9                                   ret
 426+ 81C8
 427+ 81C8              ; returns nz is set if c_ key is held, if key was held then keystate would be 2 or 3, i.e. bit 1 set
 428+ 81C8              is_key_held:            GetKeyStateAddressHL
 428+ 81C8 21 D8 80    >                        ld      hl,KeyboardMap                  ; work our address to read from
 428+ 81CB ED 31       >                        add     hl,a
 428+ 81CD 7E          >                        ld      a,(hl)
 428+ 81CE 23          >                        inc     hl
 428+ 81CF 66          >                        ld      h,(hl)                          ; now hl = address in keypress list
 428+ 81D0 6F          >                        ld      l,a
 429+ 81D1 7E                                   ld      a,(hl)                          ; a = keystate
 430+ 81D2 E6 02                                and     Bit1Only                        ; clear out bit 1 which elimiates state 3, so it can now be 2 (held) or 0 (not pressed or one off)
 431+ 81D4 C9                                   ret
 432+ 81D5
 433+ 81D5              ; checks to see if any key is pressed in the key table
 434+ 81D5 21 A0 80     is_any_key_pressed:     ld      hl,Keys
 435+ 81D8 01 28 00                             ld      bc,40
 436+ 81DB 3E 01                                ld      a,1
 437+ 81DD ED B1                                cpir                                    ; search for the value 1
 438+ 81DF 28 03                                jr      z,.KeyPressed                   ; if a key was pressed then handle press
 439+ 81E1                                      SetAFalse
 439+ 81E1 3E FF       >                        ld      a,$FF
 440+ 81E3 C9                                   ret
 441+ 81E4 3E 27        .KeyPressed:            ld      a,39                            ; so c will be how many keys still to scan
 442+ 81E6 91                                   sub     c                               ; so a = 40 - c to get to result
 443+ 81E7 C9                                   ret
 444+ 81E8
 445+ 81E8 21 A0 80     is_any_key_held:        ld      hl,Keys
 446+ 81EB 06 28                                ld      b,40
 447+ 81ED 0E 00                                ld      c,0
 448+ 81EF 7E           .KeyReadLoop:           ld      a,(hl)
 449+ 81F0 E6 02                                and     Bit1Only                        ; clear out bit 1 which elimiates state 3, so it can now be 2 (held) or 0 (not pressed or one off)
 450+ 81F2 C2 FC 81                             jp      nz,.KeyPressed
 451+ 81F5 23                                   inc     hl
 452+ 81F6 0C                                   inc     c
 453+ 81F7 10 F6                                djnz    .KeyReadLoop
 454+ 81F9                                      SetAFalse
 454+ 81F9 3E FF       >                        ld      a,$FF
 455+ 81FB C9                                   ret
 456+ 81FC 79           .KeyPressed:            ld      a,c
 457+ 81FD C9                                   ret
 458+ 81FE
 459+ 81FE
 460+ 81FE 00 00 00...  InputString             DS  30              ; used for a 30 character input buffer
 461+ 821C 00                                   DB  0               ; end of string marker as a safety
 462+ 821D 00           InputCursor             DB  0
 463+ 821E 00           EnterPressed            DB  0               ; zero notpressed FF pressed
 464+ 821F 00           InputChanged            DB  0
 465+ 8220              InputLimit              EQU 20
 466+ 8220
 467+ 8220 21 FE 81     keyboard_copy_input_to_de:  ld      hl,InputString
 468+ 8223 3A 1D 82                                 ld      a,(InputCursor)
 469+ 8226 FE 00                                    cp      0
 470+ 8228 28 05                                    jr      z,.NoString
 471+ 822A 4F                                       ld      c,a
 472+ 822B 06 00                                    ld      b,0
 473+ 822D ED B0                                    ldir
 474+ 822F 3E 00        .NoString                   ld      a,0
 475+ 8231 12                                       ld      (de),a
 476+ 8232 C9                                       ret
 477+ 8233
 478+ 8233 AF           initInputText:          xor     a
 479+ 8234 32 1D 82                             ld      (InputCursor),a
 480+ 8237                                      SetMemFalse EnterPressed
 480+ 8237 3E FF       >                        ld      a,$FF
 480+ 8239 32 1E 82    >                        ld      (EnterPressed),a
 481+ 823C                                      SetMemFalse InputChanged
 481+ 823C 3E FF       >                        ld      a,$FF
 481+ 823E 32 1F 82    >                        ld      (InputChanged),a
 482+ 8241 21 FE 81                             ld      hl,InputString
 483+ 8244 06 1E                                ld      b,30
 484+ 8246 77           .wipeloop:              ld      (hl),a
 485+ 8247 23                                   inc     hl
 486+ 8248 10 FC                                djnz    .wipeloop
 487+ 824A C9                                   ret
 488+ 824B
 489+ 824B              InputName:              SetMemFalse InputChanged
 489+ 824B 3E FF       >                        ld      a,$FF
 489+ 824D 32 1F 82    >                        ld      (InputChanged),a
 490+ 8250 CD D5 81                             call    is_any_key_pressed
 491+ 8253 FE FF                                cp      $FF
 492+ 8255 C8                                   ret     z
 493+ 8256 4F           .KeyPressed:            ld      c,a
 494+ 8257 3A 1D 82                             ld      a,(InputCursor)                 ; No key so we can now look at if we are at the end of the buffer
 495+ 825A FE 14                                cp      InputLimit                      ; move to variable later and then cp (hl)
 496+ 825C 28 0B                                jr      z,.DeleteOrEnterOnly            ;
 497+ 825E 21 2C 81                             ld      hl,ASCII_Map
 498+ 8261 79                                   ld      a,c
 499+ 8262 ED 31                                add     hl,a
 500+ 8264 7E                                   ld      a,(hl)
 501+ 8265 FE 41                                cp      "A"
 502+ 8267 30 0B                                jr      nc,.AlphaPressed
 503+ 8269              ; CAPS and Symbol act as delete for now
 504+ 8269 FE 20        .DeleteOrEnterOnly      cp      " "                             ; if space was  pressed (mapped to Hash in ASCII table))
 505+ 826B 28 33                                jr      z,.SpacePressed               ; for now we will ignore the shift and just assume delete
 506+ 826D FE 3E                                cp      ">"         ; ENTER
 507+ 826F 28 19                                jr      z,.EnterPressed
 508+ 8271 FE 23                                cp      "#"         ; CAPS
 509+ 8273 C9                                   ret
 510+ 8274 47           .AlphaPressed:          ld      b,a
 511+ 8275 3A 1D 82                             ld      a,(InputCursor)
 512+ 8278 4F                                   ld      c,a
 513+ 8279 21 FE 81                             ld      hl,InputString
 514+ 827C ED 31                                add     hl,a
 515+ 827E 78                                   ld      a,b
 516+ 827F 70                                   ld      (hl),b
 517+ 8280 79                                   ld      a,c
 518+ 8281 21 1D 82                             ld      hl,InputCursor
 519+ 8284 34                                   inc     (hl)
 520+ 8285                                      SetMemTrue InputChanged
 520+ 8285 AF          >                        xor     a
 520+ 8286 32 1F 82    >                        ld      (InputChanged),a
 521+ 8289 C9                                   ret
 522+ 828A 3A 1D 82     .EnterPressed:          ld      a,(InputCursor)
 523+ 828D 21 FE 81                             ld      hl,InputString
 524+ 8290 ED 31                                add     hl,a
 525+ 8292                                      ZeroA
 525+ 8292 AF          >                        xor a
 526+ 8293 77                                   ld      (hl),a
 527+ 8294                                      SetMemTrue EnterPressed
 527+ 8294 AF          >                        xor     a
 527+ 8295 32 1E 82    >                        ld      (EnterPressed),a
 528+ 8298                                      SetMemTrue InputChanged
 528+ 8298 AF          >                        xor     a
 528+ 8299 32 1F 82    >                        ld      (InputChanged),a
 529+ 829C CD 54 81                             call    init_keyboard           ; Flush keyboard status so futher inputs don't auto read the enter key as a second press
 530+ 829F C9                                   ret
 531+ 82A0 3A 1D 82     .SpacePressed:          ld      a,(InputCursor)         ; Space = delete
 532+ 82A3 FE 00                                cp      0                       ; if input is zero length then can not delete
 533+ 82A5 C8                                   ret     z
 534+ 82A6 3D                                   dec     a                       ; move back one and update cursor pos
 535+ 82A7 32 1D 82                             ld      (InputCursor),a         ;
 536+ 82AA 21 FE 81                             ld      hl,InputString          ; now update end of line to null
 537+ 82AD ED 31                                add     hl,a                    ; .
 538+ 82AF                                      ZeroA                           ; .
 538+ 82AF AF          >                        xor a
 539+ 82B0 77                                   ld      (hl),a                  ; .
 540+ 82B1                                      SetMemTrue InputChanged
 540+ 82B1 AF          >                        xor     a
 540+ 82B2 32 1F 82    >                        ld      (InputChanged),a
 541+ 82B5 C9                                   ret
 542+ 82B6
 543+ 82B6 AF           MovementKeyTest:        xor     a
 544+ 82B7 32 52 85                             ld      (CursorKeysPressed),a
 545+ 82BA 3A 71 84                             ld      a,(MenuIdMax)
 546+ 82BD E6 FC                                and     $FC
 547+ 82BF 20 26                                jr      nz,CursorKeys
 548+ 82C1 2A E6 80     ClimbDiveKeys:          ld      hl,(addr_Pressed_Climb)
 549+ 82C4 7E                                   ld      a,(hl)
 550+ 82C5                                      JumpIfAIsZero ScanDiveKey
 550+ 82C5 A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
 550+ 82C6 CA D4 82    >                        jp	z, ScanDiveKey
 551+ 82C9 3A 52 85                             ld      a,(CursorKeysPressed)
 552+ 82CC F6 80                                or      $80
 553+ 82CE 32 52 85                             ld      (CursorKeysPressed),a
 554+ 82D1 C3 0A 83                             jp      ScanLeftKey
 555+ 82D4 2A E4 80     ScanDiveKey:            ld      hl,(addr_Pressed_Dive)
 556+ 82D7 7E                                   ld      a,(hl)
 557+ 82D8                                      JumpIfAIsZero ScanLeftKey
 557+ 82D8 A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
 557+ 82D9 CA 0A 83    >                        jp	z, ScanLeftKey
 558+ 82DC 3A 52 85                             ld      a,(CursorKeysPressed)
 559+ 82DF F6 40                                or      $40
 560+ 82E1 32 52 85                             ld      (CursorKeysPressed),a
 561+ 82E4 C3 0A 83                             jp      ScanLeftKey
 562+ 82E7 2A 22 81     CursorKeys:             ld      hl,(addr_Pressed_CursorUp)
 563+ 82EA 7E                                   ld      a,(hl)
 564+ 82EB                                      JumpIfAIsZero ScanCursorDownKey
 564+ 82EB A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
 564+ 82EC CA FA 82    >                        jp	z, ScanCursorDownKey
 565+ 82EF 3A 52 85                             ld      a,(CursorKeysPressed)
 566+ 82F2 F6 80                                or      $80
 567+ 82F4 32 52 85                             ld      (CursorKeysPressed),a
 568+ 82F7 C3 0A 83                             jp      ScanLeftKey
 569+ 82FA 2A 24 81     ScanCursorDownKey:      ld      hl,(addr_Pressed_CursorDown)
 570+ 82FD 7E                                   ld      a,(hl)
 571+ 82FE                                      JumpIfAIsZero ScanLeftKey
 571+ 82FE A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
 571+ 82FF CA 0A 83    >                        jp	z, ScanLeftKey
 572+ 8302 3A 52 85                             ld      a,(CursorKeysPressed)
 573+ 8305 F6 40                                or      $40
 574+ 8307 32 52 85                             ld      (CursorKeysPressed),a
 575+ 830A 2A E0 80     ScanLeftKey:            ld      hl,(addr_Pressed_RollLeft)
 576+ 830D 7E                                   ld      a,(hl)
 577+ 830E                                      JumpIfAIsZero ScanRightKey
 577+ 830E A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
 577+ 830F CA 1B 83    >                        jp	z, ScanRightKey
 578+ 8312 3A 52 85                             ld      a,(CursorKeysPressed)
 579+ 8315 F6 20                                or      $20
 580+ 8317 32 52 85                             ld      (CursorKeysPressed),a
 581+ 831A C9                                   ret
 582+ 831B 2A E2 80     ScanRightKey:           ld      hl,(addr_Pressed_RollRight)
 583+ 831E 7E                                   ld      a,(hl)
 584+ 831F                                      JumpIfAIsZero ScanHomeKey
 584+ 831F A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
 584+ 8320 CA 2C 83    >                        jp	z, ScanHomeKey
 585+ 8323 3A 52 85                             ld      a,(CursorKeysPressed)
 586+ 8326 F6 10                                or      $10
 587+ 8328 32 52 85                             ld      (CursorKeysPressed),a
 588+ 832B C9                                   ret
 589+ 832C 2A 00 81     ScanHomeKey:            ld      hl,(addr_Pressed_HomeCursor)
 590+ 832F 7E                                   ld      a,(hl)
 591+ 8330                                      JumpIfAIsZero ScanRecentreKey
 591+ 8330 A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
 591+ 8331 CA 3D 83    >                        jp	z, ScanRecentreKey
 592+ 8334 3A 52 85                             ld      a,(CursorKeysPressed)
 593+ 8337 F6 08                                or      $08
 594+ 8339 32 52 85                             ld      (CursorKeysPressed),a
 595+ 833C C9                                   ret
 596+ 833D 2A 1C 81     ScanRecentreKey:        ld      hl,(addr_Pressed_Recentre)
 597+ 8340 7E                                   ld      a,(hl)
 598+ 8341                                      ReturnIfAIsZero
 598+ 8341 A7          >                        and     a
 598+ 8342 C8          >                        ret     z
 599+ 8343 3A 52 85                             ld      a,(CursorKeysPressed)
 600+ 8346 F6 04                                or      $04
 601+ 8348 32 52 85                             ld      (CursorKeysPressed),a
 602+ 834B C9                                   ret
 603+ 834C
 604+ 834C
# file closed: ./Hardware/keyboard.asm
 117  834C                  INCLUDE "./Data/EquipmentEquates.asm"
# file opened: ./Data/EquipmentEquates.asm
   1+ 834C
   2+ 834C              EQ_FUEL                 EQU 0
   3+ 834C              EQ_MISSILE              EQU 1
   4+ 834C              EQ_CARGO_BAY            EQU 2
   5+ 834C              EQ_ECM                  EQU 3
   6+ 834C              EQ_FUEL_SCOOPS          EQU 4
   7+ 834C              EQ_ESCAPE_POD           EQU 5
   8+ 834C              EQ_ENERGY_BOMB          EQU 6
   9+ 834C              EQ_ENERGY_UNIT          EQU 7
  10+ 834C              EQ_DOCK_COMP            EQU 8
  11+ 834C              EQ_GAL_DRIVE            EQU 9
  12+ 834C              EQ_FRONT_PULSE          EQU 10
  13+ 834C              EQ_REAR_PULSE           EQU 11
  14+ 834C              EQ_LEFT_PULSE           EQU 12
  15+ 834C              EQ_RIGHT_PULSE          EQU 13
  16+ 834C              EQ_FRONT_BEAM           EQU 14
  17+ 834C              EQ_REAR_BEAM            EQU 15
  18+ 834C              EQ_LEFT_BEAM            EQU 16
  19+ 834C              EQ_RIGHT_BEAM           EQU 17
  20+ 834C              EQ_FRONT_MINING         EQU 18
  21+ 834C              EQ_REAR_MINING          EQU 19
  22+ 834C              EQ_LEFT_MINING          EQU 20
  23+ 834C              EQ_RIGHT_MINING         EQU 21
  24+ 834C              EQ_FRONT_MILITARY       EQU 22
  25+ 834C              EQ_REAR_MILITARY        EQU 23
  26+ 834C              EQ_LEFT_MILITARY        EQU 24
  27+ 834C              EQ_RIGHT_MILITARY       EQU 25
  28+ 834C
  29+ 834C              EQ_ITEM_COUNT           EQU EQ_RIGHT_MILITARY+1
  30+ 834C
# file closed: ./Data/EquipmentEquates.asm
 118  834C                  INCLUDE "./Variables/constant_equates.asm"
# file opened: ./Variables/constant_equates.asm
   1+ 834C              ;Contants
   2+ 834C
   3+ 834C              SignMask8Bit		equ %01111111
   4+ 834C              SignMask16Bit		equ %0111111111111111
   5+ 834C              SignOnly8Bit		equ $80
   6+ 834C              SignOnly16Bit		equ $8000
   7+ 834C
   8+ 834C              Bit7Only            equ %10000000
   9+ 834C              Bit6Only            equ %01000000
  10+ 834C              Bit5Only            equ %00100000
  11+ 834C              Bit4Only            equ %00010000
  12+ 834C              Bit3Only            equ %00001000
  13+ 834C              Bit2Only            equ %00000100
  14+ 834C              Bit1Only            equ %00000010
  15+ 834C              Bit0Only            equ %00000001
  16+ 834C              Bit7Clear           equ %01111111
  17+ 834C              Bit6Clear           equ %10111111
  18+ 834C              Bit5Clear           equ %11011111
  19+ 834C              Bit4Clear           equ %11101111
  20+ 834C              Bit3Clear           equ %11110111
  21+ 834C              Bit2Clear           equ %11111011
  22+ 834C              Bit1Clear           equ %11111101
  23+ 834C              Bit0Clear           equ %11111110
  24+ 834C              ConstPi				equ $80
  25+ 834C              ConstNorm           equ 197
  26+ 834C
  27+ 834C              ;Text Tokens
  28+ 834C              EliteToken			equ $1E			; Token ID for text messsage ---- E L I T E ----
  29+ 834C              BrabenBellToken 	equ $0D
  30+ 834C              AcorToken			equ $0C
  31+ 834C
  32+ 834C              ; Intro Screen
  33+ 834C              TitleShip			equ	$8C
  34+ 834C              RotationUnity		equ $60
  35+ 834C              DBCheckCode			equ $DB
  36+ 834C              MaxVisibility		equ $1F
  37+ 834C              FarInFront			equ $C0
  38+ 834C
  39+ 834C              ; Universe Managment
  40+ 834C              ShipTypeJunk        equ 3
  41+ 834C              ShipTypeStation     equ 2
  42+ 834C              ShipTypeMissile     equ 1
  43+ 834C              ShipTypeNormal      equ 0
  44+ 834C              ShipTypeText        equ 253
  45+ 834C              ShipTypeDebug       equ 254
  46+ 834C              ShipTypeEmpty       equ 255
  47+ 834C              ; TacticsControl
  48+ 834C              ShipIsTrader        equ Bit0Only   ; Trader flag  80% are peaceful 20% also have Bounty Hunter flag
  49+ 834C              ShipIsBountyHunter  equ Bit1Only   ;
  50+ 834C              ShipIsHostile       equ Bit2Only   ;
  51+ 834C              ShipNotHostile      equ Bit2Clear   ;
  52+ 834C              ShipIsPirate        equ Bit3Only   ;
  53+ 834C              ShipIsDocking       equ Bit4Only   ;
  54+ 834C              ShipIsBystander     equ Bit5Only   ;
  55+ 834C              ShipIsCop           equ Bit6Only   ;
  56+ 834C              ShipIsScoopDockEsc  equ Bit7Only   ;
  57+ 834C              ShipAIEnabled       equ Bit7Only   ;
  58+ 834C              ShipExploding       equ Bit5Only
  59+ 834C              ShipKilled          equ Bit7Clear
  60+ 834C
  61+ 834C              ; UniverseAIControl
  62+ 834C              ShipCanAnger        equ %00000001
  63+ 834C
  64+ 834C
  65+ 834C              ShipMaxDistance     equ 192
  66+ 834C              HyperSpaceTimers    equ $0B0B
  67+ 834C
  68+ 834C
  69+ 834C              MaxNumberOfStars	equ 11
  70+ 834C              ConsoleRefreshInterval  equ 4
  71+ 834C
  72+ 834C              ShipTypeSize		equ	32 			;??????? just a guess for now
  73+ 834C              ShipSST				equ 4			; its a space station
  74+ 834C              UniverseBasePage 	equ 70			; Base memory bank for universe Item #0
  75+ 834C              ShipDataBasePage	equ	90			; Needs 2mb upgrade but what the heck
  76+ 834C              ShipCountMax		equ	2			; For now just 2 ships to debug
  77+ 834C              LineLimitPerShip	equ 70			; Max lines per ship
  78+ 834C              FaceLimitPerShip	equ	70			; Same as line limit to simplify some logic
  79+ 834C              ; "NEED TO DEFINE SHIPTYPESIZE TODO"
  80+ 834C              PlayerDocked		equ	$FF
  81+ 834C
  82+ 834C              ; Memory page managment	(Refers to a memory slot as a place to access data)
  83+ 834C              ShipDataSlot		equ	6			; this may move into rom swap out space later
  84+ 834C              UniverseObjectSlot	equ	7
  85+ 834C
  86+ 834C              KeyForwardsView		equ	$20
  87+ 834C              ; Game specific equates
  88+ 834C              MissileDropHeight   equ 5           ; how far the missile is ejected on launch in y axis
  89+ 834C
  90+ 834C              ;...Game Colour Mapping
  91+ 834C              L2DustColour        equ L2ColourGREY_1
  92+ 834C              L2SunScannerBright  equ 252
  93+ 834C              L2SunScanner        equ 180
  94+ 834C
  95+ 834C
  96+ 834C              ; Ship Data
  97+ 834C              ;;;;	.XX21	\ -> &5600 \ Table of pointers to ships' data given to XX0
  98+ 834C              ;;;;00 7F			 EQUW &7F00 \ type  1 is #MSL  Missile data on page off bottom of screen
  99+ 834C              ;;;;00 00			 EQUW 0     \ type  2 is #SST  Space Station, Coriolis or Dodo.
 100+ 834C              ;;;;00 00			 EQUW 0     \ type  3 is #ESC  Escape capsule
 101+ 834C              ;;;;00 00			 EQUW 0     \ type  4 is #PLT  Plate, alloys
 102+ 834C              ;;;;00 00			 EQUW 0     \ type  5 is #OIL  Cargo cannister
 103+ 834C              ;;;;00 00			 EQUW 0     \ type  6 is       Boulder
 104+ 834C              ;;;;00 00			 EQUW 0     \ type  7 is #AST  Asteroid
 105+ 834C              ;;;;00 00			 EQUW 0     \ type  8 is #SPL  Splinter, rock.
 106+ 834C              ;;;;00 00			 EQUW 0     \ type  9 is #SHU  Shuttle
 107+ 834C              ;;;;00 00			 EQUW 0     \ type 10 is       Transporter
 108+ 834C              ;;;;00 00			 EQUW 0     \ type 11 is #CYL  Cobra Mk III,  Boa
 109+ 834C              ;;;;00 00			 EQUW 0     \ type 12 is       Python
 110+ 834C              ;;;;00 00			 EQUW 0     \ type 13 is       Last of three traders
 111+ 834C              ;;;;00 00			 EQUW 0     \ type 14 is #ANA  Anaconda
 112+ 834C              ;;;;00 00			 EQUW 0     \ type 15 is #WRM  Worm with Anaconda
 113+ 834C              ;;;;00 00			 EQUW 0     \ type 16 is #COP  Viper
 114+ 834C              ;;;;00 00			 EQUW 0     \ type 17 is       First pirate
 115+ 834C              ;;;;00 00			 EQUW 0     \ type 18 is
 116+ 834C              ;;;;00 00			 EQUW 0     \ type 19 is #KRA  Krait small pirate
 117+ 834C              ;;;;00 00			 EQUW 0     \ type 20 is #ADA  Adder
 118+ 834C              ;;;;00 00			 EQUW 0     \ type 21 is
 119+ 834C              ;;;;00 00			 EQUW 0     \ type 22 is
 120+ 834C              ;;;;00 00			 EQUW 0     \ type 23 is
 121+ 834C              ;;;;00 00			 EQUW 0     \ type 24 is #CYL2 Last strong pirate
 122+ 834C              ;;;;00 00			 EQUW 0     \ type 25 is #ASP  Asp Mk II
 123+ 834C              ;;;;00 00			 EQUW 0     \ type 26 is #FER  Fer de Lance
 124+ 834C              ;;;;00 00			 EQUW 0     \ type 27 is
 125+ 834C              ;;;;00 00			 EQUW 0     \ type 28 is	Last of three bounty hunters
 126+ 834C              ;;;;00 00			 EQUW 0     \ type 29 is #THG  Thargoid
 127+ 834C              ;;;;00 00			 EQUW 0     \ type 30 is #TGL  Thargon
 128+ 834C              ;;;;00 00			 EQUW 0     \ type 31 is #CON  Constrictor
 129+ 834C              ;;;;	.E%	\ -> &563E \ Hull NEWB bits are escpod, cop, inno, ?, pirate, angry, hunter, trader.
 130+ 834C              ;;;;			\ NEWB examples
 131+ 834C              ;;;;\ 21			EQUB &21    \ 0010 0001    9 Shuttle has no escape pod, inno, trader.
 132+ 834C              ;;;;\ 61			EQUB &61    \ 0110 0001   10 Tansporter no escape pod, Cop, inno, trader.
 133+ 834C              ;;;;\ A0			EQUB &A0    \ 1010 0000   11 Cobra has Escape pod, inno, not a trader.
 134+ 834C              ;;;;\ C2			EQUB &C2    \ 1100 0010   16 Viper has Escape pod, Cop, hunter.
 135+ 834C              ;;;;\ 8C			EQUB &8C    \ 1000 1100   19 Krait pirate has escape pod, is pirate and angry.
 136+ 834C
# file closed: ./Variables/constant_equates.asm
 119  834C                  INCLUDE "./Variables/general_variables.asm"
# file opened: ./Variables/general_variables.asm
   1+ 834C
   2+ 834C
   3+ 834C 00 00        varAxis1	DW 	0				; address of first axis in a rotation action
   4+ 834E 00 00        varAxis2	DW	0				; address of 2nd axis in a roation action
   5+ 8350              ; Variables to simulate 6502 registers until code fixed
   6+ 8350              ; These must be here in this order as reading Y and X can then be a 16 bit read
   7+ 8350 00           regX		DB	0               ; using 16 bit read into BC this would go into C
   8+ 8351 00           regY		DB	0               ; using 16 bit read into BC this would go into B
   9+ 8352 00           regA		DB	0
  10+ 8353
  11+ 8353
  12+ 8353 00           varGPLoopA	DB	0				; General Purpose innermost loop variable
  13+ 8354 00 00        INF			DW	0				; page 0 &20 Used to get address from UNIV array
  14+ 8356 00 00        INF28		DW	0				; page 0 &20 Used to get address from UNIV array
  15+ 8358
  16+ 8358
  17+ 8358
  18+ 8358              ;XX16		DS	16				; 16 byte Matrix
  19+ 8358
  20+ 8358              P0INWK							; page 0 & 46
  21+ 8358              p0INWK31						; page 0 & 65
  22+ 8358              P0INWK36						; PAGE 0 &6A
  23+ 8358
  24+ 8358 00           XX4			DB	0				; XX4 page 0 &96 last Normal Found to be visible
  25+ 8359              LastNormalVisible	equ	XX4
  26+ 8359              varXX4              equ XX4
  27+ 8359
  28+ 8359
  29+ 8359
  30+ 8359 00           PATG		DB	0				; 6502 &03C9
  31+ 835A 00 00        SLSP 		DW	0				; &03B0 \ SLSP \ ship lines pointer
  32+ 835C
  33+ 835C
  34+ 835C              ;UNIV		DS FreeListSize*2	; Array of Universe Pointers
  35+ 835C              ;HULLINDEX	DS ShipTypeSize*2	; hull index for table at XX21= &5600 XX21-1,Y
  36+ 835C
  37+ 835C              ; Present System Variables
  38+ 835C
  39+ 835C 2B           RandomSeed				DB	43			; 00 DEBUG JUST SOME START VALUES
  40+ 835D 20           RandomSeed1				DB	32	; 01
  41+ 835E 0C           RandomSeed2				DB	12			; 02
  42+ 835F 42           RandomSeed3				DB	66			; 03
  43+ 8360
  44+ 8360 00           varT1					DB	0				; 06
  45+ 8361 00           SClo					DB 0				; 07
  46+ 8362 00           SChi					DB 0				; 08
  47+ 8363 00           varP					DB 0 				; 10	XX16+7
  48+ 8364 00           varPhi					DB 0 				; 11	XX16+8
  49+ 8365 00           varPhi2					DB 0 				; 12	XX16+9
  50+ 8366              varPp1                  equ varPhi
  51+ 8366              varPp2                  equ varPhi2
  52+ 8366 00           UnivPointerLo			DB	0				; 20		INF                 XX0+2
  53+ 8367 00           UnivPointerHi			DB	0				; 21      INF+1               XX0+3
  54+ 8368              UnivPointer				equ	UnivPointerLo
  55+ 8368 00           varV					DB 0				; 22                          XX0+4
  56+ 8369 00           varVHi					DB 0				; 23                          XX0+5
  57+ 836A 00           varXXlo                 DB 0                ; 24
  58+ 836B 00           varXXHi                 DB 0                ; 25
  59+ 836C              varXX					equ	varXXlo
  60+ 836C 00           YYlo                    DB 0                ; 26
  61+ 836D 00           YYHi                    DB 0                ; 27
  62+ 836E              varYY					equ	YYlo
  63+ 836E              											;	28
  64+ 836E              											;	29
  65+ 836E              ;PlayerShipPositionData - Must be contiguous for setup
  66+ 836E 00           BETA 					DB	0               ; 2A        (pitch done)
  67+ 836F 00           JSTY                    DB  0               ; Joystick analog
  68+ 8370 00           BET1 					DB	0               ; 2B        lower7 magnitude
  69+ 8371 00           BET2                    DB  0               ;            climb sign
  70+ 8372 00           BET2FLIP				DB	0				; 7C		BET 2 pitch Sign negated
  71+ 8373 1F           BET1MAXC                DB  31              ; max climb
  72+ 8374 E1           BET1MAXD                DB  -31             ; max dive
  73+ 8375 00           XC						DB	0               ; 2C
  74+ 8376 00           YC						DB 	0               ; 2D
  75+ 8377              ;... ECM logic. If another ship adds ECM then we just set the loop A and B to starting values so they overlap
  76+ 8377 00           ECMActive				DB 	0				; 30		ECM Active flag
  77+ 8378 00           ECMLoopA                DB  0
  78+ 8379 00           ECMLoopB                DB  0
  79+ 837A 00 00        JSTX                    DW  0               ;           Joystick analog value
  80+ 837C 00           ALPHA					DB	0				; 8D        Alpha with bit 7 sign
  81+ 837D 00           ALP1					DB 	0				; 31		ALP1	Roll magnitude Also Apha
  82+ 837E 00           ALP2					DB  0				; 32		ALP2	Roll Sign
  83+ 837F 00           ALP2FLIP				DB  0				; 33		ALP2	negated roll sign
  84+ 8380 1F           ALP1MAXR                DB  31               ;   Maximum roll, added becuase we may allow different ship types
  85+ 8381 E1           ALP1MAXL                DB  -31             ;   Maximum roll, added becuase we may allow different ship types
  86+ 8382
  87+ 8382
  88+ 8382
  89+ 8382              MAXMESSAGES             EQU 5
  90+ 8382              MESSAGETIMELIMIT        EQU 20
  91+ 8382              MESSAGESIZE             EQU 33
  92+ 8382              MESSAGELINE             EQU $0001
  93+ 8382
  94+ 8382 00           MessageCount            DB  0                ; used for enquing messages later
  95+ 8383 00           MessageCurrent          DB  0
  96+ 8384 05 00        MessageIndex            DW  MAXMESSAGES
  97+ 8386 00 00 00...  MessageQueue            DS  MAXMESSAGES * MESSAGESIZE
  98+ 842B 05           MessageTimeout          DB  MAXMESSAGES
  99+ 842C 00 00 00...  IndexedWork				DS	37				; General purpose work space when doing temp arrays
 100+ 8451
 101+ 8451              ; MOVED TO Universe XX19					DB	0				; page 0 &67
 102+ 8451              ; MOVED TO Universe XX20					DB	0				; page 0 &67 also used as XX19+1 for XX19 being a word
 103+ 8451              ;DEFUNCT EQUATE NormalCountCopyBy4		equ	XX20			; Also used for normal * 4 holding variable
 104+ 8451 00           XX21					DB  0				; this may be part of XX20/xx21 accordign to spawn new shipXX21		DW	0				; Ah XX21 is hull pointer  hull pointer lo as it can;t hold HULLINDX as 16bit array
 105+ 8452              ;XX21 is the pointer table to the pages for ship types. this will be repalaced by paging so just need an equate for first page
 106+ 8452
 107+ 8452
 108+ 8452 00 00 00...  SystemSeed				DS  5				;	6C		QQ15	Current Galaxy Seed
 109+ 8457              											;	6D		QQ15+1
 110+ 8457              											;	6E		QQ15+2
 111+ 8457              											;	6F		QQ15+3
 112+ 8457              											;	70		QQ15+4
 113+ 8457              											;	71		QQ15+5
 114+ 8457 00           QQ17					DB	0				;   72
 115+ 8458 00           XX18xlo                 DB  0               ;	72		XX18   xlo
 116+ 8459 00           XX18xhi                 DB  0               ;	73		XX18+1 xhi
 117+ 845A 00           XX18xsg                 DB  0               ;	74		XX18+2 xsgn
 118+ 845B 00           XX18ylo                 DB  0               ;	75		XX18   ylo
 119+ 845C 00           XX18yhi                 DB  0               ;	76		XX18+1 yhi
 120+ 845D 00           XX18ysg                 DB  0               ;	77		XX18+2 ysgn
 121+ 845E 00           XX18zlo                 DB  0               ;	78		XX18   zlo
 122+ 845F 00           XX18zhi                 DB  0               ;	79		XX18+1 zhi
 123+ 8460 00           XX18zsg                 DB  0               ;	7A		XX18+2 zsgn
 124+ 8461
 125+ 8461 28           SHIPMAXSPEED            DB  40              ; variable to facilitate ship editing later
 126+ 8462 00           DELTA					DB 	0				; 7D 		DELTA  \ bpl -2 inserted here to stall from title code if byte check fails
 127+ 8463 00           DELT4Lo					DB 	0				; 7E
 128+ 8464 00           DELT4Hi					DB 	0				; 7F
 129+ 8465              DELTA4                  equ                 DELT4Lo
 130+ 8465
 131+ 8465
 132+ 8465              ; Not thise must be in this order else 16 bit fetches will fail
 133+ 8465 00           varU                    DB  0               ;   80
 134+ 8466 00           varQ					DB  0 				;	81
 135+ 8467 00           varR					DB  0 				;	82
 136+ 8468 00           varS					DB  0 				;	83
 137+ 8469              varRS                   equ varR
 138+ 8469
 139+ 8469 00 00        varU16                  DW  0               ; 16 bit variant on varU as I can't use above for this
 140+ 846B
 141+ 846B 00           XSAV					DB	0				; 84	   XSAV usef for nearby ship count outer
 142+ 846C 00           YSAV                    DB  0               ; 85
 143+ 846D 00           XX17					DB	0				; 86
 144+ 846E              RequiredScale			equ  XX17			; use to hold calculated scale in drawing ship
 145+ 846E              varXX17                 equ  XX17
 146+ 846E 00           ScreenChanged           DB  0
 147+ 846F 00           ScreenIndex             DB  0
 148+ 8470 00           InvertedYAxis           DB  0
 149+ 8471 00           MenuIdMax				DB	0				;	87		MenuIdMax		QQ11
 150+ 8472              											; Bit 7 Set  ShortRangeChart    $80
 151+ 8472              											; Bit 6 Set  Galactic Chart     $40
 152+ 8472              											; Bit 5 Set  Market Place       $20
 153+ 8472              											; Bit 4 Set  Status Screen      $10
 154+ 8472              											; Bit 3 Set  Display Inventory  $08
 155+ 8472                                                          ; Bit 2 Set  Planet Data        $04
 156+ 8472                                                          ; View bit combinations if the ones above not matched
 157+ 8472                                                          ; bits 1 0
 158+ 8472                                                          ;      1 1  Front view , i.e. $03
 159+ 8472                                                          ;      1 0  Aft View          $02
 160+ 8472                                                          ;      0 1  Left View         $01
 161+ 8472                                                          ;      0 0  Right view        $00
 162+ 8472              											; Bit 0 Set  Data On System
 163+ 8472              											; 0  Space View (Not a menu)
 164+ 8472 00           ZZDust					DB	0				;	88		ZZDust (Poss 16 bit need to check)
 165+ 8473 00           XX13                    DB  0               ;   89
 166+ 8474 00           TYPE					DB	0				; 8C used for ship type in drawing
 167+ 8475              ;Docked flag = 00 = in free space
 168+ 8475              ;              FF = Docked
 169+ 8475              ;              FE = transition
 170+ 8475              ;              FD = Setup open space and transition to not docked
 171+ 8475              ;              FC = Hyperspace manimation
 172+ 8475              ;              FB = Hyperspace complete
 173+ 8475 00           DockedFlag				DB	0				; 8E -
 174+ 8476 00           GamePaused              DB  0
 175+ 8477 00           varSWAP                 DB  0               ; 90 , general purpose swap variable
 176+ 8478 00           varCNT                  DB  0               ; 93
 177+ 8479
 178+ 8479 00           varK					DB	0				; 40
 179+ 847A 00           varKp1					DB	0				; 41
 180+ 847B 00           varKp2					DB	0				; 42
 181+ 847C 00           varKp3					DB	0				; 43
 182+ 847D
 183+ 847D 00           varK2                   DB  0               ; 9B
 184+ 847E 00           varK2p1                 DB  0               ; 9C K2 plus 1
 185+ 847F 00           varK2p2                 DB  0               ; 9D K2 plus 2
 186+ 8480 00           varK2p3                 DB  0               ; 9E K2 plus 3
 187+ 8481
 188+ 8481 00           Point                   DB  0               ; 9F      POINT
 189+ 8482
 190+ 8482 00           varT					DB	0				; D1
 191+ 8483
 192+ 8483 00 00 00...  varVector9ByteWork      DS  9
 193+ 848C
 194+ 848C 00 00 00 00  varK3					DS	4				; D2
 195+ 8490 00           varK3p2					DB	0				; 42
 196+ 8491 00           varK3p3					DB	0				; 43
 197+ 8492              varK3p1					equ varK3+1			; D3
 198+ 8492 00 00 00 00  varK4					DS	4				; E0
 199+ 8496              varK4p1					equ varK4+1			; D3
 200+ 8496
 201+ 8496
 202+ 8496              ;Heap
 203+ 8496
 204+ 8496 00 00        HeapStart				DS	2				; &0100 XX3 50 bytes for now
 205+ 8498 00 00 00...  HeapData				DS	50
 206+ 84CA              ; Contains 				X 16 bit, Y ;MissileArmedStatus		DB	0				; 0344 MSAR   using MissileTarget, if missile is not armed tehn target is FF
 207+ 84CA              ; TODO will need an read for a list of missiles, who they are targeting an the target current vector for AI persuit
 208+ 84CA              ; i.e. a list of programmed missiles in universe slot list code
 209+ 84CA 00 00 00...  DampingKeys				DS  7				; 0387 - 038D
 210+ 84D1              ;  #&6 Does K toggle keyboard/joystick control -  03CD certainly makes keyboard not work anymore.
 211+ 84D1              ;  #&5 Does J reverse both joystick channels
 212+ 84D1              ;  #&4 Does Y reverse joystick Y channel			03CB
 213+ 84D1              ;  #&2 Does X toggle startup message display ? PATG?	03C9
 214+ 84D1              ;  #&3 Does F toggle flashing information			03CA
 215+ 84D1              ;  #&1 Does A toggle keyboard auto-recentering ?
 216+ 84D1              ;  #&0 Caps-lock toggles keyboard flight damping
 217+ 84D1 00           NbrMissiles				DB	0				; 038B	Does this clash with Dampingkeys?
 218+ 84D2 00           FugitiveInnocentStatus	DB	0				; 038C	FIST
 219+ 84D3 00 00 00...  StockAvaliabiliy		DS 	16				; 038D - 039C Stock inventory in station
 220+ 84E3 00           AlienItemsAvaliability  DB	0				; 039D
 221+ 84E4 00           RandomMarketSeed		DB	0				; 039E   \ QQ26	\ random byte for each system vist (for market)
 222+ 84E5 00 00        KillTally  				DW	0				; 039F - 03A0 \ TALLY   \ kills lo hi
 223+ 84E7 00           COMP     				DB	0				; 03A1 2nd competion byte used for save integrity checks?
 224+ 84E8              											;
 225+ 84E8 00           MCH						DB	0				; 03A4  \ MCH  \ old message to erase
 226+ 84E9 00           MarketPrice				DB	0				; 03AA QQ24
 227+ 84EA 00           MaxStockAvaliable		DB  0				; 03AB   \ QQ25     \ max available
 228+ 84EB 00           SystemEconomy			DB  0				; 03AC \ QQ28   \ the economy byte of present system (0 is Rich Ind.)
 229+ 84EC 00           CargoItem				DB	0				; 03AD (I think its item type just scooped) QQ29
 230+ 84ED 00 00        ShipLineStackPointer	DW	0				; 03B0 & 03B1 ship Lines pointer reset to top LS% = &0CFF (make DW for z80 and direct hl pointer)
 231+ 84EF              											; this is ship lines stack pointer so may be redundant with paging
 232+ 84EF              											; LS = line stack so we will have one for now to remove later
 233+ 84EF 00           COK						DB	0				; 0366 Competition Byte what ? Does some file check and accelleration check
 234+ 84F0 00           DisplayEcononmy			DB	0				; 03B8
 235+ 84F1 00           DisplayGovernment		DB  0				; 03B9 Is it target? 03B9 \ QQ4	 \ Government, 0 is Anarchy.
 236+ 84F2 00           DisplayTekLevel			DB	0				; 03BA   \ QQ5	\ Tech
 237+ 84F3 00 00        DisplayPopulation		DW	0				; 03BB \ QQ6  \ population*10
 238+ 84F5 00 00        DisplayProductivity		DW	0				; 03BD \ QQ7   \ productivity*10
 239+ 84F7 00 00        Distance          		DW	0				; 03BE \ QQ8 distince in 0.1LY units
 240+ 84F9 00 00        DisplayRadius			DW	0
 241+ 84FB              ; --- Used in creation of sun and planet----;
 242+ 84FB 00           PlanetXPos              DS  1
 243+ 84FC 00           PlanetYPos              DS  1
 244+ 84FD 00           PlanetZPos              DS  1
 245+ 84FE 00           PlanetType              DS  1
 246+ 84FF 00           SunXPos                 DS  1
 247+ 8500 00           SunYPos                 DS  1
 248+ 8501 00           SunZPos                 DS  1
 249+ 8502              ; -- Current Missile Runbtime data
 250+ 8502 00           CurrentMissileBank:     DB      0                                   ; used by missile logic as local copy of missile bank number
 251+ 8503 00 00        MissileXPos             DW      0
 252+ 8505 00           MissileXSgn             DB      0
 253+ 8506 00 00        MissileYPos             DW      0
 254+ 8508 00           MissileYSgn             DB      0
 255+ 8509 00 00        MissileZPos             DW      0
 256+ 850B 00           MissileZSgn             DB      0
 257+ 850C 00 00        CurrentTargetXpos       DS      2
 258+ 850E 00 00        CurrentTargetXsgn       DS      2
 259+ 8510 00 00        CurrentTargetYpos       DS      2
 260+ 8512 00 00        CurrentTargetYsgn       DS      2
 261+ 8514 00 00        CurrentTargetZpos       DS      2
 262+ 8516 00 00        CurrentTargetZsgn       DS      2
 263+ 8518 00 00        TargetVectorXpos        DS      2
 264+ 851A 00 00        TargetVectorXsgn        DS      2
 265+ 851C 00 00        TargetVectorYpos        DS      2
 266+ 851E 00 00        TargetVectorYsgn        DS      2
 267+ 8520 00 00        TargetVectorZpos        DS      2
 268+ 8522 00 00        TargetVectorZsgn        DS      2
 269+ 8524 00           CurrentMissileBlastRange:      DB  0                       ; TODO Initi for runtime copied in when setting up a missile
 270+ 8525 00           CurrentMissileBlastDamage:     DB  0                       ; TODO Initi for runtime copied in when setting up a missile
 271+ 8526 00           CurrentMissileDetonateRange:   DB  0                       ; TODO Initi for runtime copied in when setting up a missile, allows for proximity missiles
 272+ 8527 00           CurrentMissileDetonateDamage:  DB  0                       ; TODO Initi for runtime copied in when setting up a missile
 273+ 8528
 274+ 8528              ; --- Main Loop Data -----------------------;
 275+ 8528 00           CurrentUniverseAI       DB  0               ; current ship unviverse slot due an AI update
 276+ 8529 00           SelectedUniverseSlot    DB  0
 277+ 852A 00           SetStationAngryFlag     DB  0               ; used to semaphore angry space station
 278+ 852B 00           ShipBlastCheckCounter   DB  0
 279+ 852C 00           InnerHyperCount			DB 	0				; 2F QQ22+1
 280+ 852D 00           OuterHyperCount			DB 	0				; 2E QQ22
 281+ 852E 00           EventCounter            DB  0
 282+ 852F 00           HyperCircle             DB  0
 283+ 8530 00           MissJumpFlag            DB  0
 284+ 8531 00           PlayerMisJump			DB	0				; $0341 witchspace misjump
 285+ 8532 00           HyperSpaceFX			DB	0				; 0348 HFX (probabyl BBC specific
 286+ 8533 00           ExtraVessels			DB	0				; 0349 EV Use d by cops, extra vessels still to spawn?
 287+ 8534 00           Delay					DB	0				; 034A Delay general purpose eg. spawing EV or when printign messages
 288+ 8535 00           CurrentMissileCheck:    DB  0               ; if > Universe Slot list then free for next missile
 289+ 8536 00           MessageForDestroyed		DB	0				; 034B Message flag for item + destroyed
 290+ 8537              UniverseSlotListSize    equ	12
 291+ 8537 00 00 00...  UniverseSlotList        DS  UniverseSlotListSize
 292+ 8543 00 00 00...  UniverseSlotType        DS  UniverseSlotListSize ; base type, e.g. missile, cargo etc,
 293+ 854F              ; Probably not needed UniverseTypeCount       DS  UniverseSlotListSize
 294+ 854F 04           ConsoleRefreshCounter   DB  ConsoleRefreshInterval ; Every 4 interations the console will update twice (once for primary and once for seconday buffer)
 295+ 8550 00           ConsoleRedrawFlag       DB  0
 296+ 8551 00           TextInputMode           DB  0
 297+ 8552 00           CursorKeysPressed       DB  0               ; mapping of the current key presses
 298+ 8553                                                          ; 7    6    5    4     3    2        1    0
 299+ 8553                                                          ; Up   Down Left Right Home Recentre
 300+ 8553 00           FireLaserPressed        DB  0
 301+ 8554              ; --- Current System Data ------------------;
 302+ 8554 00           SpaceStationSafeZone    DB  0               ; Flag to determine if we are in safe zone
 303+ 8555 00           ExtraVesselsCounter     DB  0
 304+ 8556 00           JunkCount				DB  0				; $033E
 305+ 8557 00           AsteroidCount           DB  0               ; Not used as yet
 306+ 8558 00           TransporterCount        DB  0
 307+ 8559 00           CopCount                DB  0
 308+ 855A 00           PirateCount             DB  0
 309+ 855B              ; --- Galaxy Data --------------------------;
 310+ 855B 00           Galaxy      			DB	0				; 0367 Galaxy (incremented with galactiv drive
 311+ 855C 00 00 00...  WorkingSeeds			DS	6
 312+ 8562 00 00 00...  PresentSystemSeeds		DS	6				; 03B2 - 03B7
 313+ 8568 00 00 00...  GalaxySeeds				DS	6				; 035B - 0360 QQ21
 314+ 856E 00           PresentSystemX			DB	0				; System we are currently in
 315+ 856F 00           PresentSystemY			DB  0				; System we are currently in
 316+ 8570 00           TargetSystemX			DB	0				; System we are targeting for jump
 317+ 8571 00           TargetSystemY			DB	0				; System we are targeting for jump
 318+ 8572 00           GovPresentSystem		DB	0				; 03AE Govenment
 319+ 8573 00           TekPresentSystem		DB	0				; 03AF Technology
 320+ 8574
 321+ 8574 00           CompassColor			DB	0				; 03C5
 322+ 8575 00           SoundToggle				DB	0				; 03C6
 323+ 8576 00           KeyboardRecenterToggle	DB	0				; 03C8
 324+ 8577 00           PATGMask				DB	0				; &03C9    \ PATG	\ Mask to scan keyboard X-key, for misjump
 325+ 8578 00           FlashToggle				DB  0				; 03CA \ FLH \ flash toggle
 326+ 8579 00           ReverseJoystick			DB	0				; 03CB \ JSTGY \ Y reverse joystick Y channel
 327+ 857A 00           JoystickToggle			DB	0				; 03CD  \ JSTK    \ K toggle keyboard/joystick
 328+ 857B 00           DigitalJoystick			DB	0				; 03CE \ JDB   \ . = toggle between keyboard and bitpaddle
 329+ 857C 00           DiskReadFailFlag		DB	0				; 03CF \ CATF \ Disk catalog fail flag
 330+ 857D
 331+ 857D              ; Working Data
 332+ 857D
 333+ 857D              ;UniverseTable			DS	26				; 1741  \ address pointers for 13 ships INF on pages &9. 37 bytes each.
 334+ 857D              ; $0900 =	EQUW page9+37* 0 \ copied to inner worskpace INWK on zero-page when needed
 335+ 857D              ; $0925 =	EQUW page9+37* 1
 336+ 857D              ; $094A =	EQUW page9+37* 2
 337+ 857D              ; $096F =	EQUW page9+37* 3
 338+ 857D              ; $0994 =	EQUW page9+37* 4
 339+ 857D              ; $09B9 =	EQUW page9+37* 5
 340+ 857D              ; $09DE =	EQUW page9+37* 6
 341+ 857D              ; $0A03 =	EQUW page9+37* 7
 342+ 857D              ; $0A28 =	EQUW page9+37* 8
 343+ 857D              ; $0A4D =	EQUW page9+37* 9
 344+ 857D              ; $0A72 =	EQUW page9+37*10
 345+ 857D              ; $0A97 =	EQUW page9+37*11
 346+ 857D              ; $0ABC =	EQUW page9+37*12 \ allwk up to &0ABC while heap for edges working down from &CFF.
 347+ 857D
 348+ 857D
 349+ 857D
 350+ 857D              ; 0b00 is start address of data to save
 351+ 857D              ; Now MissionData VarTP					DB	0				; 0358 TP? The Plan  \ mission uses lower 4 bits
 352+ 857D              											; Bit mask XXXX10XX - Thargoid plan mission
 353+ 857D
 354+ 857D 00           MissionData				DB	0				; &0B00	  \ look at data, first byte is TP mission bits
 355+ 857E
 356+ 857E 00 00        FileNameStringPointer	DW	0				;0C00	   \ pointer to filename string
 357+ 8580 00 00        CommanderLoadAddress	DW	0				;0C03
 358+ 8582 00 00        LengthOfFile			DW	0				;0C0B
 359+ 8584 00 00        SaveDataEndAddress		DW	0				;&0C0F	      \ &0C00 is end address of data to save
 360+ 8586
 361+ 8586 00 00 00...  EdgesBuffer				DS 50
 362+ 85B8              EdgesBufferSP			equ	$				; Was $0CFF			; Heap pointer for edges buffer
 363+ 85B8              ShipLinesBufferSP		equ EdgesBufferSP	; was $0CFF
 364+ 85B8
 365+ 85B8 00 00 00...  ShipLineStack			DS  70			; For now but will be in the page later
 366+ 85FE              ShipLineStackTop		equ $ - ShipLineStack
 367+ 85FE
 368+ 85FE 00 00 00...  LSO						DS 	$C0				;0E00 Line Buffer Solar of 192 lines (may be 191 in reality)
 369+ 86BE              ; LSX vector overlaps with LSO
 370+ 86BE 00           LSX2					DB	0				; &0EC0	    \ LSX2 bline buffer size?
 371+ 86BF 00           LSY2					DB	0           	; &0F0E	    \ LSY2
 372+ 86C0
 373+ 86C0              ; Star Positions are 16 bit 3d coordinates
 374+ 86C0 00 00 00...  varDust                 DS  MaxNumberOfStars * 6
 375+ 8702 00 00 00...  varDustSceen            DS  MaxNumberOfStars * 2 ; To optimise star list to wipe from screen
 376+ 8718 00           varStarX                DB  0
 377+ 8719 00           varStarY                DB  0
 378+ 871A 00 00 00...  varDustX                DS MaxNumberOfStars *2
 379+ 8730 00 00 00...  varDustY                DS MaxNumberOfStars *2
 380+ 8746 00 00 00...  varDustZ                DS MaxNumberOfStars *2
 381+ 875C              ; -- Player Runtime Data
 382+ 875C 00           GunTemperature          DB  0
 383+ 875D 00           CabinTemperature        DB  0
 384+ 875E 00           PlayerForwardSheild0	DB	0 ; ?????
 385+ 875F 00           PlayerForwardSheild1    DB	0
 386+ 8760 00           PlayerForwardSheild2    DB	0
 387+ 8761 00           ForeShield				DB	0				; 03A5
 388+ 8762 00           AftShield				DB	0				; 03A6
 389+ 8763 00           PlayerEnergy			DB	0				; 03A7
 390+ 8764 00           CompassX				DB	0				; 03A8
 391+ 8765 00           CompassY				DB	0				; 03A9
 392+ 8766 00           MissileTarget			DB  0				; 45
 393+ 8767 00           MissileLaunchFlag       DB  0
 394+ 8768 00 00 00...  CommanderName           DS  15
 395+ 8777 00           CommanderName0			DB	0				; Sneaky little 0 to allow use of print name directly
 396+ 8778 00           BadnessStatus           DB  0
 397+ 8779              ; need to add copy table routines
 398+ 8779 00           CurrLaserType           DB  0               ; current view laser type, copied in from LaserType array
 399+ 877A 00           CurrLaserDamage         DB  0               ; copied in from LaserDamagedFlag array
 400+ 877B 00           CurrLaserPulseRate      DB  0               ; current view laser amount of pulses
 401+ 877C 00           CurrLaserPulseOnTime    DB  0               ; how many cycles the laser is on
 402+ 877D 00           CurrLaserPulseOffTime   DB  0               ; how many cycles the laser is on
 403+ 877E 00           CurrLaserPulseRest      DB  0               ; current view laser delay setup between pulses
 404+ 877F              ; Count down timers must be aligned like this to work
 405+ 877F 00           CurrLaserPulseOnCount   DB  0               ; how many cycles the laser is on timer
 406+ 8780 00           CurrLaserPulseOffCount  DB  0               ; how many cycles the laser is on timer
 407+ 8781 00           CurrLaserPulseRestCount DB  0               ; countdown after shooting for next shot
 408+ 8782 00           CurrLaserPulseRateCount DB  0               ; current view laser current pulses fired
 409+ 8783              ;note rapidly changing views could reset these so need to consider it in an array
 410+ 8783
 411+ 8783              ; LaserType
 412+ 8783              ; LaserPulseRate                          ; how many pulses can be fired before long pause
 413+ 8783              ; LaserPulsePause                         ; time before next pulse - 0 = beam
 414+ 8783              ; LaserPulseRest                          ; time before pulse count resets to 0
 415+ 8783              ; LaserDamageOutput                       ; amount of damage for a laser hit
 416+ 8783              ; LaserEnergyDrain                        ; amount of energy drained by cycle
 417+ 8783              ; LaserHeat                               ; amount of heat generated
 418+ 8783              ; LaserDurability                         ; probabability out of 255 that a hit on unshielded will add random amount of damage
 419+ 8783              ; LaserDurabilityAmount                   ; max amount of damagage can be sustained in one damage hit
 420+ 8783              ; LaserInMarkets                          ; can this laser be purchased 0 = yes 1 = no
 421+ 8783              ; LaserTechLevel                          ; minimum tech level system to buy from
 422+ 8783
 423+ 8783 00           CurrLaserBurstRate      DB  0
 424+ 8784 00           CurrLaserBurstCount     DB  0
 425+ 8785 00           CurrLaserDamageOutput   DB  0
 426+ 8786 00           CurrLaserEnergyDrain    DB  0
 427+ 8787 00           CurrLaserHeat           DB  0
 428+ 8788 00           CurrLaserDurability     DB  0
 429+ 8789 00           CurrLaserDurabilityAmount DB  0
 430+ 878A
 431+ 878A              ; -- Input variables
 432+ 878A 00           JoystickX				DB	0				; 034C JSTX
 433+ 878B 00           JoystickY				DB	0				; 034D JSTY
 434+ 878C 00           XSAV2 					DB	0				; 034E used to temporary save 6502 X reg
 435+ 878D 00           YSAV2 					DB	0				; 034F used to temporary save 6502 Y reg
 436+ 878E
 437+ 878E              ; -- Console drawing data
 438+ 878E              FShieldStart            equ $8410
 439+ 878E              AShieldStart            equ $8D10
 440+ 878E              FuelStart               equ $9410
 441+ 878E
 442+ 878E              EnergyBar4Start         equ $A5D5
 443+ 878E              EnergyBar3Start         equ $ADD5
 444+ 878E              EnergyBar2Start         equ $B5D5
 445+ 878E              EnergyBar1Start         equ $BDD5
 446+ 878E              ; 70 /2 = 35 values
 447+ 878E              ;                            0                             1                             2                             3
 448+ 878E              ;                            0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6
 449+ 878E 01 02 02 03  FuelMapping             DB  01,02,02,03,04,04,05,06,06,07,08,09,10,10,11,12,13,14,14,15,16,16,17,19,20,21,21,22,23,24,25,26,27,28,30,31,31
 449+ 8792 04 04 05 06
 449+ 8796 06 07 08 09
 449+ 879A 0A 0A 0B 0C
 449+ 879E 0D 0E 0E 0F
 449+ 87A2 10 10 11 13
 449+ 87A6 14 15 15 16
 449+ 87AA 17 18 19 1A
 449+ 87AE 1B 1C 1E 1F
 449+ 87B2 1F
 450+ 87B3              SpeedoStart             equ $84D1
 451+ 87B3              ;                            0                             1                             2                             3                             4
 452+ 87B3              ;                            0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  0
 453+ 87B3 01 02 02 03  SpeedoMapping           DB  01,02,02,03,04,04,05,06,06,07,08,09,10,10,11,12,13,14,14,15,16,16,17,18,19,20,20,21,22,23,24,24,25,26,26,27,28,28,29,30,31
 453+ 87B7 04 04 05 06
 453+ 87BB 06 07 08 09
 453+ 87BF 0A 0A 0B 0C
 453+ 87C3 0D 0E 0E 0F
 453+ 87C7 10 10 11 12
 453+ 87CB 13 14 14 15
 453+ 87CF 16 17 18 18
 453+ 87D3 19 1A 1A 1B
 453+ 87D7 1C 1C 1D 1E
 453+ 87DB 1F
 454+ 87DC
 455+ 87DC              DialMiddleXPos          equ $E1
 456+ 87DC              RollMiddle              equ $8CE0
 457+ 87DC              PitchMiddle             equ $94E0
 458+ 87DC
 459+ 87DC
 460+ 87DC
 461+ 87DC
 462+ 87DC
# file closed: ./Variables/general_variables.asm
 120  87DC                  INCLUDE "./Variables/UniverseSlotRoutines.asm"
# file opened: ./Variables/UniverseSlotRoutines.asm
   1+ 87DC AF           ClearSlotCount:         xor     a
   2+ 87DD 21 37 85                             ld      hl,UniverseSlotList
   3+ 87E0 06 0C                                ld      b, UniverseSlotListSize ; prbably not needed + UniverseSlotTypeSize
   4+ 87E2 77           .fillLoop:              ld      (hl),a
   5+ 87E3 23                                   inc     hl
   6+ 87E4 10 FC                                djnz    .fillLoop
   7+ 87E6 C9                                   ret
   8+ 87E7
   9+ 87E7              ; Initialises all types to a count of 1 where there is an occupied universe slot
  10+ 87E7              ; this needs expanding to cater for a missing type, find type and increment count (use cpir?)
  11+ 87E7              ; DOE NOT WORK CorrectSlotCount:       call    ClearSlotCount
  12+ 87E7              ; DOE NOT WORK                         ld      hl,UniverseSlotCount
  13+ 87E7              ; DOE NOT WORK                         ld      de,UniverseSlotList
  14+ 87E7              ; DOE NOT WORK                         ld      b,UniverseSlotListSize
  15+ 87E7              ; DOE NOT WORK .fillLoop:              ld      a,(de)
  16+ 87E7              ; DOE NOT WORK                         cp      $FF
  17+ 87E7              ; DOE NOT WORK                         jr      z,.SkipSlot
  18+ 87E7              ; DOE NOT WORK .CorrectSlot:           ld      (hl),a
  19+ 87E7              ; DOE NOT WORK                         inc     hl
  20+ 87E7              ; DOE NOT WORK                         ld      (hl),1
  21+ 87E7              ; DOE NOT WORK                         inc     hl
  22+ 87E7              ; DOE NOT WORK                         inc     hl
  23+ 87E7              ; DOE NOT WORK .SkipSlot               inc     de
  24+ 87E7              ; DOE NOT WORK                         djnz    .fillLoop
  25+ 87E7 C9                                   ret
  26+ 87E8              ; Wipe all items
  27+ 87E8 3E FF        ClearUnivSlotList:      ld      a,$FF
  28+ 87EA 21 37 85                             ld      hl,UniverseSlotList
  29+ 87ED 06 18                                ld      b, UniverseSlotListSize * 2
  30+ 87EF 77           .fillLoop:              ld      (hl),a
  31+ 87F0 23                                   inc     hl
  32+ 87F1 10 FC                                djnz    .fillLoop
  33+ 87F3 C9                                   ret
  34+ 87F4
  35+ 87F4 21 37 85     SetSlot0ToSpaceStation: ld      hl,UniverseSlotList
  36+ 87F7 36 02                                ld      (hl),ShipTypeStation
  37+ 87F9 21 43 85                             ld      hl,UniverseSlotType
  38+ 87FC 36 02                                ld      (hl),ShipTypeStation
  39+ 87FE C9                                   ret
  40+ 87FF
  41+ 87FF 21 37 85     SetSlotAToTypeB:        ld      hl,UniverseSlotList
  42+ 8802 ED 31                                add     hl,a
  43+ 8804 70                                   ld      (hl),b
  44+ 8805 C9                                   ret
  45+ 8806
  46+ 8806 21 43 85     SetSlotAToClassB:       ld      hl,UniverseSlotType
  47+ 8809 ED 31                                add     hl,a
  48+ 880B 70                                   ld      (hl),b
  49+ 880C C9                                   ret
  50+ 880D
  51+ 880D              ; Clears all except slot A, used when say restarting a space station post launch
  52+ 880D 57           ClearFreeSlotListSaveA: ld      d,a
  53+ 880E 0E 00                                ld      c,0
  54+ 8810 21 37 85                             ld      hl,UniverseSlotList
  55+ 8813 06 18                                ld      b, UniverseSlotListSize * 2
  56+ 8815 79           .fillLoop:              ld      a,c
  57+ 8816 BA                                   cp      d
  58+ 8817 28 03                                jr      z,.SkipSlot
  59+ 8819 3E FF                                ld      a,$FF
  60+ 881B 77                                   ld      (hl),a
  61+ 881C 23           .SkipSlot:              inc     hl
  62+ 881D 23                                   inc     hl
  63+ 881E 10 F5                                djnz    .fillLoop
  64+ 8820 C9                                   ret
  65+ 8821
  66+ 8821 21 37 85     ClearSlotA:             ld      hl,UniverseSlotList
  67+ 8824 ED 31                                add     hl,a
  68+ 8826 36 FF                                ld      (hl),$FF
  69+ 8828 3E 0C                                ld      a,UniverseSlotListSize  ; move to types
  70+ 882A ED 31                                add     hl,a
  71+ 882C 36 FF                                ld      (hl),$FF
  72+ 882E C9                                   ret
  73+ 882F              ; Space Station will always be slot 0
  74+ 882F
  75+ 882F 21 44 85     AreShipsPresent:        ld      hl,UniverseSlotType+1
  76+ 8832 06 0B                                ld      b,UniverseSlotListSize -1      ; ignore space station
  77+ 8834 7E           .NextShip:              ld      a,(hl)
  78+ 8835 FE 00                                cp      ShipTypeNormal
  79+ 8837                                      ClearCarryFlag
  79+ 8837 B7          >                        or a
  80+ 8838 C8                                   ret     z
  81+ 8839 23                                   inc     hl
  82+ 883A 10 F8                                djnz    .NextShip
  83+ 883C                                      SetCarryFlag
  83+ 883C 37          >                        scf
  84+ 883D C9                                   ret
  85+ 883E
  86+ 883E 21 37 85     IsSpaceStationPresent:  ld      hl,UniverseSlotList
  87+ 8841                                      ClearCarryFlag
  87+ 8841 B7          >                        or a
  88+ 8842 7E           .SearchLoop:            ld      a,(hl)
  89+ 8843                                      ReturnIfAEqNusng ShipTypeStation
  89+ 8843 FE 02       >                        cp      ShipTypeStation
  89+ 8845 C8          >                        ret     z
  90+ 8846                                      SetCarryFlag
  90+ 8846 37          >                        scf
  91+ 8847 C9                                   ret
  92+ 8848
  93+ 8848 21 37 85     GetTypeAtSlotA:         ld      hl,UniverseSlotList
  94+ 884B ED 31                                add     hl,a
  95+ 884D 7E                                   ld      a,(hl)
  96+ 884E C9                                   ret
  97+ 884F
  98+ 884F 21 38 85     IsPlanetOrSpaceStation: ld      hl,UniverseSlotList+1
  99+ 8852 7E                                   ld      a,(hl)
 100+ 8853 C9                                   ret
 101+ 8854
 102+ 8854 21 37 85     FindNextFreeSlotInC:    ld      hl,UniverseSlotList
 103+ 8857 06 0C                                ld      b, UniverseSlotListSize
 104+ 8859 0E 00                                ld      c, 0
 105+ 885B 7E           .SearchLoop:            ld      a,(hl)
 106+ 885C                                      JumpIfAEqNusng $FF, .FoundSlot
 106+ 885C FE FF       >                        cp     $FF
 106+ 885E CA 67 88    >                        jp      z,.FoundSlot
 107+ 8861 0C                                   inc     c
 108+ 8862 23                                   inc     hl
 109+ 8863 10 F6                                djnz    .SearchLoop
 110+ 8865                                      SetCarryFlag
 110+ 8865 37          >                        scf
 111+ 8866 C9                                   ret
 112+ 8867              .FoundSlot:             ClearCarryFlag
 112+ 8867 B7          >                        or a
 113+ 8868 C9                                   ret
 114+ 8869
 115+ 8869
 116+ 8869 CD 54 88     FindNextFreeSlotInA:    call    FindNextFreeSlotInC
 117+ 886C 79                                   ld      a,c
 118+ 886D C9                                   ret
 119+ 886E
# file closed: ./Variables/UniverseSlotRoutines.asm
 121  886E                  INCLUDE "./Variables/EquipmentVariables.asm"
# file opened: ./Variables/EquipmentVariables.asm
   1+ 886E 00           AutoDocking				DB	0				; $033F
   2+ 886F 00           PlayerECM				DB	0				; $0340
   3+ 8870 00           Laser2					DB	0				; 0343 laser Power? Not sure
   4+ 8871 00           LaserCount				DB	0				; 0346  LASCT  \ laser count =9 for pulse, cooled off?
   5+ 8872 00 00 00 00  Cash					DB  0,0,0,0			; 0361 - 0364 Cash now litte endian
   6+ 8876 19           Fuel					DB	25				; 0365  QQ14
   7+ 8877 46           CargoBaySize			DB	70				; 036E
   8+ 8878 00           CargoRunningLoad        DB  0
   9+ 8879 00 00 00 00  CargoTonnes             DB  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
   9+ 887D 00 00 00 00
   9+ 8881 00 00 00 00
   9+ 8885 00 00 00 00
  10+ 8889              ;CargoTonnes		    DB	16,1,2,3,4,5,6,7,6,9,10,11,12,13,14,15			; 036F - 037F	QQ20
  11+ 8889              SlaveCargoTonnes		equ CargoTonnes+3
  12+ 8889              NarcoticsCargoTonnes	equ CargoTonnes+6
  13+ 8889              FirearmsCargoTonnes		equ CargoTonnes+10
  14+ 8889              ; For each view laser a localised copy of the stats
  15+ 8889              ; TODO - need to add code to maintain on load/save/equipment transactions
  16+ 8889 00 00 00 00  LaserType               DS  4               ; quick reference to laser type
  17+ 888D 00 00 00 00  LaserDamagedFlag        DS  4               ; probabiliy out of 255 that it will no fire, 0 = good, 255 = will not fire
  18+ 8891              ; dont need as static from table LaserPulseRate          DS  4               ; how many pulses can be fired before long pause
  19+ 8891              ; dont need as static from table LaserPulsePause         DS  4               ; time before next pulse - 0 = beam
  20+ 8891              ; dont need as static from table LaserPulseRest          DS  4               ; time before pulse count resets to 0
  21+ 8891              ; dont need as static from table LaserDamageOutput       DS  4               ; amount of damage for a laser hit
  22+ 8891              ; dont need as static from table LaserEnergyDrain        DS  4               ; amount of energy drained by cycle
  23+ 8891              ; dont need as static from table LaserHeat               DS  4               ; amount of heat generated
  24+ 8891              ; dont need as static from table LaserDurability         DS  4               ; probabability out of 255 that a hit on it unshielded will add random amount of damage
  25+ 8891              ; dont need as static from table LaserDurabilityAmount   DS  4               ; max amount of damagage can be sustained in one damage hit
  26+ 8891
  27+ 8891
  28+ 8891              QQ20                    equ CargoTonnes
  29+ 8891 00 00 00...  EquipmentFitted         DS  EQ_ITEM_COUNT    ; Series of flags for if each item is fitted
  30+ 88AB              ECMPresent				EQU EquipmentFitted + EQ_ECM				; 0380
  31+ 88AB              EnergyBomb				EQU EquipmentFitted + EQ_ENERGY_BOMB		; 0382	Also random hyperspeace in Elite A
  32+ 88AB              ExtraEnergyUnit			EQU EquipmentFitted + EQ_ENERGY_UNIT        ; 0383
  33+ 88AB              DockingComputer 		EQU EquipmentFitted + EQ_DOCK_COMP    		; 0384
  34+ 88AB              GalacticHyperDrive		EQU EquipmentFitted + EQ_GAL_DRIVE   		; 0385
  35+ 88AB              EscapePod				EQU EquipmentFitted + EQ_ESCAPE_POD  		; 0386
  36+ 88AB 01           FuelScoopsBarrelStatus	DB	1				; 0381
  37+ 88AC
# file closed: ./Variables/EquipmentVariables.asm
 122  88AC                  INCLUDE "./Variables/random_number.asm"
# file opened: ./Variables/random_number.asm
   1+ 88AC              doRandom2:									; .DORND2	\ -> &3F85 \ Restricted for explosion dust.
   2+ 88AC              doRND2:
   3+ 88AC A7           	and		a								; fast clear carry  leave bit0 of RAND+2 at 0.
   4+ 88AD              doRandom:									;.DORND	\ -> &3F86 \ do random, new A, X.
   5+ 88AD              ; "doRandom, Random Seed update, new value in A & B)"
   6+ 88AD 3A 5C 83     doRND:                  ld		a,(RandomSeed)					; Get Seed 0
   7+ 88B0 CB 17                                rl		a								; Rotate L including carry
   8+ 88B2 4F                                   ld		c,a								; c =  double lo
   9+ 88B3 21 5E 83     .AddSeed2:              ld		hl,RandomSeed2
  10+ 88B6 8E                                   adc		a,(hl)							; RAND+2
  11+ 88B7 32 5C 83     .SaveAtoSeed:           ld		(RandomSeed),a					; and save RAND
  12+ 88BA 08           .SaveBtoSeed2:          ex		af,af'
  13+ 88BB 79                                   ld		a,c
  14+ 88BC 32 5E 83                             ld		(RandomSeed2),a
  15+ 88BF 08                                   ex		af,af'
  16+ 88C0 3A 5D 83                             ld		a,(RandomSeed1)
  17+ 88C3 4F                                   ld		c,a								; C = Seed1
  18+ 88C4 21 5F 83     .AddSeed3:              ld		hl,RandomSeed3
  19+ 88C7 8E                                   adc		a,(hl)
  20+ 88C8 32 5D 83                             ld		(RandomSeed1),a
  21+ 88CB 08                                   ex		af,af'
  22+ 88CC 79                                   ld		a,c
  23+ 88CD 32 5F 83                             ld		(RandomSeed3),a
  24+ 88D0 08                                   ex		af,af'
  25+ 88D1 C9                                   ret
  26+ 88D2
# file closed: ./Variables/random_number.asm
 123  88D2                  INCLUDE "./Variables/galaxy_seed.asm"
# file opened: ./Variables/galaxy_seed.asm
   1+ 88D2 47 41 4C 41  GALAXYSEED DB "GALAXYSEED"
   1+ 88D6 58 59 53 45
   1+ 88DA 45 44
   2+ 88DC 21 68 85     copy_galaxy_to_system:  ld		hl,GalaxySeeds
   3+ 88DF 11 52 84                             ld		de,SystemSeed
   4+ 88E2 ED A0        copy_seed:		        ldi
   5+ 88E4 ED A0                                ldi
   6+ 88E6 ED A0                                ldi
   7+ 88E8 ED A0                                ldi
   8+ 88EA ED A0                                ldi
   9+ 88EC ED A0                                ldi
  10+ 88EE C9                                   ret
  11+ 88EF
  12+ 88EF 21 52 84     copy_system_to_galaxy:  ld		hl,SystemSeed
  13+ 88F2 11 68 85                             ld		de,GalaxySeeds
  14+ 88F5 18 EB                                jr		copy_seed
  15+ 88F7
  16+ 88F7 21 68 85     copy_galaxy_to_working: ld		hl,GalaxySeeds
  17+ 88FA 11 5C 85                             ld		de,WorkingSeeds
  18+ 88FD 18 E3                                jr		copy_seed
  19+ 88FF
  20+ 88FF 21 5C 85     copy_working_to_galaxy: ld		hl,WorkingSeeds
  21+ 8902 11 68 85                             ld		de,GalaxySeeds
  22+ 8905 18 DB                                jr		copy_seed
  23+ 8907
  24+ 8907 21 5C 85     copy_working_to_system: ld		hl,WorkingSeeds
  25+ 890A 11 52 84                             ld		de,SystemSeed
  26+ 890D 18 D3                                jr		copy_seed
  27+ 890F
  28+ 890F 21 52 84     copy_system_to_working: ld		hl,SystemSeed
  29+ 8912 11 5C 85                             ld		de,WorkingSeeds
  30+ 8915 18 CB                                jr		copy_seed
  31+ 8917
  32+ 8917              next_system_seed:							;.TT20	\ -> &2B0E  \ TWIST on QQ15 to next system
  33+ 8917 CD 1A 89     		call	.NextStep					; This logic means we hard code x4
  34+ 891A              .NextStep:
  35+ 891A CD 1D 89     		call	process_seed				; This logic means we hard code x2
  36+ 891D              process_seed:								; TT54	\ -> &2637 \ Twist seed for next digram in QQ15
  37+ 891D 3A 52 84     		ld		a,(SystemSeed)				; QQ15
  38+ 8920 B7           		or		a							; clear carry flag
  39+ 8921 21 54 84     		ld		hl,SystemSeed+2				; hl -> qq+2
  40+ 8924 86           		add		a,(hl)						; a= QQ15 + QQ152
  41+ 8925 47           		ld		b,a							; partial sum lo
  42+ 8926 3A 53 84     		ld		a,(SystemSeed+1)
  43+ 8929 21 55 84     		ld		hl,SystemSeed+3				; HL -> QQ+3 )we don't inc as it affects carry)
  44+ 892C 8E           		adc		a,(hl)						; note add with carry
  45+ 892D 4F           		ld		c,a  						; c = QQ1+QQ3+carry bit parial sum hi
  46+ 892E 3A 54 84     		ld		a,(SystemSeed+2)
  47+ 8931 32 52 84     		ld		(SystemSeed+0),a			; copy qq152 to qq150
  48+ 8934 3A 55 84     		ld		a,(SystemSeed+3)
  49+ 8937 32 53 84     		ld		(SystemSeed+1),a			; copy qq153 to qq151
  50+ 893A 3A 57 84     		ld		a,(SystemSeed+5)
  51+ 893D 32 55 84     		ld		(SystemSeed+3),a			; copy qq155 to qq153
  52+ 8940 3A 56 84     		ld		a,(SystemSeed+4)
  53+ 8943 32 54 84     		ld		(SystemSeed+2),a			; copy qq154 to qq152
  54+ 8946 B7           		or		a
  55+ 8947 78           		ld		a,b
  56+ 8948 21 54 84     		ld		hl,SystemSeed+2				; hl -> qq+2
  57+ 894B 86           		add	    a,(hl)
  58+ 894C 32 56 84     		ld		(SystemSeed+4),a
  59+ 894F 79           		ld		a,c
  60+ 8950 21 55 84     		ld		hl,SystemSeed+3				; HL -> QQ+3 )we don't inc as it affects carry)
  61+ 8953 8E           		adc		a,(hl)
  62+ 8954 32 57 84     		ld		(SystemSeed+5),a
  63+ 8957 C9           		ret
  64+ 8958
  65+ 8958              next_working_seed:							;.TT20	\ -> &2B0E  \ TWIST on QQ15 to next system
  66+ 8958 CD 5B 89     		call	.NextStep					; This logic means we hard code x4
  67+ 895B              .NextStep:
  68+ 895B CD 5E 89     		call	working_seed				; This logic means we hard code x2
  69+ 895E              working_seed:								; TT54	\ -> &2637 \ Twist seed for next digram in QQ15
  70+ 895E              ; x = a + c
  71+ 895E 3A 5C 85     		ld		a,(WorkingSeeds)			; QQ15
  72+ 8961 B7           		or		a							; clear carry flag
  73+ 8962 21 5E 85     		ld		hl,WorkingSeeds+2			; hl -> qq+2 [c]
  74+ 8965 86           		add		a,(hl)						; a= QQ15 [a]+ QQ15 [c]
  75+ 8966 47           		ld		b,a							; partial sum lo [x]
  76+ 8967              ; y = b + d	+ carry
  77+ 8967 3A 5D 85     		ld		a,(WorkingSeeds+1)          ; [b]
  78+ 896A 21 5F 85     		ld		hl,WorkingSeeds+3			; HL -> QQ+3 [d] we don't inc as it affects carry)
  79+ 896D 8E           		adc		a,(hl)						; note add with carry
  80+ 896E 4F           		ld		c,a  						; c = QQ1+QQ3+carry bit parial sum hi
  81+ 896F 3A 5E 85     		ld		a,(WorkingSeeds+2)
  82+ 8972 32 5C 85     		ld		(WorkingSeeds+0),a			; copy qq152 to qq150 [a] = [c]
  83+ 8975 3A 5F 85     		ld		a,(WorkingSeeds+3)
  84+ 8978 32 5D 85     		ld		(WorkingSeeds+1),a			; copy qq153 to qq151 [b] = [d]
  85+ 897B 3A 61 85     		ld		a,(WorkingSeeds+5)
  86+ 897E 32 5F 85     		ld		(WorkingSeeds+3),a			; copy qq155 to qq153 [d] = [f]
  87+ 8981 3A 60 85     		ld		a,(WorkingSeeds+4)
  88+ 8984 32 5E 85     		ld		(WorkingSeeds+2),a			; copy qq154 to qq152 [c] = [e]
  89+ 8987 B7           		or		a
  90+ 8988 78           		ld		a,b
  91+ 8989 21 5E 85     		ld		hl,WorkingSeeds+2		    ; hl -> qq+2
  92+ 898C 86           		add	    a,(hl)
  93+ 898D 32 60 85     		ld		(WorkingSeeds+4),a			; e = x + [c]
  94+ 8990 79           		ld		a,c
  95+ 8991 21 5F 85     		ld		hl,WorkingSeeds+3			; HL -> QQ+3 )we don't inc as it affects carry)
  96+ 8994 8E           		adc		a,(hl)
  97+ 8995 32 61 85     		ld		(WorkingSeeds+5),a			; f = y + [d] + carry
  98+ 8998 C9           		ret
  99+ 8999
 100+ 8999 32           working_distX	DB 50
 101+ 899A 32           working_distY	DB 50
 102+ 899B 00           current_distY	DB 0
 103+ 899C
 104+ 899C AF           find_present_system:    xor		a
 105+ 899D 32 6B 84                             ld		(XSAV),a
 106+ 89A0 3A 53 84     .CounterLoop:           ld		a,(SystemSeed+1)				; QQ15+1 \ seed Ycoord of star
 107+ 89A3 4F                                   ld		c,a
 108+ 89A4 3A 6F 85     .calcLocaldy:           ld		a,(PresentSystemY)
 109+ 89A7 47                                   ld		b,a								; so b holds Y ccord
 110+ 89A8 79                                   ld		a,c
 111+ 89A9 90                                   sub		b
 112+ 89AA CB 7F                                bit		7,a
 113+ 89AC 28 02                                jr		z,.positivedy
 114+ 89AE ED 44        .negativedy:            neg
 115+ 89B0 32 9B 89     .positivedy:            ld		(current_distY),a				; save cuirrent_dist Y as we need it maybe
 116+ 89B3 ED 5B 99 89                          ld		de,(working_distX)
 117+ 89B7 BA                                   cp		d
 118+ 89B8 30 24                                jr		nc,.toofar
 119+ 89BA 3A 55 84     .calcLocaldx:           ld		a,(SystemSeed+3)				; QQ15+3 \ seed Xcoord of star
 120+ 89BD 4F                                   ld		c,a
 121+ 89BE 3A 6E 85                             ld		a,(PresentSystemX)
 122+ 89C1 47                                   ld		b,a								; so b holds Y ccord
 123+ 89C2 79                                   ld		a,c
 124+ 89C3 90                                   sub		b
 125+ 89C4 CB 7F                                bit		7,a
 126+ 89C6 28 02                                jr		z,.positivedx
 127+ 89C8 ED 44        .negativedx:            neg
 128+ 89CA 4F           .positivedx:            ld		c,a
 129+ 89CB BB                                   cp		e
 130+ 89CC 30 10                                jr		nc,.toofar
 131+ 89CE 3A 9B 89     .Nearer:			    ld		a,(current_distY) 				; we have a closer system
 132+ 89D1 47                                   ld		b,a								; we have c to recall Y into b
 133+ 89D2 ED 43 99 89                          ld		(working_distX),bc
 134+ 89D6 C5                                   push	bc
 135+ 89D7 CD 0F 89                             call 	copy_system_to_working
 136+ 89DA C1                                   pop		bc
 137+ 89DB 78                                   ld		a,b								;
 138+ 89DC B1                                   or		c								;
 139+ 89DD C8                                   ret		z								; if we have distance 0 then bang on
 140+ 89DE CD 17 89     .toofar:                call	next_system_seed
 141+ 89E1 3A 6B 84                             ld		a,(XSAV)
 142+ 89E4 3D                                   dec		a
 143+ 89E5 FE 00                                cp		0
 144+ 89E7 C8                                   ret		z
 145+ 89E8 32 6B 84                             ld		(XSAV),a
 146+ 89EB 18 B3                                jr		.CounterLoop
 147+ 89ED
 148+ 89ED              get_planet_data_working_seed:
 149+ 89ED 3A 5D 85     		ld		a, (WorkingSeeds+1)
 150+ 89F0 E6 07        		and		7
 151+ 89F2 32 F0 84     		ld		(DisplayEcononmy),a
 152+ 89F5 3A 5E 85     		ld		a, (WorkingSeeds+2)
 153+ 89F8 CB 3F        		srl	a
 154+ 89FA CB 3F        		srl	a
 155+ 89FC CB 3F        		srl	a
 156+ 89FE CB 3F        		srl	a								; c/8
 157+ 8A00 E6 07        		and		7
 158+ 8A02 32 F1 84     		ld		(DisplayGovernment),a
 159+ 8A05 CB 3F        		srl	a
 160+ 8A07 FE 00        		cp		0
 161+ 8A09 20 08        		jr		nz,.CanBeRich
 162+ 8A0B              .Fedual:
 163+ 8A0B 3A F0 84     		ld		a,(DisplayEcononmy)
 164+ 8A0E F6 02        		or		2							; Adjust Eco for Anarchy and Feudal, set bit 1.
 165+ 8A10 32 F0 84     		ld		(DisplayEcononmy),a
 166+ 8A13              .CanBeRich:
 167+ 8A13 3A F0 84     		ld		a,(DisplayEcononmy)
 168+ 8A16 EE 07        		xor		7							; flip economy so Rich is now 7
 169+ 8A18 32 F2 84     		ld		(DisplayTekLevel),a			; Flipped Eco, EcoEOR7, Rich Ind = 7
 170+ 8A1B 47           		ld		b,a
 171+ 8A1C 3A 5F 85     		ld		a,(WorkingSeeds+3)
 172+ 8A1F E6 03        		and		3
 173+ 8A21 80           		add		a,b
 174+ 8A22 32 F2 84     		ld		(DisplayTekLevel),a			; Tek Level += seed d & 3
 175+ 8A25 3A F1 84     		ld		a,(DisplayGovernment)		; Government, 0 is Anarchy
 176+ 8A28 CB 3F        		srl		a 							; gov/2
 177+ 8A2A 47           		ld		b,a
 178+ 8A2B 3A F2 84     		ld		a,(DisplayTekLevel)
 179+ 8A2E 80           		add		a,b
 180+ 8A2F 32 F2 84     		ld		(DisplayTekLevel),a			; Tek += gov /2
 181+ 8A32 CB 27        		sla		a
 182+ 8A34 CB 27        		sla		a							; Onto Population (TL-1)*= 4
 183+ 8A36 47           		ld		b,a
 184+ 8A37 3A F0 84     		ld		a,(DisplayEcononmy)
 185+ 8A3A 80           		add		a,b                  		; TechLevel*4 + Eco   7-56
 186+ 8A3B 47           		ld		b,a
 187+ 8A3C 3A F1 84     		ld		a,(DisplayGovernment)
 188+ 8A3F 3C           		inc		a  							; +Government, 0 is Anarchy + 1
 189+ 8A40 32 F3 84     		ld		(DisplayPopulation),a
 190+ 8A43 3A F0 84     		ld		a,(DisplayEcononmy)
 191+ 8A46 EE 07        		xor		7							; Onto productivity
 192+ 8A48 C6 03        		add		3							;  (Flipped eco +3)
 193+ 8A4A 57           		ld		d,a
 194+ 8A4B 3A F1 84     		ld		a,(DisplayGovernment)		; Government, 0 is Anarchy
 195+ 8A4E C6 04        		add		4
 196+ 8A50 5F           		ld		e,a
 197+ 8A51 ED 30        		mul									; ; DE = d*e, Productivity part 1. has hsb in A, lsb in P.
 198+ 8A53 3A F3 84     		ld		a,(DisplayPopulation)		; then we use d for radius
 199+ 8A56 57           		ld		d,a
 200+ 8A57 ED 30        		mul
 201+ 8A59 CB 23        		sla		e
 202+ 8A5B CB 1A        		rr		d
 203+ 8A5D CB 23        		sla		e
 204+ 8A5F CB 1A        		rr		d
 205+ 8A61 CB 23        		sla		e
 206+ 8A63 CB 1A        		rr		d							; de * 8
 207+ 8A65 ED 53 F5 84  		ld		(DisplayProductivity),de
 208+ 8A69              .DoRadius:
 209+ 8A69 3A 5F 85     		ld		a,(WorkingSeeds+3)
 210+ 8A6C 4F           		ld		c,a
 211+ 8A6D 3A 61 85     		ld		a,(WorkingSeeds+5)
 212+ 8A70 E6 0F        		and		$0F							;  lower 4 bits of w2_h determine planet radius
 213+ 8A72 C6 0B        		add		11							;  radius min = 256*11 = 2816 km
 214+ 8A74 47           		ld		b,a							;
 215+ 8A75 ED 43 F9 84  		ld		(DisplayRadius),bc
 216+ 8A79 C9           		ret
 217+ 8A7A
# file closed: ./Variables/galaxy_seed.asm
 124  8A7A                  INCLUDE "./Tables/text_tables.asm"
# file opened: ./Tables/text_tables.asm
   1+ 8A7A 50 75 6C 73  StatusLaserName1	DB	"Pulse",0
   1+ 8A7E 65 00
   2+ 8A80 42 65 61 6D  StatusLaserName2	DB	"Beam",0
   2+ 8A84 00
   3+ 8A85 4D 69 6C 69  StatusLaserName3    DB  "Military",0
   3+ 8A89 74 61 72 79
   3+ 8A8D 00
   4+ 8A8E 4D 69 6E 69  StatusLaserName4    DB  "Mining",0
   4+ 8A92 6E 67 00
   5+ 8A95 43 75 73 74  StatusLaserName5    DB  "Custom",0
   5+ 8A99 6F 6D 00
   6+ 8A9C
   7+ 8A9C 7A 8A 80 8A  StatusLaserNameIdx	DW	StatusLaserName1,StatusLaserName2,StatusLaserName3,StatusLaserName4,StatusLaserName5
   7+ 8AA0 85 8A 8E 8A
   7+ 8AA4 95 8A
   8+ 8AA6              StatusLaserNameIdxLen EQU $ - StatusLaserNameIdx
   9+ 8AA6
  10+ 8AA6 44 6F 63 6B  ConditionName1		DB "Docked",0
  10+ 8AAA 65 64 00
  11+ 8AAD 47 72 65 65  ConditionName2		DB "Green",0
  11+ 8AB1 6E 00
  12+ 8AB3 59 65 6C 6C  ConditionName3		DB "Yellow",0
  12+ 8AB7 6F 77 00
  13+ 8ABA 52 65 64 00  ConditionName4		DB "Red",0
  14+ 8ABE
  15+ 8ABE A6 8A AD 8A  ConditionNameIdx	DW ConditionName1,ConditionName2,ConditionName3,ConditionName4
  15+ 8AC2 B3 8A BA 8A
  16+ 8AC6              ConditionNameIdxLen EQU $ - ConditionNameIdx
  17+ 8AC6
  18+ 8AC6 41 42 4F 55  StatusDiagrams		DB "ABOUSEITILETSTONLONUTHNOALLEXEGEZACEBISOUSESARMAINDIREA?ERATENBERALAVETIEDORQUANTEISRION",0
  18+ 8ACA 53 45 49 54
  18+ 8ACE 49 4C 45 54
  18+ 8AD2 53 54 4F 4E
  18+ 8AD6 4C 4F 4E 55
  18+ 8ADA 54 48 4E 4F
  18+ 8ADE 41 4C 4C 45
  18+ 8AE2 58 45 47 45
  18+ 8AE6 5A 41 43 45
  18+ 8AEA 42 49 53 4F
  18+ 8AEE 55 53 45 53
  18+ 8AF2 41 52 4D 41
  18+ 8AF6 49 4E 44 49
  18+ 8AFA 52 45 41 3F
  18+ 8AFE 45 52 41 54
  18+ 8B02 45 4E 42 45
  18+ 8B06 52 41 4C 41
  18+ 8B0A 56 45 54 49
  18+ 8B0E 45 44 4F 52
  18+ 8B12 51 55 41 4E
  18+ 8B16 54 45 49 53
  18+ 8B1A 52 49 4F 4E
  18+ 8B1E 00
  19+ 8B1F
  20+ 8B1F 00 00 08 00  RankingTable		DW	$0000,$0008,$0010,$0020,$0040,$0080,$0200,$0A00,$1900,$4900,$FFFF
  20+ 8B23 10 00 20 00
  20+ 8B27 40 00 80 00
  20+ 8B2B 00 02 00 0A
  20+ 8B2F 00 19 00 49
  20+ 8B33 FF FF
  21+ 8B35
  22+ 8B35 48 61 72 6D  RankingName1		DB 	"Harmless",0
  22+ 8B39 6C 65 73 73
  22+ 8B3D 00
  23+ 8B3E 4D 6F 73 74  RankingName2		DB 	"Mostly Harmless",0
  23+ 8B42 6C 79 20 48
  23+ 8B46 61 72 6D 6C
  23+ 8B4A 65 73 73 00
  24+ 8B4E 50 6F 6F 72  RankingName3		DB 	"Poor",0
  24+ 8B52 00
  25+ 8B53 41 76 65 72  RankingName4		DB 	"Average",0
  25+ 8B57 61 67 65 00
  26+ 8B5B 41 62 6F 76  RankingName5		DB 	"Above Average",0
  26+ 8B5F 65 20 41 76
  26+ 8B63 65 72 61 67
  26+ 8B67 65 00
  27+ 8B69 43 6F 6D 70  RankingName6		DB 	"Competent",0
  27+ 8B6D 65 74 65 6E
  27+ 8B71 74 00
  28+ 8B73 44 61 6E 67  RankingName7		DB 	"Dangerous",0
  28+ 8B77 65 72 6F 75
  28+ 8B7B 73 00
  29+ 8B7D 44 65 61 64  RankingName8		DB 	"Deadly",0
  29+ 8B81 6C 79 00
  30+ 8B84 2D 2D 2D 2D  RankingName9		DB 	"---- E L I T E ---",0
  30+ 8B88 20 45 20 4C
  30+ 8B8C 20 49 20 54
  30+ 8B90 20 45 20 2D
  30+ 8B94 2D 2D 00
  31+ 8B97 53 6B 6F 6C  RankingName10		DB 	"Skollobsgod",0
  31+ 8B9B 6C 6F 62 73
  31+ 8B9F 67 6F 64 00
  32+ 8BA3 4E 75 74 74  RankingName11		DB 	"Nutter",0
  32+ 8BA7 65 72 00
  33+ 8BAA
  34+ 8BAA 35 8B 3E 8B  RankingNameIdx		dw RankingName1,RankingName2,RankingName3,RankingName4,RankingName5,RankingName6,RankingName7,RankingName8,RankingName9,RankingName10,RankingName11
  34+ 8BAE 4E 8B 53 8B
  34+ 8BB2 5B 8B 69 8B
  34+ 8BB6 73 8B 7D 8B
  34+ 8BBA 84 8B 97 8B
  34+ 8BBE A3 8B
  35+ 8BC0              RankingNameIdxLen EQU $ - RankingNameIdx
  36+ 8BC0
  37+ 8BC0
  38+ 8BC0              getTableText:
  39+ 8BC0              ; ">getTableText, hl = indexlist, a = textnbr, returns with hl = porinter to head of text"
  40+ 8BC0              ; ">Note for ranking first 2 bytes are target rank"
  41+ 8BC0 D5           	push	de								; save DE as we will likley need it in caller
  42+ 8BC1 ED 31        	add		hl,a							; 0 based ref, and its 2 bytes
  43+ 8BC3 ED 31        	add		hl,a
  44+ 8BC5 5E           	ld		e,(hl)
  45+ 8BC6 23           	inc		hl
  46+ 8BC7 56           	ld		d,(hl)							; de = indexed address
  47+ 8BC8 EB           	ex		de,hl							; flip it to hl
  48+ 8BC9 D1           	pop		de								; retrieve de
  49+ 8BCA C9           	ret										; return with hl as start entry
  50+ 8BCB
  51+ 8BCB
  52+ 8BCB              ;               CF      ZF      Result
  53+ 8BCB              ;               -----------------------------------
  54+ 8BCB              ;               0       0       HL > DE
  55+ 8BCB              ;               0       1       HL == DE
  56+ 8BCB              ;               1       0       HL < DE
  57+ 8BCB              ;               1       1       Impossible
  58+ 8BCB              getRankIndex:
  59+ 8BCB              ; ">getRank, de = kill count, returns a = index,hl destroyed"
  60+ 8BCB              ; ">Note for ranking first 2 bytes are target rank"
  61+ 8BCB 7A           	ld		a,d
  62+ 8BCC B3           	or		e
  63+ 8BCD FE 00        	cp		0
  64+ 8BCF C8           	ret		z								; quicks skip for 0 kills
  65+ 8BD0 AF           	xor 	a
  66+ 8BD1 21 1F 8B     	ld		hl,RankingTable
  67+ 8BD4              .testLoop:
  68+ 8BD4 4E           	ld		c,(hl)
  69+ 8BD5 23           	inc		hl
  70+ 8BD6 46           	ld		b,(hl)							; bc = ranking
  71+ 8BD7 E5           	push	hl
  72+ 8BD8 60           	ld		h,b
  73+ 8BD9 69           	ld		l,c
  74+ 8BDA CD 55 97     	call	compare16HLDE
  75+ 8BDD 38 06        	jr		c,.HLLTDE
  76+ 8BDF              .HLGTEDE									; Found the correct rank
  77+ 8BDF E1           	pop		hl
  78+ 8BE0 23           	inc		hl								; move to next value
  79+ 8BE1 23           	inc		hl
  80+ 8BE2 3C           	inc		a								; we canloop forever as if kills was $FFFF then hits nutter rank but also +1 = 0000 as its 16 bit
  81+ 8BE3 18 EF        	jr		.testLoop
  82+ 8BE5              .HLLTDE:									; HL < Kills so found correct rank
  83+ 8BE5 E1           	pop		hl
  84+ 8BE6 C9           	ret
  85+ 8BE7
# file closed: ./Tables/text_tables.asm
 125  8BE7                  INCLUDE "./Tables/dictionary.asm"
# file opened: ./Tables/dictionary.asm
   1+ 8BE7 58 00        WordDummy					DB  "X",0
   2+ 8BE9 46 72 6F 6E  WordFront					DB	"Front",0              ;1
   2+ 8BED 74 00
   3+ 8BEF 52 69 67 68  WordRight					DB	"Right",0              ;2
   3+ 8BF3 74 00
   4+ 8BF5 4C 65 66 74  WordLeft 					DB	"Left",0               ;3
   4+ 8BF9 00
   5+ 8BFA 52 65 61 72  WordRear   	 				DB	"Rear",0               ;4
   5+ 8BFE 00
   6+ 8BFF 4C 61 72 67  WordLarge           		DB  "Large",0              ;5
   6+ 8C03 65 00
   7+ 8C05 45 73 63 61  WordEscape          		DB  "Escape",0             ;6
   7+ 8C09 70 65 00
   8+ 8C0C 50 6F 64 00  WordPod             		DB  "Pod",0                ;7
   9+ 8C10 43 61 72 67  WordCargo           		DB  "Cargo",0              ;8
   9+ 8C14 6F 00
  10+ 8C16 42 61 79 00  WordBay             		DB  "Bay",0                ;9
  11+ 8C1A 46 75 65 6C  WordFuel            		DB  "Fuel",0               ;10
  11+ 8C1E 00
  12+ 8C1F 53 63 6F 6F  WordScoops          		DB  "Scoops",0             ;11
  12+ 8C23 70 73 00
  13+ 8C26 45 2E 43 2E  WordECM             		DB  "E.C.M.",0             ;12
  13+ 8C2A 4D 2E 00
  14+ 8C2D 53 79 73 74  WordSystem          		DB  "System",0             ;13
  14+ 8C31 65 6D 00
  15+ 8C34 45 6E 65 72  WordEnergy					DB  "Energy",0             ;14
  15+ 8C38 67 79 00
  16+ 8C3B 42 6F 6D 62  WordBomb					DB  "Bomb",0               ;15
  16+ 8C3F 00
  17+ 8C40 4C 61 73 65  WordLaser					DB  "Laser",0              ;16
  17+ 8C44 72 00
  18+ 8C46 50 75 6C 73  WordPulse           		DB  "Pulse",0              ;17
  18+ 8C4A 65 00
  19+ 8C4C 42 65 61 6D  WordBeam            		DB  "Beam",0               ;18
  19+ 8C50 00
  20+ 8C51 4D 69 6C 69  WordMiliary         		DB  "Miliary",0            ;19
  20+ 8C55 61 72 79 00
  21+ 8C59 4D 69 6E 69  WordMining          		DB  "Mining",0             ;20
  21+ 8C5D 6E 67 00
  22+ 8C60 43 75 73 74  WordCustom          		DB  "Custom",0             ;21
  22+ 8C64 6F 6D 00
  23+ 8C67 55 6E 69 74  WordUnit            		DB  "Unit",0               ;22
  23+ 8C6B 00
  24+ 8C6C 53 68 69 65  WordShield          		DB  "Shield",0             ;23
  24+ 8C70 6C 64 00
  25+ 8C73 44 6F 63 6B  WordDocking         		DB  "Docking",0            ;24
  25+ 8C77 69 6E 67 00
  26+ 8C7B 43 6F 6D 70  WordComputers       		DB  "Computers",0          ;25
  26+ 8C7F 75 74 65 72
  26+ 8C83 73 00
  27+ 8C85 48 79 70 65  WordHyperspace      		DB  "Hyperspace",0         ;26
  27+ 8C89 72 73 70 61
  27+ 8C8D 63 65 00
  28+ 8C90 47 61 6C 61  WordGalactic        		DB  "Galactic",0           ;27
  28+ 8C94 63 74 69 63
  28+ 8C98 00
  29+ 8C99 45 78 74 72  WordExtra           		DB  "Extra",0              ;28
  29+ 8C9D 61 00
  30+ 8C9F 43 6C 65 61  WordClean           		DB  "Clean",0              ;29
  30+ 8CA3 6E 00
  31+ 8CA5 4F 66 66 65  WordOffender        		DB  "Offender",0           ;30
  31+ 8CA9 6E 64 65 72
  31+ 8CAD 00
  32+ 8CAE 46 75 67 69  WordFugitive        		DB  "Fugitive",0           ;31
  32+ 8CB2 74 69 76 65
  32+ 8CB6 00
  33+ 8CB7 46 6F 6F 64  WordFood					DB	"Food",0               ;32
  33+ 8CBB 00
  34+ 8CBC 54 65 78 74  WordTextiles				DB 	"Textiles",0           ;33
  34+ 8CC0 69 6C 65 73
  34+ 8CC4 00
  35+ 8CC5 52 61 64 69  WordRadioactives			DB  "Radioactives",0       ;34
  35+ 8CC9 6F 61 63 74
  35+ 8CCD 69 76 65 73
  35+ 8CD1 00
  36+ 8CD2 53 6C 61 76  WordSlaves					DB  "Slaves",0             ;35
  36+ 8CD6 65 73 00
  37+ 8CD9 4C 69 71 75  WordLiquorWines     		DB  "Liquor/Wines",0       ;36
  37+ 8CDD 6F 72 2F 57
  37+ 8CE1 69 6E 65 73
  37+ 8CE5 00
  38+ 8CE6 4C 75 78 75  WordLuxuries  	    		DB  "Luxuries",0	       ;37
  38+ 8CEA 72 69 65 73
  38+ 8CEE 00
  39+ 8CEF 4E 61 72 63  WordNarcotics  	    		DB  "Narcotics",0	       ;38
  39+ 8CF3 6F 74 69 63
  39+ 8CF7 73 00
  40+ 8CF9 4D 61 63 68  WordMachinery  	    		DB  "Machinery",0	       ;39
  40+ 8CFD 69 6E 65 72
  40+ 8D01 79 00
  41+ 8D03 41 6C 6C 6F  WordAlloys  				DB  "Alloys",0		       ;40
  41+ 8D07 79 73 00
  42+ 8D0A 46 69 72 65  WordFirearms  	    		DB  "Firearms",0	       ;41
  42+ 8D0E 61 72 6D 73
  42+ 8D12 00
  43+ 8D13 46 75 72 73  WordFurs  		    		DB  "Furs",0	           ;42
  43+ 8D17 00
  44+ 8D18 4D 69 6E 65  WordMinerals  	    		DB  "Minerals",0           ;43
  44+ 8D1C 72 61 6C 73
  44+ 8D20 00
  45+ 8D21 47 6F 6C 64  WordGold  		    		DB  "Gold",0	           ;44
  45+ 8D25 00
  46+ 8D26 50 6C 61 74  WordPlatinum  	    		DB  "Platinum",0           ;45
  46+ 8D2A 69 6E 75 6D
  46+ 8D2E 00
  47+ 8D2F 47 65 6D 2D  WordGemStones  				DB  "Gem-Stones",0         ;46
  47+ 8D33 53 74 6F 6E
  47+ 8D37 65 73 00
  48+ 8D3A 41 6C 69 65  WordAlienItems      		DB  "Alien Items",0        ;47
  48+ 8D3E 6E 20 49 74
  48+ 8D42 65 6D 73 00
  49+ 8D46 54 6F 6E 6E  WordTonnes          		DB  "Tonnes",0             ;48
  49+ 8D4A 65 73 00
  50+ 8D4D 4B 69 6C 6F  WordKilograms       		DB  "Kilograms",0          ;49
  50+ 8D51 67 72 61 6D
  50+ 8D55 73 00
  51+ 8D57 47 72 61 6D  WordGrams           		DB  "Grams",0			   ;50
  51+ 8D5B 73 00
  52+ 8D5D 53 68 6F 72  WordShort           		DB  "Short",0			   ;51
  52+ 8D61 74 00
  53+ 8D63 52 61 6E 67  WordRange           		DB  "Range",0			   ;52
  53+ 8D67 65 00
  54+ 8D69 43 68 61 72  WordChart	        		DB  "Chart",0			   ;53
  54+ 8D6D 74 00
  55+ 8D6F 44 61 74 61  WordData					DB	"Data",0			   ;54
  55+ 8D73 00
  56+ 8D74 4F 6E 00     WordOn						DB  "On",0                 ;55
  57+ 8D77 44 69 73 74  WordDistance        		DB  "Distance",0           ;56
  57+ 8D7B 61 6E 63 65
  57+ 8D7F 00
  58+ 8D80 45 63 6F 6E  WordEconomy         		DB  "Economy",0            ;57
  58+ 8D84 6F 6D 79 00
  59+ 8D88 47 6F 76 65  WordGovernment      		DB  "Government",0         ;58
  59+ 8D8C 72 6E 6D 65
  59+ 8D90 6E 74 00
  60+ 8D93 54 65 63 68  WordTechLevel       		DB  "TechLevel",0          ;59
  60+ 8D97 4C 65 76 65
  60+ 8D9B 6C 00
  61+ 8D9D 50 6F 70 75  WordPopulation      		DB  "Population",0         ;60
  61+ 8DA1 6C 61 74 69
  61+ 8DA5 6F 6E 00
  62+ 8DA8 4D 69 6C 6C  WordMillion         		DB  "Million",0            ;61
  62+ 8DAC 69 6F 6E 00
  63+ 8DB0 42 69 6C 6C  WordBillion         		DB  "Billion",0            ;62
  63+ 8DB4 69 6F 6E 00
  64+ 8DB8 47 72 6F 73  WordGross           		DB  "Gross",0              ;63
  64+ 8DBC 73 00
  65+ 8DBE 50 72 6F 64  WordProductivity    		DB  "Productivity",0       ;64
  65+ 8DC2 75 63 74 69
  65+ 8DC6 76 69 74 79
  65+ 8DCA 00
  66+ 8DCB 41 76 65 72  WordAverage         		DB  "Average",0            ;65
  66+ 8DCF 61 67 65 00
  67+ 8DD3 52 61 64 69  WordRadius          		DB  "Radius",0             ;66
  67+ 8DD7 75 73 00
  68+ 8DDA 4B 4D 00     WordKM              		DB  "KM",0                 ;67
  69+ 8DDD 4D 20 43 52  WordMCR             		DB  "M CR",0               ;68
  69+ 8DE1 00
  70+ 8DE2 52 69 63 68  WordRich					DB  "Rich",0               ;69
  70+ 8DE6 00
  71+ 8DE7 41 76 67 00  WordAvg         			DB  "Avg",0            	   ;70
  72+ 8DEB 4D 61 69 6E  WordMainly          		DB  "Mainly",0             ;71
  72+ 8DEF 6C 79 00
  73+ 8DF2 50 6F 6F 72  WordPoor            		DB  "Poor",0               ;72
  73+ 8DF6 00
  74+ 8DF7 49 6E 64 75  WordIndustrial      		DB  "Industrial",0         ;73
  74+ 8DFB 73 74 72 69
  74+ 8DFF 61 6C 00
  75+ 8E02 41 67 72 69  WordAgricultural    		DB  "Agricultural",0       ;74
  75+ 8E06 63 75 6C 74
  75+ 8E0A 75 72 61 6C
  75+ 8E0E 00
  76+ 8E0F 41 6E 61 72  WordAnarchy                 DB  "Anarchy",0            ;75
  76+ 8E13 63 68 79 00
  77+ 8E17 46 65 75 64  WordFeudal                  DB  "Feudal",0             ;76
  77+ 8E1B 61 6C 00
  78+ 8E1E 4D 75 6C 74  WordMultiGovernment         DB  "Multi-Government",0   ;77
  78+ 8E22 69 2D 47 6F
  78+ 8E26 76 65 72 6E
  78+ 8E2A 6D 65 6E 74
  78+ 8E2E 00
  79+ 8E2F 44 69 63 74  WordDictatorship            DB  "Dictatorship",0       ;78
  79+ 8E33 61 74 6F 72
  79+ 8E37 73 68 69 70
  79+ 8E3B 00
  80+ 8E3C 43 6F 6D 6D  WordCommunist               DB  "Communist",0          ;79
  80+ 8E40 75 6E 69 73
  80+ 8E44 74 00
  81+ 8E46 43 6F 6E 66  WordConfederacy             DB  "Confederacy",0        ;80
  81+ 8E4A 65 64 65 72
  81+ 8E4E 61 63 79 00
  82+ 8E52 44 65 6D 6F  WordDemocracy               DB  "Democracy",0          ;81
  82+ 8E56 63 72 61 63
  82+ 8E5A 79 00
  83+ 8E5C 43 6F 72 70  WordCorporate               DB  "Corporate State",0    ;82
  83+ 8E60 6F 72 61 74
  83+ 8E64 65 20 53 74
  83+ 8E68 61 74 65 00
  84+ 8E6C 53 74 61 74  WordState 					DB  "State",0              ;83
  84+ 8E70 65 00
  85+ 8E72 4C 69 67 68  WordLight 					DB  "Light",0              ;84
  85+ 8E76 74 00
  86+ 8E78 59 65 61 72  WordYears 					DB  "Years",0              ;85
  86+ 8E7C 73 00
  87+ 8E7E 30 00        Word0						DB  "0",0				   ;86
  88+ 8E80 4D 61 72 6B  WordMarket					DB  "Market",0			   ;87
  88+ 8E84 65 74 00
  89+ 8E87 50 72 69 63  WordPrices					DB  "Prices",0			   ;88
  89+ 8E8B 65 73 00
  90+ 8E8E 50 72 6F 64  WordProduct    				DB  "Product",0  		   ;89
  90+ 8E92 75 63 74 00
  91+ 8E96 55 6F 4D 00  WordUoM						DB  "UoM",0                ;90
  92+ 8E9A 50 72 69 63  WordPrice					DB  "Price",0              ;91
  92+ 8E9E 65 00
  93+ 8EA0 46 6F 72 00  WordFor                     DB  "For",0                ;92
  94+ 8EA4 53 61 6C 65  WordSale                    DB  "Sale",0               ;93
  94+ 8EA8 00
  95+ 8EA9 74 00        Wordt						DB  "t",0                  ;94
  96+ 8EAB 6B 67 00     Wordkg						DB  "kg",0                 ;95
  97+ 8EAE 67 00        Wordg						DB  "g",0                  ;96
  98+ 8EB0 51 75 61 6E  WordQuantity				DB  "Quanitity",0		   ;97
  98+ 8EB4 69 74 69 74
  98+ 8EB8 79 00
  99+ 8EBA 49 6E 76 00  WordInv                     DB  "Inv",0                ;98
 100+ 8EBE 53 74 6F 63  WordStock                   DB  "Stock",0              ;99
 100+ 8EC2 6B 00
 101+ 8EC4 45 71 75 69  WordEquip                   DB  "Equip",0              ;100
 101+ 8EC8 70 00
 102+ 8ECA 53 68 69 70  WordShip                    DB  "Ship",0               ;101
 102+ 8ECE 00
 103+ 8ECF 4D 69 73 73  WordMissile                 DB  "Missile",0            ;102
 103+ 8ED3 69 6C 65 00
 104+ 8ED7 48 79 70 65  WordHyperdrive              DB  "Hyperdrive",0
 104+ 8EDB 72 64 72 69
 104+ 8EDF 76 65 00
 105+ 8EE2 4D 69 6C 69  WordMilitary                DB  "Military",0
 105+ 8EE6 74 61 72 79
 105+ 8EEA 00
 106+ 8EEB
 107+ 8EEB E7 8B E9 8B  WordIdx				DW  WordDummy,          WordFront,        WordRight,        WordLeft		;0-3
 107+ 8EEF EF 8B F5 8B
 108+ 8EF3 FA 8B FF 8B  					DW  WordRear,           WordLarge,        WordEscape,       WordPod      	;4-7
 108+ 8EF7 05 8C 0C 8C
 109+ 8EFB 10 8C 16 8C  					DW  WordCargo,          WordBay,          WordFuel,         WordScoops   	;8
 109+ 8EFF 1A 8C 1F 8C
 110+ 8F03 26 8C 2D 8C  					DW  WordECM,            WordSystem,       WordEnergy,       WordBomb     	;12
 110+ 8F07 34 8C 3B 8C
 111+ 8F0B 40 8C 46 8C  					DW  WordLaser,          WordPulse,        WordBeam,         WordMiliary  	;16
 111+ 8F0F 4C 8C 51 8C
 112+ 8F13 59 8C 60 8C  					DW  WordMining,         WordCustom,       WordUnit,         WordShield   	;20
 112+ 8F17 67 8C 6C 8C
 113+ 8F1B 73 8C 7B 8C  					DW  WordDocking,        WordComputers,    WordHyperspace,   WordGalactic 	;24
 113+ 8F1F 85 8C 90 8C
 114+ 8F23 99 8C 9F 8C  					DW  WordExtra,          WordClean,        WordOffender,     WordFugitive	;28
 114+ 8F27 A5 8C AE 8C
 115+ 8F2B B7 8C BC 8C  					DW  WordFood,           WordTextiles,     WordRadioactives, WordSlaves		;32
 115+ 8F2F C5 8C D2 8C
 116+ 8F33 D9 8C E6 8C  					DW  WordLiquorWines,    WordLuxuries,     WordNarcotics,    WordMachinery   ;36
 116+ 8F37 EF 8C F9 8C
 117+ 8F3B 03 8D 0A 8D  					DW  WordAlloys,         WordFirearms,     WordFurs,         WordMinerals    ;40
 117+ 8F3F 13 8D 18 8D
 118+ 8F43 21 8D 26 8D  					DW  WordGold,           WordPlatinum,     WordGemStones,    WordAlienItems  ;44               ;
 118+ 8F47 2F 8D 3A 8D
 119+ 8F4B 46 8D 4D 8D  WordIdxUoMFull		DW  WordTonnes,         WordKilograms,    WordGrams,		WordShort		;48
 119+ 8F4F 57 8D 5D 8D
 120+ 8F53 63 8D 69 8D  					DW	WordRange,		    WordChart,        WordData,         WordOn          ;52
 120+ 8F57 6F 8D 74 8D
 121+ 8F5B 77 8D 80 8D  					DW  WordDistance,       WordEconomy,      WordGovernment,   WordTechLevel   ;56
 121+ 8F5F 88 8D 93 8D
 122+ 8F63 9D 8D A8 8D  					DW  WordPopulation,     WordMillion,      WordBillion,      WordGross       ;60
 122+ 8F67 B0 8D B8 8D
 123+ 8F6B BE 8D CB 8D  					DW  WordProductivity,   WordAverage,      WordRadius,       WordKM          ;64
 123+ 8F6F D3 8D DA 8D
 124+ 8F73 DD 8D        					DW  WordMCR																	;68
 125+ 8F75 E2 8D E7 8D  WordIdxEconomy		DW  WordRich,           WordAvg,      	  WordMainly,       WordPoor        ;69
 125+ 8F79 EB 8D F2 8D
 126+ 8F7D F7 8D 02 8E                      DW  WordIndustrial,     WordAgricultural									;73
 127+ 8F81 0F 8E 17 8E  WordIdxGovernment	DW  WordAnarchy,        WordFeudal,       WordMultiGovernment, WordDictatorship ;75
 127+ 8F85 1E 8E 2F 8E
 128+ 8F89 3C 8E 46 8E                      DW  WordCommunist,      WordConfederacy,  WordDemocracy,       WordCorporate ;79
 128+ 8F8D 52 8E 5C 8E
 129+ 8F91 6C 8E 72 8E  					DW  WordState,          WordLight,        WordYears,           Word0         ; 83
 129+ 8F95 78 8E 7E 8E
 130+ 8F99 80 8E 87 8E  WordIdxMarketmenu	DW  WordMarket,         WordPrices,       WordProduct,         WordUoM	    ;87
 130+ 8F9D 8E 8E 96 8E
 131+ 8FA1 9A 8E A0 8E                      DW  WordPrice,          WordFor,          WordSale                          ;91
 131+ 8FA5 A4 8E
 132+ 8FA7 A9 8E AB 8E  WordIdxUomAbbrev	DW	Wordt,				Wordkg,           Wordg                 		    ;94
 132+ 8FAB AE 8E
 133+ 8FAD B0 8E BA 8E  					DW  WordQuantity,       WordInv,          WordStock,           WordEquip	;97
 133+ 8FB1 BE 8E C4 8E
 134+ 8FB5 CA 8E CF 8E                      DW  WordShip,           WordMissile       ; 101
 135+ 8FB9
 136+ 8FB9              ; Phrases
 137+ 8FB9 05 08 09 00  TextLargeCargoBay			DB 	5,8,9,0          ;0
 138+ 8FBD 06 07 00     TextEscapePod				DB	6,7,0            ;1
 139+ 8FC0 0A 0B 00     TextFuelScoops				DB	10,11,0          ;2
 140+ 8FC3 0C 0D 00     TextECMSystem				DB	12,13,0          ;3
 141+ 8FC6 0E 0F 00     TextEnergyBomb				DB	14,15,0          ;4
 142+ 8FC9 0E 16 00     TextEnergyUnit				DB	14,22,0          ;5
 143+ 8FCC 18 19 00     TextDockingComp     		DB  24,25,0          ;6
 144+ 8FCF 1B 1A 00     TextGalacticHyper			DB	27,26,0          ;7
 145+ 8FD2 01 12 10 00  TextFrontLaser      		DB  01,18,16,0       ;8
 146+ 8FD6 03 12 10 00  TextLeftLaser       		DB  03,18,16,0       ;9
 147+ 8FDA 02 12 10 00  TextRightLaser      		DB  02,18,16,0       ;10
 148+ 8FDE 04 12 10 00  TextRearLaser       		DB  04,18,16,0       ;11
 149+ 8FE2 33 34 35 00  TextShortRangeChart 		DB	51,52,53,0       ;12
 150+ 8FE6 1B 35 00     TextGalacticChart   		DB	27,53,0          ;13
 151+ 8FE9 36 37 00     TextDataOn					DB	54,55,0          ;14
 152+ 8FEC 45 49 00     TextRichIndustrial          DB  69,73,0          ;15
 153+ 8FEF 46 49 00     TextAvgIndustrial           DB  70,73,0			 ;16
 154+ 8FF2 47 49 00     TextMainIndustrial          DB  71,73,0          ;17
 155+ 8FF5 48 49 00     TextPoorIndustrial          DB  72,73,0          ;18
 156+ 8FF8 45 4A 00     TextRichAgricultural        DB  69,74,0          ;19
 157+ 8FFB 46 4A 00     TextAvgAgricultural         DB  70,74,0          ;20
 158+ 8FFE 47 4A 00     TextMainAgricultural        DB  71,74,0          ;21
 159+ 9001 48 4A 00     TextPoorAgricultural        DB  72,74,0          ;22
 160+ 9004 54 55 00     TextLightYears				DB  84,85,0			 ;23
 161+ 9007 56 54 55 00  Text0LightYears				DB  86,84,85,0		 ;24
 162+ 900B 57 58 00     TextMarketPrices			DB  87,88,0			 ;25
 163+ 900E 64 65        TextEquipShip               DB  100,101          ;26
 164+ 9010
 165+ 9010 00           TextDummy					DB  0
 166+ 9011
 167+ 9011 B9 8F BD 8F  TextTokens			DW  TextLargeCargoBay, TextEscapePod, TextFuelScoops				; 0 2
 167+ 9015 C0 8F
 168+ 9017 C3 8F C6 8F  					DW  TextECMSystem, TextEnergyBomb, TextEnergyUnit					; 3 5
 168+ 901B C9 8F
 169+ 901D CC 8F CF 8F  					DW  TextDockingComp, TextGalacticHyper  							; 6 7
 170+ 9021 D2 8F D6 8F  					DW	TextFrontLaser, TextLeftLaser, TextRightLaser, TextRearLaser	; 8 11
 170+ 9025 DA 8F DE 8F
 171+ 9029 E2 8F E6 8F  					DW  TextShortRangeChart, TextGalacticChart, TextDataOn				; 12 14
 171+ 902D E9 8F
 172+ 902F EC 8F EF 8F  TextTokenEconomy	DW  TextRichIndustrial, TextAvgIndustrial, TextPoorIndustrial, TextMainIndustrial, TextMainAgricultural, TextRichAgricultural, TextAvgAgricultural,  TextPoorAgricultural
 172+ 9033 F5 8F F2 8F
 172+ 9037 FE 8F F8 8F
 172+ 903B FB 8F 01 90
 173+ 903F 04 90        					DW  TextLightYears		                                            ; 21 23
 174+ 9041 07 90 0B 90  					DW  Text0LightYears, TextMarketPrices
 175+ 9045 10 90        					DW  TextDummy;  25
 176+ 9047 00 00 00...  TextBuffer			DS	33
 177+ 9068
 178+ 9068              TextEconomyOffset   EQU (TextTokenEconomy - TextTokens)/2
 179+ 9068              TextGovOffset       EQU (WordIdxGovernment - WordIdx)/2
 180+ 9068
 181+ 9068              CapitaliseString:
 182+ 9068              ; ">CapitaliseString hl = address"
 183+ 9068              .CapLoop:
 184+ 9068 23           	inc		hl
 185+ 9069 7E           	ld		a,(hl)
 186+ 906A FE 00        	cp		0
 187+ 906C C8           	ret		z
 188+ 906D FE 5B        	cp		'Z'+1
 189+ 906F 30 F7        	jr		nc,.CapLoop
 190+ 9071 FE 41        	cp		'A'
 191+ 9073 38 F3        	jr		c,.CapLoop
 192+ 9075              .LowerCase:
 193+ 9075 C6 20        	add		a,'a'-'A'
 194+ 9077 77           	ld		(hl),a
 195+ 9078 18 EE        	jr		.CapLoop
 196+ 907A
 197+ 907A              WordIndexToAddress:
 198+ 907A 21 EB 8E     	ld		hl,WordIdx
 199+ 907D ED 31        	add		hl,a
 200+ 907F ED 31        	add		hl,a
 201+ 9081 D5           	push	de
 202+ 9082 5E           	ld		e,(hl)
 203+ 9083 23           	inc		hl
 204+ 9084 56           	ld		d,(hl)
 205+ 9085 EB           	ex		de,hl
 206+ 9086 D1           	pop		de
 207+ 9087 C9           	ret
 208+ 9088
 209+ 9088
 210+ 9088              expandTokenToString:
 211+ 9088              ; ">expandTokenToString a = texttoken"
 212+ 9088 21 11 90     	ld		hl,TextTokens
 213+ 908B CD C0 8B     	call	getTableText
 214+ 908E 11 47 90     	ld		de,TextBuffer
 215+ 9091              .ReadLoop:
 216+ 9091 7E           	ld		a,(hl)
 217+ 9092 FE 00        	cp		0
 218+ 9094 28 1B        	jr		z,.ReadDone
 219+ 9096 E5           	push	hl
 220+ 9097 D5           	push	de
 221+ 9098 21 EB 8E     	ld		hl,WordIdx
 222+ 909B CD C0 8B     	call	getTableText
 223+ 909E D1           	pop		de
 224+ 909F              .WordExpandLoop:
 225+ 909F 7E           	ld		a,(hl)
 226+ 90A0 FE 00        	cp		0
 227+ 90A2 28 05        	jr		z,.AddSpace
 228+ 90A4              ;.GetChar:
 229+ 90A4 12           	ld		(de),a
 230+ 90A5 13           	inc		de
 231+ 90A6 23           	inc		hl
 232+ 90A7 18 F6        	jr		.WordExpandLoop
 233+ 90A9              .AddSpace:
 234+ 90A9 3E 20        	ld		a,' '
 235+ 90AB 12           	ld		(de),a
 236+ 90AC 13           	inc		de
 237+ 90AD E1           	pop		hl
 238+ 90AE 23           	inc		hl
 239+ 90AF 18 E0        	jr		.ReadLoop
 240+ 90B1              .ReadDone:
 241+ 90B1 1B           	dec		de
 242+ 90B2 AF           	xor		a
 243+ 90B3 12           	ld		(de),a
 244+ 90B4 C9           	ret
 245+ 90B5
# file closed: ./Tables/dictionary.asm
 126  90B5                  INCLUDE "./Tables/name_digrams.asm"
# file opened: ./Tables/name_digrams.asm
   1+ 90B5 41 42 4F 55  name_digrams	DB "ABOUSEITILETSTONLONUTHNO"
   1+ 90B9 53 45 49 54
   1+ 90BD 49 4C 45 54
   1+ 90C1 53 54 4F 4E
   1+ 90C5 4C 4F 4E 55
   1+ 90C9 54 48 4E 4F
   2+ 90CD 41 4C 4C     name_digrams2   DB "ALL"
   3+ 90D0 45 58 45 47  				DB "EXEGEZACEBISOUSESARMAINDIREA"
   3+ 90D4 45 5A 41 43
   3+ 90D8 45 42 49 53
   3+ 90DC 4F 55 53 45
   3+ 90E0 53 41 52 4D
   3+ 90E4 41 49 4E 44
   3+ 90E8 49 52 45 41
   4+ 90EC 3F 45 52 41  				DB "?ERATENBERALAVETIEDORQUANTEISRION"
   4+ 90F0 54 45 4E 42
   4+ 90F4 45 52 41 4C
   4+ 90F8 41 56 45 54
   4+ 90FC 49 45 44 4F
   4+ 9100 52 51 55 41
   4+ 9104 4E 54 45 49
   4+ 9108 53 52 49 4F
   4+ 910C 4E
   5+ 910D
   6+ 910D              ; TODO Moveinto galaxy data module
   7+ 910D 00 00 00...  name_expanded	DS 32
   8+ 912D 00           				DB 0
   9+ 912E
  10+ 912E
  11+ 912E
  12+ 912E              NamingLoop:
  13+ 912E 3A 61 85     	ld		a,(WorkingSeeds+5)	; a = first byte of name seed
  14+ 9131 E6 1F        	and 	$1F					; Keep bottom 5 bits only
  15+ 9133 FE 00        	cp		0					; 0 = skip 2 chars
  16+ 9135 28 12        	jr		z,.SkipPhrase
  17+ 9137 C6 0C        	add		a,12
  18+ 9139 CB 27        	sla		a					; phrase = (a+12)*2
  19+ 913B 21 B5 90     	ld		hl,name_digrams
  20+ 913E ED 31        	add		hl,a
  21+ 9140 ED A0        	ldi
  22+ 9142 7E           	ld		a,(hl)
  23+ 9143 FE 3F        	cp		'?'
  24+ 9145 28 02        	jr		z,.SkipPhrase
  25+ 9147              .AddExtra:
  26+ 9147 ED A0        	ldi
  27+ 9149              .SkipPhrase:
  28+ 9149 D5           	push	de
  29+ 914A CD 5E 89     	call	working_seed
  30+ 914D D1           	pop		de
  31+ 914E C9           	ret
  32+ 914F
  33+ 914F              ;GetDigramGalaxySeed:
  34+ 914F              ;	call	copy_galaxy_to_working
  35+ 914F              ;	jr		GetDigramWorkingSeed
  36+ 914F              ;GetDigramSystemSeed:
  37+ 914F              ;	call	copy_system_to_working
  38+ 914F              ;GetDigramWorkingSeed:
  39+ 914F              ;; ">GetDigram a = digram seed"
  40+ 914F              ;	ld		de,name_expanded
  41+ 914F              ;	ld		b,3
  42+ 914F              ;	ld		a,(WorkingSeeds)
  43+ 914F              ;	and		$40
  44+ 914F              ;	jr		z,.SmallSizeName
  45+ 914F              ;.LargeSizeName:
  46+ 914F              ;	call	NamingLoop
  47+ 914F              ;.SmallSizeName:
  48+ 914F              ;	call	NamingLoop
  49+ 914F              ;	call	NamingLoop
  50+ 914F              ;	call	NamingLoop
  51+ 914F              ;.DoneName:
  52+ 914F              ;	ex		de,hl
  53+ 914F              ;	ld		(hl),0
  54+ 914F              ;	ex		de,hl
  55+ 914F              ;	ret
  56+ 914F
  57+ 914F
  58+ 914F
  59+ 914F              ;GetDigramWorkingSeed:
  60+ 914F              ;	MESSAGE ">GetDigram a = digram seed b = length"
  61+ 914F              ;	ld		b,5					; working seed
  62+ 914F              ;	ld		de,name_expanded
  63+ 914F              ;.ExpansionLoop:
  64+ 914F              ;	push	bc
  65+ 914F              ;	ld		hl,WorkingSeeds
  66+ 914F              ;	ld		a,b
  67+ 914F              ;	add		hl,a
  68+ 914F              ;	ld		a,(hl)	; a = first byte of name seed
  69+ 914F              ;	and 	$1F					; Keep bottom 5 bits only
  70+ 914F              ;	cp		0					; 0 = skip 2 chars
  71+ 914F              ;	jr		z,.SkipPhrase
  72+ 914F              ;	or		&80					; set buit 7 high (probabtyl capitalisation)
  73+ 914F              ;	call	TT27
  74+ 914F              ;.SkipPhrase:
  75+ 914F              ;	push	de
  76+ 914F              ;	call	next_working_seed
  77+ 914F              ;	pop		de
  78+ 914F              ;	pop		bc
  79+ 914F              ;	djnz	GetDigramWorkingSeed
  80+ 914F              ;.DoneName:
  81+ 914F              ;	ex		de,hl
  82+ 914F              ;	ld		(hl),0
  83+ 914F              ;	ex		de,hl
  84+ 914F              ;	ret
  85+ 914F              ;
  86+ 914F              ;ExpandToken:
  87+ 914F              ;	DE = target
  88+ 914F              ;	a = token
  89+ 914F              ;
  90+ 914F              ;PlanetDigram:
  91+ 914F              ;	cp		&A0							; >- 160
  92+ 914F              ;	jr		c,MorePage4
  93+ 914F              ;	and		$7F							; 128 to 159 now 0 to 31
  94+ 914F              ;	asl		2							; Multiply by 2
  95+ 914F              ;	ld		hl, name_digrams2
  96+ 914F              ;	add		hl,a
  97+ 914F              ;	ld		a,(hl)
  98+ 914F              ;	call	ProcessTextToken
  99+ 914F              ;	inc		hl
 100+ 914F              ;	ld		a,(hl)
 101+ 914F              ;	cp		'?'
 102+ 914F              ;	ret		z
 103+ 914F              ;	call	ProcessTextToken
 104+ 914F              ;	ret
 105+ 914F              ;MorePage4:
 106+ 914F              ;	sub		$A0
 107+ 914F              ;ExtraTokenCheck:
 108+ 914F              ;	push	de							; save target address
 109+ 914F              ;	push	bc
 110+ 914F              ;	ld		b,a
 111+ 914F              ;	ld		hl,varV
 112+ 914F              ;	ld		(VarV),0400
 113+ 914F              ;	ld		(varV),a
 114+ 914F              ;	ld
 115+ 914F              ;
 116+ 914F              ;		.TT43	\ Token > 127 page4 token or planet digram.
 117+ 914F              ;C9 A0                   CMP #&A0	      \ >= #160 ?
 118+ 914F              ;B0 14                   BCS TT47	      \ more page4, subtract #160
 119+ 914F              ;29 7F                   AND #&7F	      \ else token 128to159  -> 0 to 31
 120+ 914F              ;0A                      ASL A		      \ *= 2
 121+ 914F              ;A8                      TAY 		      \ digram index = 0to62
 122+ 914F              ;B9 80 08                LDA &0880,Y \ QQ16,Y  \ ALLEXEGEZACEBISOUSESARMAINDIREA?ER  etc.
 123+ 914F              ;20 9A 33                JSR &339A   \ TT27    \ process text token
 124+ 914F              ;B9 81 08                LDA &0881,Y \ QQ16+1,Y \ 2nd character of diagram. Flight copied down from docked code.
 125+ 914F              ;C9 3F                   CMP #&3F	      \ is second letter '?'
 126+ 914F              ;F0 40                   BEQ TT48    	      \ rts, name has odd-number of letters.
 127+ 914F              ;4C 9A 33                JMP &339A   \ TT27    \ process text token
 128+ 914F              ;
 129+ 914F              ;	.TT47	\ more page4, subtract #160
 130+ 914F              ;E9 A0                   SBC #&A0	\ -= 160
 131+ 914F              ;	.ex	\ -> &342D \ extra, token >= 96 or Acc = 128to145 or -=160
 132+ 914F              ;AA                      TAX 		\ copy of word index
 133+ 914F              ;A9 00                   LDA #0		\ page 4 words lo  #QQ18 MOD 256
 134+ 914F              ;85 22                   STA &22		\ V
 135+ 914F              ;A9 04                   LDA #4		\ page 4 words hi  #QQ18 DIV 256
 136+ 914F              ;85 23                   STA &23		\ V+1
 137+ 914F              ;A0 00                   LDY #0
 138+ 914F              ;8A                      TXA 		\ token = word index
 139+ 914F              ;F0 13                   BEQ TT50	\ if X=0 then Y offset to word correct
 140+ 914F              ;	.TT51	\ counters Y letter, X token
 141+ 914F              ;B1 22                   LDA (&22),Y	\ (V),Y
 142+ 914F              ;F0 07                   BEQ TT49	\ exit as word ended
 143+ 914F              ;C8                      INY 		\ letter count
 144+ 914F              ;D0 F9                   BNE TT51	\ loop Y
 145+ 914F              ;E6 23                   INC &23	  \ V+1 \ next page as Y reached 256
 146+ 914F              ;D0 F5                   BNE TT51    	\ guaranteed, loop Y letter
 147+ 914F              ;	.TT49	\ word ended
 148+ 914F              ;C8                      INY
 149+ 914F              ;D0 02                   BNE TT59    	\ next word
 150+ 914F              ;E6 23                   INC &23	  \ V+1	\ next page as Y reached 256
 151+ 914F              ;	.TT59	\ next word
 152+ 914F              ;CA                      DEX 		\ token count
 153+ 914F              ;D0 ED                   BNE TT51	\ loop X token
 154+ 914F              ;	.TT50	\ token X = 0, counter Y offset to word correct
 155+ 914F              ;98                      TYA
 156+ 914F              ;48                      PHA 		\ store Yindex
 157+ 914F              ;A5 23                   LDA &23		\ V+1
 158+ 914F              ;48                      PHA 		\ correct pointer hi
 159+ 914F              ;B1 22                   LDA (&22),Y 	\ (V),Y
 160+ 914F              ;49 23                   EOR #&23	\ decode '#'
 161+ 914F              ;20 9A 33                JSR &339A \ TT27 \ process text token to next depth
 162+ 914F              ;68                      PLA 		\ restore this depth's Vhi
 163+ 914F              ;85 23                   STA &23		\ V+1
 164+ 914F              ;68                      PLA
 165+ 914F              ;A8                      TAY 		\ restore this depth's Yindex
 166+ 914F              ;C8                      INY 		\ next letter
 167+ 914F              ;D0 02                   BNE P%+4	\ not zero so skip next page
 168+ 914F              ;E6 23                   INC &23		\ V+1
 169+ 914F              ;B1 22                   LDA (&22),Y	\ (V),Y
 170+ 914F              ;D0 E6                   BNE TT50    	\ loop Y for next letter of page4 token
 171+ 914F              ;	.TT48 	\ rts
 172+ 914F              ;60                      RTS 		\ end of flight token printing TT27
 173+ 914F              ;
 174+ 914F              ;
 175+ 914F              ;
 176+ 914F              ;
 177+ 914F              ;
 178+ 914F              ;
 179+ 914F              ;		.TT27	\ -> &36E0 \ process flight text Token in Acc
 180+ 914F              ;;AA                      TAX		\ copy token to count down
 181+ 914F              ;;F0 DE                   BEQ csh		\ Acc = 0, up to Cash
 182+ 914F              ;30 74                   BMI TT43	\ if token is >  127 down, page4 token or digram
 183+ 914F              ;CA                      DEX
 184+ 914F              ;F0 BC                   BEQ tal		\ Acc == 1, up, print Galaxy number.
 185+ 914F              ;CA                      DEX
 186+ 914F              ;F0 A3                   BEQ ypl		\ Acc == 2, up, present planet in QQ2.
 187+ 914F              ;CA                      DEX
 188+ 914F              ;D0 03                   BNE P%+5	\ hop over, else X == 0
 189+ 914F              ;4C 0A 33                JMP &330A \ cpl \ Acc = 3 print Planet name for seed QQ15
 190+ 914F              ;CA                      DEX
 191+ 914F              ;F0 8A                   BEQ cmn		\ Acc == 4, up, commander name.
 192+ 914F              ;CA                      DEX
 193+ 914F              ;F0 B5                   BEQ fwl		\ Acc == 5, up, fuel followed by cash.
 194+ 914F              ;CA                      DEX
 195+ 914F              ;D0 05                   BNE  P%+7	\ hop over, else X == 0
 196+ 914F              ;A9 80                   LDA #&80	\ Acc == 6, set bit 7 TT27m
 197+ 914F              ;85 72                   STA &72	 	\ QQ17
 198+ 914F              ;60                      RTS
 199+ 914F              ;CA                      DEX 		\ skip Acc ==7
 200+ 914F              ;CA                      DEX
 201+ 914F              ;D0 03                   BNE P%+5	\ hop over to continue Acc 9to127
 202+ 914F              ;86 72                   STX &72	 \ QQ17	\ else Acc ==8, QQ17 set to X = 0
 203+ 914F              ;60                      RTS
 204+ 914F              ;CA                      DEX 		\ continue 9to127 tokens
 205+ 914F              ;F0 38                   BEQ crlf	\ Acc == 9, down, colon on right.
 206+ 914F              ;C9 60                   CMP #&60	\ discard X, look at Acc = token >= 96
 207+ 914F              ;B0 66                   BCS ex   	\ extra >= #&60, far down
 208+ 914F              ;C9 0E                   CMP #14		\ < 14 ?
 209+ 914F              ;90 04                   BCC P%+6	\ goes to Token < 14 or > 31
 210+ 914F              ;C9 20                   CMP #32		\ < 32 ?
 211+ 914F              ;90 28                   BCC qw   	\ 14 <= token A < 32 becomes 128to145 page4 digram
 212+ 914F              ;		\ Token  < 14 or > 31
 213+ 914F              ;A6 72                   LDX &72	 	\ QQ17
 214+ 914F              ;F0 3D                   BEQ TT74 	\ if QQ17 = 0 Upper case, jmp TT26, print character.
 215+ 914F              ;30 11                   BMI TT41 	\ if bit7 set
 216+ 914F              ;24 72                   BIT &72		\ QQ17 has bit6 set too
 217+ 914F              ;70 30                   BVS TT46 	\ If only bit6 set, clear bit6 and print as Upper
 218+ 914F              ;	.TT42	\ Uppercase to lowercase
 219+ 914F              ;C9 41                   CMP #&41	\ < ascii 'A'
 220+ 914F              ;90 06                   BCC TT44 	\ jmp TT26, print character
 221+ 914F              ;C9 5B                   CMP #&5B	\ >= ascii 'Z'+1
 222+ 914F              ;B0 02                   BCS TT44 	\ jmp TT26, print character
 223+ 914F              ;69 20                   ADC #&20	\ else Upper to lowercase
 224+ 914F              ;	.TT44	\ print character as is with TT26
 225+ 914F              ;4C FC 1E                JMP &1EFC \ TT26 \ print character
 226+ 914F              ;
 227+ 914F              ;	.TT41	\ QQ17 bit7 set
 228+ 914F              ;24 72                   BIT &72		\ QQ17
 229+ 914F              ;70 17                   BVS TT45	\ bit6 set too, Nothing or lower.
 230+ 914F              ;C9 41                   CMP #&41	\ < ascii 'A'
 231+ 914F              ;90 22                   BCC TT74 	\ print as is using TT26
 232+ 914F              ;48                      PHA 		\ else store token Acc
 233+ 914F              ;8A                      TXA 		\ QQ17 copy
 234+ 914F              ;09 40                   ORA #&40	\ set bit6 in QQ17 so subsequent ones lower
 235+ 914F              ;85 72                   STA &72	 	\ QQ17
 236+ 914F              ;68                      PLA 		\ restore token
 237+ 914F              ;D0 EC                   BNE TT44	\ guaranteed up, print as Uppercase with TT26.
 238+ 914F              ;
 239+ 914F              ;	.qw	\ Acc = 14to31 becomes 128to145 page4 digram
 240+ 914F              ;69 72                   ADC #&72	\ A+=114 becomes 128to145 page4 digram
 241+ 914F              ;D0 32                   BNE ex		\ guaranteed down, extra.
 242+ 914F              ;
 243+ 914F              ;	.crlf	\ Acc == 9,  colon on right
 244+ 914F              ;A9 15                   LDA #21		\ on right
 245+ 914F              ;85 2C                   STA &2C		\ XC
 246+ 914F              ;D0 97                   BNE TT73	\ guaranteed up, print colon.
 247+ 914F              ;
 248+ 914F              ;	.TT45	\ QQ17 bits 7,6 set. Nothing or lower.
 249+ 914F              ;E0 FF                   CPX #&FF	\ if QQ17 = #&FF
 250+ 914F              ;F0 63                   BEQ TT48	\ rts
 251+ 914F              ;C9 41                   CMP #&41	\ >= ascii 'A' ?
 252+ 914F              ;B0 D0                   BCS TT42	\ Uppercase to lowercase, up.
 253+ 914F              ;	.TT46	\ clear bit6 QQ17 and print as is using TT26
 254+ 914F              ;48                      PHA 		\ push token
 255+ 914F              ;8A                      TXA 		\ QQ17 copy
 256+ 914F              ;29 BF                   AND #&BF	\ clear bit6
 257+ 914F              ;85 72                   STA &72	 	\ QQ17
 258+ 914F              ;68                      PLA 		\ pull token
 259+ 914F              ;	.TT74	\ TT26, print character.
 260+ 914F              ;4C FC 1E                JMP &1EFC	\ TT26
 261+ 914F              ;
 262+ 914F              ;	.TT43	\ Token > 127 page4 token or planet digram.
 263+ 914F              ;C9 A0                   CMP #&A0	      \ >= #160 ?
 264+ 914F              ;B0 14                   BCS TT47	      \ more page4, subtract #160
 265+ 914F              ;29 7F                   AND #&7F	      \ else token 128to159  -> 0 to 31
 266+ 914F              ;0A                      ASL A		      \ *= 2
 267+ 914F              ;A8                      TAY 		      \ digram index = 0to62
 268+ 914F              ;B9 80 08                LDA &0880,Y \ QQ16,Y  \ ALLEXEGEZACEBISOUSESARMAINDIREA?ER  etc.
 269+ 914F              ;20 9A 33                JSR &339A   \ TT27    \ process text token
 270+ 914F              ;B9 81 08                LDA &0881,Y \ QQ16+1,Y \ 2nd character of diagram. Flight copied down from docked code.
 271+ 914F              ;C9 3F                   CMP #&3F	      \ is second letter '?'
 272+ 914F              ;F0 40                   BEQ TT48    	      \ rts, name has odd-number of letters.
 273+ 914F              ;4C 9A 33                JMP &339A   \ TT27    \ process text token
 274+ 914F              ;
 275+ 914F              ;	.TT47	\ more page4, subtract #160
 276+ 914F              ;E9 A0                   SBC #&A0	\ -= 160
 277+ 914F              ;	.ex	\ -> &342D \ extra, token >= 96 or Acc = 128to145 or -=160
 278+ 914F              ;AA                      TAX 		\ copy of word index
 279+ 914F              ;A9 00                   LDA #0		\ page 4 words lo  #QQ18 MOD 256
 280+ 914F              ;85 22                   STA &22		\ V
 281+ 914F              ;A9 04                   LDA #4		\ page 4 words hi  #QQ18 DIV 256
 282+ 914F              ;85 23                   STA &23		\ V+1
 283+ 914F              ;A0 00                   LDY #0
 284+ 914F              ;8A                      TXA 		\ token = word index
 285+ 914F              ;F0 13                   BEQ TT50	\ if X=0 then Y offset to word correct
 286+ 914F              ;	.TT51	\ counters Y letter, X token
 287+ 914F              ;B1 22                   LDA (&22),Y	\ (V),Y
 288+ 914F              ;F0 07                   BEQ TT49	\ exit as word ended
 289+ 914F              ;C8                      INY 		\ letter count
 290+ 914F              ;D0 F9                   BNE TT51	\ loop Y
 291+ 914F              ;E6 23                   INC &23	  \ V+1 \ next page as Y reached 256
 292+ 914F              ;D0 F5                   BNE TT51    	\ guaranteed, loop Y letter
 293+ 914F              ;	.TT49	\ word ended
 294+ 914F              ;C8                      INY
 295+ 914F              ;D0 02                   BNE TT59    	\ next word
 296+ 914F              ;E6 23                   INC &23	  \ V+1	\ next page as Y reached 256
 297+ 914F              ;	.TT59	\ next word
 298+ 914F              ;CA                      DEX 		\ token count
 299+ 914F              ;D0 ED                   BNE TT51	\ loop X token
 300+ 914F              ;	.TT50	\ token X = 0, counter Y offset to word correct
 301+ 914F              ;98                      TYA
 302+ 914F              ;48                      PHA 		\ store Yindex
 303+ 914F              ;A5 23                   LDA &23		\ V+1
 304+ 914F              ;48                      PHA 		\ correct pointer hi
 305+ 914F              ;B1 22                   LDA (&22),Y 	\ (V),Y
 306+ 914F              ;49 23                   EOR #&23	\ decode '#'
 307+ 914F              ;20 9A 33                JSR &339A \ TT27 \ process text token to next depth
 308+ 914F              ;68                      PLA 		\ restore this depth's Vhi
 309+ 914F              ;85 23                   STA &23		\ V+1
 310+ 914F              ;68                      PLA
 311+ 914F              ;A8                      TAY 		\ restore this depth's Yindex
 312+ 914F              ;C8                      INY 		\ next letter
 313+ 914F              ;D0 02                   BNE P%+4	\ not zero so skip next page
 314+ 914F              ;E6 23                   INC &23		\ V+1
 315+ 914F              ;B1 22                   LDA (&22),Y	\ (V),Y
 316+ 914F              ;D0 E6                   BNE TT50    	\ loop Y for next letter of page4 token
 317+ 914F              ;	.TT48 	\ rts
 318+ 914F              ;60                      RTS 		\ end of flight token printing TT27
 319+ 914F              ;
 320+ 914F              ;
 321+ 914F              ;
# file closed: ./Tables/name_digrams.asm
 127  914F                  INCLUDE "./Maths/addhldesigned.asm"
# file opened: ./Maths/addhldesigned.asm
   1+ 914F CB 7C        addhldesigned:          bit     7,h
   2+ 9151 20 03                                jr      nz,.noneghl
   3+ 9153 CD 6B 97                             call    negate16hl
   4+ 9156 CB 7A        .noneghl:               bit     7,d
   5+ 9158 20 03                                jr      nz,.nonegde
   6+ 915A CD 72 97                             call    negate16de
   7+ 915D 19           .nonegde:               add     hl,de                       ; do 2'd c add
   8+ 915E AF                                   xor     a                           ; assume positive
   9+ 915F CB 7C                                bit     7,h
  10+ 9161 C8                                   ret     z                           ; if not set then can exit early
  11+ 9162 CD 6B 97                             call    negate16hl
  12+ 9165 3E FF                                ld      a,$FF
  13+ 9167 C9                                   ret
  14+ 9168
# file closed: ./Maths/addhldesigned.asm
 128  9168                  INCLUDE "./Maths/asm_add.asm"
# file opened: ./Maths/asm_add.asm
   1+ 9168
   2+ 9168              ; HL(2sc) = HL (signed) + A (unsigned), uses HL, DE, A
   3+ 9168 16 00        HL2cEquHLSgnPlusAusgn:  ld      d,0
   4+ 916A 5F                                   ld      e,a                         ; set up DE = A
   5+ 916B 7C                                   ld      a,h
   6+ 916C E6 7F                                and     SignMask8Bit
   7+ 916E 28 07                                jr      z,.HLPositive               ; if HL is negative then do HL - A
   8+ 9170 67           .HLNegative:            ld      h,a                         ; hl = ABS (HL)
   9+ 9171                                      NegHL                               ; hl = - hl
   9+ 9171 AF          >                    xor a
   9+ 9172 95          >                    sub l
   9+ 9173 6F          >                    ld l,a
   9+ 9174 9F          >                    sbc a,a
   9+ 9175 94          >                    sub h
   9+ 9176 67          >                    ld h,a
  10+ 9177              .HLPositive:            ClearCarryFlag                      ; now do adc hl,de
  10+ 9177 B7          >                        or a
  11+ 9178 ED 5A                                adc     hl,de                       ; aftert his hl will be 2's c
  12+ 917A C9                                   ret
  13+ 917B
  14+ 917B 5F           HLEquHLSgnPlusAusgn:    ld      e,a
  15+ 917C 7C                                   ld      a,h
  16+ 917D E6 7F                                and     SignMask8Bit
  17+ 917F 20 04                                jr      nz,.HLNegative              ; if HL is negative then do HL - A
  18+ 9181 7B           .HLPositive:            ld      a,e                         ; else its HL + A
  19+ 9182 ED 31                                add     hl,a
  20+ 9184 C9                                   ret
  21+ 9185              .HLNegative:            ClearSignBit    h                   ; Clear sign of HL
  21+ 9185 7C          >                        ld      a,h
  21+ 9186 E6 7F       >                        and     SignMask8Bit
  21+ 9188 67          >                        ld      h,a
  22+ 9189                                      NegHL                               ; and convert to 2's C
  22+ 9189 AF          >                    xor a
  22+ 918A 95          >                    sub l
  22+ 918B 6F          >                    ld l,a
  22+ 918C 9F          >                    sbc a,a
  22+ 918D 94          >                    sub h
  22+ 918E 67          >                    ld h,a
  23+ 918F 16 00                                ld      d,0
  24+ 9191                                      ClearCarryFlag
  24+ 9191 B7          >                        or a
  25+ 9192 ED 52                                sbc     hl,de                       ; now add a to -ve HL , add does not do 2's c
  26+ 9194 FA 9C 91                             jp      m,.FlipResult               ; if it was negative then its really positive
  27+ 9197                                      SetSignBit      h
  27+ 9197 7C          >                        ld      a,h
  27+ 9198 F6 80       >                        or      SignOnly8Bit
  27+ 919A 67          >                        ld      h,a
  28+ 919B C9                                   ret
  29+ 919C              .FlipResult:            NegHL                               ; so if -hl + A => HL - A => HL - DE is negative then the actual result is +ve
  29+ 919C AF          >                    xor a
  29+ 919D 95          >                    sub l
  29+ 919E 6F          >                    ld l,a
  29+ 919F 9F          >                    sbc a,a
  29+ 91A0 94          >                    sub h
  29+ 91A1 67          >                    ld h,a
  30+ 91A2 C9                                   ret
  31+ 91A3
  32+ 91A3
  33+ 91A3
  34+ 91A3              ; HL = HL (signed) + A (unsigned), uses HL, DE, A
  35+ 91A3 57           AddAusngToHLsng:        ld      d,a
  36+ 91A4 5C                                   ld      e,h
  37+ 91A5 7C                                   ld      a,h
  38+ 91A6 E6 7F                                and     SignMask8Bit
  39+ 91A8 67                                   ld      h,a
  40+ 91A9 7A                                   ld      a,d
  41+ 91AA ED 31                                add     hl,a
  42+ 91AC 7B                                   ld      a,e
  43+ 91AD E6 80                                and     SignOnly8Bit
  44+ 91AF B4                                   or      h
  45+ 91B0 C9                                   ret
  46+ 91B1              ; HL = A (unsigned) - HL (signed), uses HL, DE, BC, A
  47+ 91B1 44           HLEequAusngMinusHLsng:  ld      b,h
  48+ 91B2 4F                                   ld      c,a
  49+ 91B3 78                                   ld      a,b
  50+ 91B4 E6 80                                and     SignOnly8Bit
  51+ 91B6 20 08                                jr      nz,.DoAdd
  52+ 91B8 EB           .DoSubtract:            ex      de,hl               ; move hl into de
  53+ 91B9 26 00                                ld      h,0                 ; hl = a
  54+ 91BB 69                                   ld      l,c
  55+ 91BC                                      ClearCarryFlag
  55+ 91BC B7          >                        or a
  56+ 91BD ED 52                                sbc     hl,de               ; hl = a - hl
  57+ 91BF C9                                   ret
  58+ 91C0 79           .DoAdd:                 ld      a,c
  59+ 91C1 ED 31                                add hl,a
  60+ 91C3 C9                                   ret
  61+ 91C4              ;tested mathstestsun2
  62+ 91C4              ; DEL = DEL + BCH signed, uses BC, DE, HL, IY, A
  63+ 91C4 78           AddBCHtoDELsigned:      ld      a,b                 ; Are the values both the same sign?
  64+ 91C5 AA                                   xor     d                   ; .
  65+ 91C6 E6 80                                and     SignOnly8Bit        ; .
  66+ 91C8 20 19                                jr      nz,.SignDifferent   ; .
  67+ 91CA 78           .SignSame:              ld      a,b                 ; if they are then we only need 1 signe
  68+ 91CB E6 80                                and     SignOnly8Bit        ; so store it in iyh
  69+ 91CD FD 67                                ld      iyh,a               ;
  70+ 91CF 78                                   ld      a,b                 ; bch = abs bch
  71+ 91D0 E6 7F                                and     SignMask8Bit        ; .
  72+ 91D2 47                                   ld      b,a                 ; .
  73+ 91D3 7A                                   ld      a,d                 ; del = abs del
  74+ 91D4 E6 7F                                and     SignMask8Bit        ; .
  75+ 91D6 57                                   ld      d,a                 ; .
  76+ 91D7 7C                                   ld      a,h                 ; l = h + l
  77+ 91D8 85                                   add     l                   ; .
  78+ 91D9 6F                                   ld      l,a                 ; .
  79+ 91DA 79                                   ld      a,c                 ; e = e + c + carry
  80+ 91DB 8B                                   adc     e                   ; .
  81+ 91DC 5F                                   ld      e,a                 ; .
  82+ 91DD 78                                   ld      a,b                 ; d = b + d + carry (signed)
  83+ 91DE 8A                                   adc     d                   ;
  84+ 91DF FD B4                                or      iyh                 ; d = or back in sign bit
  85+ 91E1 57                                   ld      d,a                 ;
  86+ 91E2 C9                                   ret                         ; done
  87+ 91E3 78           .SignDifferent:         ld      a,b                 ; bch = abs bch
  88+ 91E4 FD 67                                ld      iyh,a               ; iyh = b sign
  89+ 91E6 E6 7F                                and     SignMask8Bit        ; .
  90+ 91E8 47                                   ld      b,a                 ; .
  91+ 91E9 7A                                   ld      a,d                 ; del = abs del
  92+ 91EA FD 6F                                ld      iyl,a               ; iyl = d sign
  93+ 91EC E6 7F                                and     SignMask8Bit        ; .
  94+ 91EE 57                                   ld      d,a                 ; .
  95+ 91EF E5                                   push    hl                  ; hl = bc - de
  96+ 91F0 60 69                                ld      hl,bc               ; if bc < de then there is a carry
  97+ 91F2 ED 52                                sbc     hl,de               ;
  98+ 91F4 E1                                   pop     hl                  ;
  99+ 91F5 38 0E                                jr      c,.BCHltDEL
 100+ 91F7 20 1C                                jr      nz,.DELltBCH        ; if the result was not zero then DEL > BCH
 101+ 91F9 7C           .BCeqDE:                ld      a,h                 ; if the result was zero then check lowest bits
 102+ 91FA                                      JumpIfALTNusng l,.BCHltDEL
 102+ 91FA BD          >                        cp      l
 102+ 91FB DA 05 92    >                        jp		c, .BCHltDEL
 103+ 91FE 20 15                                jr      nz,.DELltBCH
 104+ 9200              ; The same so its just zero
 105+ 9200 AF           .BCHeqDEL:              xor     a                  ; its just zero
 106+ 9201 57                                   ld      d,a                ; .
 107+ 9202 5F                                   ld      e,a                ; .
 108+ 9203 6F                                   ld      l,a                ; .
 109+ 9204 C9                                   ret                        ; .
 110+ 9205              ;BCH is less than DEL so its DEL - BCH the sort out sign
 111+ 9205 7D           .BCHltDEL:              ld      a,l                ; l = l - h                      ; ex
 112+ 9206 94                                   sub     h                  ; .                              ;   01D70F DEL
 113+ 9207 6F                                   ld      l,a                ; .                              ;  -000028 BCH
 114+ 9208 7B                                   ld      a,e                ; e = e - c - carry              ;1.
 115+ 9209 99                                   sbc     c                  ; .                              ;
 116+ 920A 5F                                   ld      e,a                ; .                              ;
 117+ 920B 7A                                   ld      a,d                ; d = d - b - carry              ;
 118+ 920C 98                                   sbc     b                  ; .                              ;
 119+ 920D 57                                   ld      d,a                ; .                              ;
 120+ 920E FD 7D                                ld      a,iyl              ; as d was larger, take d sign
 121+ 9210 E6 80                                and     SignOnly8Bit       ;
 122+ 9212 B2                                   or      d                  ;
 123+ 9213 57                                   ld      d,a                ;
 124+ 9214 C9                                   ret
 125+ 9215 7C           .DELltBCH:              ld      a,h                ; l = h - l
 126+ 9216 95                                   sub     l                  ;
 127+ 9217 6F                                   ld      l,a                ;
 128+ 9218 79                                   ld      a,c                ; e = c - e - carry
 129+ 9219 9B                                   sbc     e                  ;
 130+ 921A 5F                                   ld      e,a                ;
 131+ 921B 78                                   ld      a,b                ; d = b - d - carry
 132+ 921C 9A                                   sbc     d                  ;
 133+ 921D 57                                   ld      d,a                ;
 134+ 921E FD 7C                                ld      a,iyh              ; as b was larger, take b sign into d
 135+ 9220 E6 80                                and     SignOnly8Bit       ;
 136+ 9222 B2                                   or      d                  ;
 137+ 9223 57                                   ld      d,a                ;
 138+ 9224 C9                                   ret
 139+ 9225
 140+ 9225
 141+ 9225              ;BHL = AHL + DE where AHL = 16 bit + A sign and DE = 15 bit signed
 142+ 9225 47           AddAHLtoDEsigned:       ld      b,a                     ; B = A , C = D (save sign bytes)
 143+ 9226 4A                                   ld      c,d                     ; .
 144+ 9227 A9                                   xor     c                       ; A = A xor C
 145+ 9228 CB BA                                res     7,d                     ; clear sign bit of D
 146+ 922A 20 02                                jr nz,  .OppositeSigns          ; if A xor C is opposite signs job to A0A1
 147+ 922C 19                                   add     hl,de                   ; HL = HL + DE
 148+ 922D C9                                   ret                             ; return
 149+ 922E ED 52        .OppositeSigns:         sbc     hl,de                   ; HL = HL -DE
 150+ 9230 D0                                   ret     nc                      ; if no carry return
 151+ 9231 19                                   add     hl,de                   ; else HL = HL + DE
 152+ 9232 EB                                   ex      de,hl                   ;      swap HL and DE
 153+ 9233 A7                                   and     a                       ;      reset carry
 154+ 9234 ED 52                                sbc     hl,de                   ;      HL = DE - HL (as they were swapped)
 155+ 9236 41                                   ld      b,c                     ;      B = sign of C
 156+ 9237 C9                                   ret                             ;      ret
 157+ 9238
 158+ 9238
 159+ 9238
 160+ 9238              ; a = value to add
 161+ 9238              ; b = offset (equivalent to regX)
 162+ 9238              ; returns INWK [x] set to new value
 163+ 9238              addINWKbasigned:
 164+ 9238 21 00 00     		ld 		hl,UBnKxlo                  ; hl = INWK 0
 165+ 923B 4F           		ld      c,a                         ; preserve a
 166+ 923C 78           		ld		a,b
 167+ 923D ED 31        		add		hl,a                        ; hl = INWK[x]
 168+ 923F 79                   ld      a,c                         ; get back a value
 169+ 9240 E6 80                and     $80                         ; get sign bit from a
 170+ 9242 47                   ld      b,a                         ; now b = sign bit of a
 171+ 9243 79                   ld      a,c                         ; a = original value
 172+ 9244 E6 7F                and     SignMask8Bit                ; a = unsigned version of original value
 173+ 9246              ; hl = unsigned version of INWK0[b]
 174+ 9246              ; a = value to add, also in c which will optimise later code
 175+ 9246              ; b = sign bit of a ( in old code was varT)
 176+ 9246              addhlcsigned:
 177+ 9246 5E                   ld      e,(hl)                      ; de = INKK value
 178+ 9247 23                   inc     hl
 179+ 9248 56                   ld      d,(hl)
 180+ 9249 23                   inc     hl                          ; now pointing a sign
 181+ 924A 7E                   ld      a,(hl)                      ; a = sign bit
 182+ 924B EB                   ex      de,hl                       ; hl = value now and de = pointer to sign
 183+ 924C A8                   xor     b                           ; a = resultant sign
 184+ 924D CB 7F                bit     7,a                         ; is it negative?
 185+ 924F 28 28                jr      z,.postivecalc
 186+ 9251              .negativecalc:
 187+ 9251 7C                   ld      a,h
 188+ 9252 E6 7F                and     SignMask8Bit
 189+ 9254 67                   ld      h,a                         ; strip high bit
 190+ 9255 DD 68                ld      ixl,b                       ; save sign bit from b into d
 191+ 9257 06 00                ld      b,0                         ; c = value to subtract so now bc = value to subtract
 192+ 9259 ED 42                sbc     hl,bc
 193+ 925B DD 45                ld      b,ixl                       ; get sign back
 194+ 925D EB                   ex      de,hl                       ; de = value hl = pointer to sign
 195+ 925E 7E                   ld      a,(hl)                      ;
 196+ 925F E6 7F                and     SignMask8Bit
 197+ 9261 DE 00                sbc     a,0                         ; subtract carry which could flip sign bit
 198+ 9263 F6 80                or      $80                         ; set bit 0
 199+ 9265 A8                   xor     b                           ; flip bit on sign (var T)
 200+ 9266 77                   ld      (hl),a
 201+ 9267 2B                   dec     hl
 202+ 9268 72                   ld      (hl),d
 203+ 9269 2B                   dec     hl
 204+ 926A 73                   ld      (hl),e                      ; write out DE to INKW[x]0,1
 205+ 926B EB                   ex      de,hl                       ; hl = value de = pointer to start if INKW[x]
 206+ 926C D8                   ret     c                           ; if carry was set then we can exit now
 207+ 926D              .nocarry:
 208+ 926D CD 6B 97             call    negate16hl                  ; get hl back to positive, a is still inkw+2
 209+ 9270 B0                   or      b                           ; b is still varT
 210+ 9271 EB                   ex      de,hl                       ; de = value hl = pointer to start if INKW[x]
 211+ 9272 73                   ld      (hl),e
 212+ 9273 23                   inc     hl
 213+ 9274 72                   ld      (hl),d
 214+ 9275 23                   inc     hl
 215+ 9276 77                   ld      (hl),a                      ; set sign bit in INKK[x]+2
 216+ 9277 EB                   ex      de,hl                       ; hl = value de = pointer to sign
 217+ 9278 C9                   ret
 218+ 9279              .postivecalc:
 219+ 9279 DD 68                ld      ixl,b
 220+ 927B 06 00                ld      b,0
 221+ 927D 19                   add     hl,de
 222+ 927E EB                   ex      de,hl
 223+ 927F DD B5                or      ixl                         ; we don;t need to recover b here
 224+ 9281 77                   ld      (hl),a                      ; push sign into INWK[x]
 225+ 9282 2B                   dec     hl
 226+ 9283 72                   ld      (hl),d
 227+ 9284 2B                   dec     hl
 228+ 9285 73                   ld      (hl),e
 229+ 9286 C9                   ret
 230+ 9287
 231+ 9287              ;a = a AND 80 (i.e. bit 7) =>carry       so value is -
 232+ 9287              ;MVT1
 233+ 9287              ;    S = bits 6 to 0 of A
 234+ 9287              ;    A = sign bit => T
 235+ 9287              ;    xor sign bit with ink[x] Sign
 236+ 9287              ;    if negative thn its not an add
 237+ 9287              ;
 238+ 9287              ;        and h, 7F
 239+ 9287              ;        b = 0
 240+ 9287              ;        c = varS
 241+ 9287              ;        subtract INW[X]hilo, bc
 242+ 9287              ;        retain carry
 243+ 9287              ;        get INKW[x]Sign
 244+ 9287              ;        and 7F
 245+ 9287              ;        subtract carry (so will go negtive if negative)
 246+ 9287              ;        xor bit 7 of h with T to flip bit
 247+ 9287              ;        write to INKW[x]Sign
 248+ 9287              ;
 249+ 9287              ;    else
 250+ 9287              ;MV10.
 251+ 9287              ;        add INWK[x]hi,lo, varS
 252+ 9287              ;        or      sign bit
 253+ 9287
 254+ 9287
# file closed: ./Maths/asm_add.asm
 129  9287                  INCLUDE "./Maths/Utilities/AddDEToCash.asm"
# file opened: ./Maths/Utilities/AddDEToCash.asm
   1+ 9287              ; Note its big endian
   2+ 9287 2A 72 88     addDEtoCash:            ld      hl,(Cash)
   3+ 928A 19                                   add     hl,de
   4+ 928B 22 72 88                             ld      (Cash),hl
   5+ 928E 11 00 00                             ld      de,0
   6+ 9291 2A 74 88                             ld      hl,(Cash+2)
   7+ 9294 ED 5A                                adc     hl,de
   8+ 9296 22 74 88                             ld      (Cash+2),hl
   9+ 9299 C9                                   ret
  10+ 929A
  11+ 929A 2A 72 88     subDEfromCash:          ld      hl,(Cash)
  12+ 929D 7C                                   ld      a,h
  13+ 929E B5                                   or      l
  14+ 929F 2A 74 88                             ld      hl,(Cash+2)
  15+ 92A2 B4                                   or      h
  16+ 92A3 B5                                   or      l
  17+ 92A4 C8                                   ret     z               ; No cash return
  18+ 92A5 B7                                   or      a
  19+ 92A6 2A 72 88                             ld      hl,(Cash)
  20+ 92A9 ED 52                                sbc     hl,de
  21+ 92AB 22 72 88                             ld      (Cash),hl
  22+ 92AE 11 00 00                             ld      de,0
  23+ 92B1 2A 74 88                             ld      hl,(Cash+2)
  24+ 92B4 ED 52                                sbc     hl,de
  25+ 92B6 22 74 88                             ld      (Cash+2),hl
  26+ 92B9                                      JumpOnBitSet h,7,.ZeroCash
  26+ 92B9 CB 7C       >                        bit 	7,h
  26+ 92BB C2 BF 92    >                        jp      nz,.ZeroCash
  27+ 92BE C9                                   ret
  28+ 92BF 21 00 00     .ZeroCash:              ld      hl,0
  29+ 92C2 22 72 88                             ld      (Cash),hl
  30+ 92C5 22 74 88                             ld      (Cash+2),hl
  31+ 92C8 C9                                   ret
  32+ 92C9
# file closed: ./Maths/Utilities/AddDEToCash.asm
 130  92C9                  INCLUDE "./Maths/DIVD3B2.asm"
# file opened: ./Maths/DIVD3B2.asm
   1+ 92C9              ;INPUTS: ahl = dividend cde = divisor
   2+ 92C9              ;OUTPUTS: cde = quotient ahl = remainder
   3+ 92C9 47           Div24by24:              ld b,a
   4+ 92CA E5                                   push hl
   5+ 92CB DD E1                                pop ix
   6+ 92CD 2E 18                                ld l,24
   7+ 92CF E5                                   push hl
   8+ 92D0 AF                                   xor a
   9+ 92D1 67                                   ld h,a
  10+ 92D2 6F                                   ld l,a
  11+ 92D3 DD 29        .Div24by24loop:         add ix,ix
  12+ 92D5 CB 10                                rl b
  13+ 92D7 ED 6A                                adc hl,hl
  14+ 92D9 17                                   rla
  15+ 92DA B9                                   cp c
  16+ 92DB 38 0C                                jr c,.Div24by24skip
  17+ 92DD 20 05                                jr nz,.Div24by24setbit
  18+ 92DF ED 52                                sbc hl,de
  19+ 92E1 19                                   add hl,de
  20+ 92E2 38 05                                jr c,.Div24by24skip
  21+ 92E4 ED 52        .Div24by24setbit:       sbc hl,de
  22+ 92E6 99                                   sbc a,c
  23+ 92E7 DD 23                                inc ix
  24+ 92E9 E3           .Div24by24skip:         ex (sp),hl
  25+ 92EA 2D                                   dec l
  26+ 92EB E3                                   ex (sp),hl
  27+ 92EC 20 E5                                jr nz,.Div24by24loop
  28+ 92EE D1                                   pop de
  29+ 92EF 48                                   ld c,b
  30+ 92F0 DD E5                                push ix
  31+ 92F2 D1                                   pop de
  32+ 92F3 C9                                   ret
  33+ 92F4
  34+ 92F4 FD 67        Div24by24ASigned:       ld      iyh,a
  35+ 92F6 E6 7F                                and     SignMask8Bit
  36+ 92F8 CD C9 92                             call    Div24by24
  37+ 92FB F5                                   push    af
  38+ 92FC FD 7C                                ld      a,iyh
  39+ 92FE E6 80                                and     SignOnly8Bit
  40+ 9300 B1                                   or      c
  41+ 9301 4F                                   ld      c,a
  42+ 9302 F1                                   pop     af
  43+ 9303 C9                                   ret
  44+ 9304
  45+ 9304                                      ; CDE = AHL/CDE, AHL = remainder
  46+ 9304 FD 67        Div24by24LeadSign:      ld      iyh,a           ; Preserve signed in IYL
  47+ 9306 A9                                   xor     c               ; flip sign if negative
  48+ 9307 E6 80                                and     SignOnly8Bit    ; .
  49+ 9309 FD 6F                                ld      iyl,a           ; .
  50+ 930B 79                                   ld      a,c             ; make both values ABS
  51+ 930C E6 7F                                and     SignMask8Bit    ; .
  52+ 930E 4F                                   ld      c,a             ; .
  53+ 930F FD 7C                                ld      a,iyh           ; .
  54+ 9311 E6 7F                                and     SignMask8Bit    ; .
  55+ 9313 CD C9 92                             call    Div24by24       ; do abs divide
  56+ 9316 FD B5                                or      iyl             ; bring in sign bit
  57+ 9318 FD 67                                ld      iyh,a           ; save a
  58+ 931A 79                                   ld      a,c             ; sort sign for c
  59+ 931B FD B5                                or      iyl             ;
  60+ 931D 4F                                   ld      c,a             ;
  61+ 931E FD 7C                                ld      a,iyh           ; sort sign of a
  62+ 9320 C9                                   ret
  63+ 9321
  64+ 9321              ; --------------------------------------------------------------
  65+ 9321              ;divdide by 16 using undocumented instrunctions
  66+ 9321              ;Input: BC = Dividend, DE = Divisor, HL = 0
  67+ 9321              ;Output: BC = Quotient, HL = Remainder
  68+ 9321 47           PROJ256mulAdivQ:        ld      b,a
  69+ 9322 0E 00                                ld      c,0
  70+ 9324 16 00                                ld      d,0
  71+ 9326 3A 66 84                             ld      a,(varQ)
  72+ 9329 5F                                   ld      e,a
  73+ 932A 21 00 00     PROJDIV16UNDOC:         ld      hl,0
  74+ 932D 78                                   ld      a,b
  75+ 932E 06 10                                ld      b,16
  76+ 9330 CB 31        PROJDIV16UNDOCLOOP:     sll     c       ; unroll 16 times
  77+ 9332 17                                   rla             ; ...
  78+ 9333 ED 6A                                adc     hl,hl       ; ...
  79+ 9335 ED 52                                sbc     hl,de       ; ...
  80+ 9337 30 02                                jr      nc,PROJDIV16UNDOCSKIP       ; ...
  81+ 9339 19                                   add     hl,de       ; ...
  82+ 933A 0D                                   dec     c       ; ...
  83+ 933B 10 F3        PROJDIV16UNDOCSKIP:     djnz    PROJDIV16UNDOCLOOP
  84+ 933D 79                                   ld      a,c
  85+ 933E 32 67 84                             ld      (varR),a
  86+ 9341 C9                                   ret
  87+ 9342
  88+ 9342
  89+ 9342
  90+ 9342
# file closed: ./Maths/DIVD3B2.asm
 131  9342                  INCLUDE "./Maths/multiply.asm"
# file opened: ./Maths/multiply.asm
   1+ 9342              HLequSRmulQdiv256:      ;X.Y=x1lo.S*M/256  	\ where M/256 is gradient
   2+ 9342 2A 67 84                             ld  hl,(varRS)
   3+ 9345 3A 66 84                             ld  a,(varQ)
   4+ 9348 C5 D5        HLeqyHLmulAdiv256:      push    bc,,de
   5+ 934A 11 00 00                             ld  de,0        ; de = XY
   6+ 934D 47                                   ld  b,a         ; b = Q
   7+ 934E                                      ShiftHLRight1
   7+ 934E CB 3C       >			   srl h
   7+ 9350 CB 1D       >			   rr  l
   8+ 9352 CB 20                                sla b
   9+ 9354 30 03                                jr  nc,.LL126
  10+ 9356 EB           .LL125:                 ex de,hl
  11+ 9357 19                                   add hl,de
  12+ 9358 EB                                   ex  de,hl       ; de = de + rs
  13+ 9359              .LL126:                 ShiftHLRight1
  13+ 9359 CB 3C       >			   srl h
  13+ 935B CB 1D       >			   rr  l
  14+ 935D CB 20                                sla b
  15+ 935F 38 F5                                jr      c,.LL125
  16+ 9361 20 F6                                jr      nz,.LL126
  17+ 9363 EB                                   ex      de,hl   ; hl = result
  18+ 9364 D1 C1                                pop     bc,,de
  19+ 9366 C9                                   ret
  20+ 9367
  21+ 9367
  22+ 9367              MacroDEEquQmulASigned:  MACRO
  23+ 9367 ~                                    ld      d,a                         ; save a into d
  24+ 9367 ~                                    ld      a,(varQ)
  25+ 9367 ~                                    ld      e,a
  26+ 9367 ~                                    xor     d                           ; a = a xor var Q
  27+ 9367 ~                                    and     SignOnly8Bit
  28+ 9367 ~                                    ld      b,a                         ; b = sign of a xor q
  29+ 9367 ~                                    ld      a,d                         ; d = abs d (or a reg)
  30+ 9367 ~                                    and     SignMask8Bit
  31+ 9367 ~                                    ld      d,a
  32+ 9367 ~                                    ld      a,e                         ; e = abs e (or varQ)
  33+ 9367 ~                                    and     SignMask8Bit
  34+ 9367 ~                                    ld      e,a
  35+ 9367 ~                                    mul                                 ; de = a * Q
  36+ 9367 ~                                    ld      a,d
  37+ 9367 ~                                    or      b                           ; de = a * Q leading sign bit
  38+ 9367 ~                                    ld      d,a
  39+ 9367                                      ENDM
  40+ 9367
  41+ 9367
  42+ 9367
  43+ 9367                                 ; .MAD	\ -> &22AD  \ Multiply and Add  (DE also) X.A(Lo.Hi) = Q*A + R.S (Lo.Hi)
  44+ 9367              madXAequQmulAaddRS:     MacroDEEquQmulASigned
  44+ 9367 57          >                        ld      d,a                         ; save a into d
  44+ 9368 3A 66 84    >                        ld      a,(varQ)
  44+ 936B 5F          >                        ld      e,a
  44+ 936C AA          >                        xor     d                           ; a = a xor var Q
  44+ 936D E6 80       >                        and     SignOnly8Bit
  44+ 936F 47          >                        ld      b,a                         ; b = sign of a xor q
  44+ 9370 7A          >                        ld      a,d                         ; d = abs d (or a reg)
  44+ 9371 E6 7F       >                        and     SignMask8Bit
  44+ 9373 57          >                        ld      d,a
  44+ 9374 7B          >                        ld      a,e                         ; e = abs e (or varQ)
  44+ 9375 E6 7F       >                        and     SignMask8Bit
  44+ 9377 5F          >                        ld      e,a
  44+ 9378 ED 30       >                        mul                                 ; de = a * Q
  44+ 937A 7A          >                        ld      a,d
  44+ 937B B0          >                        or      b                           ; de = a * Q leading sign bit
  44+ 937C 57          >                        ld      d,a
  45+ 937D 2A 67 84     madDEaddRS:             ld		hl,(varR)
  46+ 9380 CD 89 93                             call	madXAAddHLDESigned
  47+ 9383 EB                                   ex      de,hl                       ; de = R.S + DE
  48+ 9384                                      ClearCarryFlag
  48+ 9384 B7          >                        or a
  49+ 9385 DD 6B                                ld      ixl,e
  50+ 9387 7A                                   ld      a,d
  51+ 9388 C9                                   ret
  52+ 9389
  53+ 9389
  54+ 9389 7C           madXAAddHLDESigned:     ld      a,h
  55+ 938A E6 80                                and     SignOnly8Bit
  56+ 938C 47                                   ld      b,a                         ;save sign bit in b
  57+ 938D AA                                   xor     d                           ;if h sign and d sign were different then bit 7 of a will be 1 which means
  58+ 938E                                      JumpIfNegative .ADDHLDEOppSGN        ;Signs are opposite there fore we can subtract to get difference
  58+ 938E FA A6 93    >                        jp		m, .ADDHLDEOppSGN
  59+ 9391 78           .ADDHLDESameSigns:       ld      a,b
  60+ 9392 B2                                   or      d
  61+ 9393                                      JumpIfNegative .ADDHLDESameNeg       ; optimisation so we can just do simple add if both positive
  61+ 9393 FA 98 93    >                        jp		m, .ADDHLDESameNeg
  62+ 9396 19                                   add     hl,de
  63+ 9397 C9                                   ret
  64+ 9398 7C           .ADDHLDESameNeg:         ld      a,h                         ; so if we enter here then signs are the same so we clear the 16th bit
  65+ 9399 E6 7F                                and     SignMask8Bit                ; we could check the value of b for optimisation
  66+ 939B 67                                   ld      h,a
  67+ 939C 7A                                   ld      a,d
  68+ 939D E6 7F                                and     SignMask8Bit
  69+ 939F 57                                   ld      d,a
  70+ 93A0 19                                   add     hl,de
  71+ 93A1 3E 80                                ld      a,SignOnly8Bit
  72+ 93A3 B4                                   or      h                           ; now set bit for negative value, we won't bother with overflow for now TODO
  73+ 93A4 67                                   ld      h,a
  74+ 93A5 C9                                   ret
  75+ 93A6 7C           .ADDHLDEOppSGN:          ld      a,h                         ; so if we enter here then signs are the same so we clear the 16th bit                     ; here HL and DE are opposite
  76+ 93A7 E6 7F                                and     SignMask8Bit                ; we could check the value of b for optimisation
  77+ 93A9 67                                   ld      h,a
  78+ 93AA 7A                                   ld      a,d
  79+ 93AB E6 7F                                and     SignMask8Bit
  80+ 93AD 57                                   ld      d,a
  81+ 93AE B7                                   or      a
  82+ 93AF ED 52                                sbc     hl,de
  83+ 93B1 38 04                                jr      c,.ADDHLDEOppInvert
  84+ 93B3 78           .ADDHLDEOppSGNNoCarry:   ld      a,b                         ; we got here so hl > de therefore we can just take hl's previous sign bit
  85+ 93B4 B4                                   or      h
  86+ 93B5 67                                   ld      h,a                         ; set the previou sign value
  87+ 93B6 C9                                   ret
  88+ 93B7              .ADDHLDEOppInvert:       NegHL                                                   ; we need to flip the sign and 2'c the Hl result
  88+ 93B7 AF          >                    xor a
  88+ 93B8 95          >                    sub l
  88+ 93B9 6F          >                    ld l,a
  88+ 93BA 9F          >                    sbc a,a
  88+ 93BB 94          >                    sub h
  88+ 93BC 67          >                    ld h,a
  89+ 93BD 78                                   ld      a,b
  90+ 93BE EE 80                                xor     SignOnly8Bit                ; flip sign bit
  91+ 93C0 B4                                   or      h
  92+ 93C1 67                                   ld      h,a                         ; recover sign
  93+ 93C2 C9                                   ret
  94+ 93C3
  95+ 93C3
  96+ 93C3                  ; multiplication of 16-bit number and 8-bit number into a 24-bit product
  97+ 93C3                  ;
  98+ 93C3                  ; enter : hl = 16-bit multiplier   = x
  99+ 93C3                  ;          e =  8-bit multiplicand = y
 100+ 93C3                  ;
 101+ 93C3                  ; exit  : ahl = 24-bit product
 102+ 93C3                  ;         carry reset
 103+ 93C3                  ;
 104+ 93C3                  ; uses  : af, de, hl
 105+ 93C3 54           AHLequHLmulE:           ld d,h                      ; xh
 106+ 93C4 63                                   ld h,e                      ; yl
 107+ 93C5 ED 30                                mul de                      ; xh*yl
 108+ 93C7 EB                                   ex de,hl
 109+ 93C8 ED 30                                mul de                      ; yl*xl, hl = xh*yl
 110+ 93CA
 111+ 93CA 7A                                   ld  a,d                     ; sum products
 112+ 93CB 85                                   add a,l
 113+ 93CC 57                                   ld  d,a
 114+ 93CD EB                                   ex de,hl
 115+ 93CE
 116+ 93CE 7A                                   ld  a,d
 117+ 93CF CE 00                                adc a,0
 118+ 93D1 C9                                   ret
 119+ 93D2
 120+ 93D2
 121+ 93D2
 122+ 93D2                 ; multiplication of two 16-bit numbers into a 32-bit product
 123+ 93D2                 ;
 124+ 93D2                 ; enter : de = 16-bit multiplicand = y
 125+ 93D2                 ;         hl = 16-bit multiplicand = x
 126+ 93D2                 ;
 127+ 93D2                 ; exit  : dehl = 32-bit product
 128+ 93D2                 ;         carry reset
 129+ 93D2                 ;
 130+ 93D2                 ; uses  : af, bc, de, hl
 131+ 93D2
 132+ 93D2
 133+ 93D2
 134+ 93D2 45           DEHLequDEmulHL:         ld b,l                      ; x0
 135+ 93D3 4B                                   ld c,e                      ; y0
 136+ 93D4 5D                                   ld e,l                      ; x0
 137+ 93D5 6A                                   ld l,d
 138+ 93D6 E5                                   push hl                     ; x1 y1
 139+ 93D7 69                                   ld l,c                      ; y0
 140+ 93D8              ; bc = x0 y0, de = y1 x0,  hl = x1 y0,  stack = x1 y1
 141+ 93D8 ED 30                                mul de                      ; y1*x0
 142+ 93DA EB                                   ex de,hl
 143+ 93DB ED 30                                mul de                      ; x1*y0
 144+ 93DD
 145+ 93DD AF                                   xor a                       ; zero A
 146+ 93DE 19                                   add hl,de                   ; sum cross products p2 p1
 147+ 93DF 8F                                   adc a,a                     ; capture carry p3
 148+ 93E0
 149+ 93E0 59                                   ld e,c                      ; x0
 150+ 93E1 50                                   ld d,b                      ; y0
 151+ 93E2 ED 30                                mul de                      ; y0*x0
 152+ 93E4
 153+ 93E4 47                                   ld b,a                      ; carry from cross products
 154+ 93E5 4C                                   ld c,h                      ; LSB of MSW from cross products
 155+ 93E6
 156+ 93E6 7A                                   ld a,d
 157+ 93E7 85                                   add a,l
 158+ 93E8 67                                   ld h,a
 159+ 93E9 6B                                   ld l,e                      ; LSW in HL p1 p0
 160+ 93EA
 161+ 93EA D1                                   pop de
 162+ 93EB ED 30                                mul de                      ; x1*y1
 163+ 93ED
 164+ 93ED EB                                   ex de,hl
 165+ 93EE ED 4A                                adc hl,bc
 166+ 93F0 EB                                   ex de,hl                    ; de = final MSW
 167+ 93F1
 168+ 93F1 C9                                   ret
 169+ 93F2
 170+ 93F2              ; multiplication of two 16-bit numbers into a 16-bit product
 171+ 93F2              ; enter : de = 16-bit multiplicand
 172+ 93F2              ;         hl = 16-bit multiplicand
 173+ 93F2              ; exit  : hl = 16-bit product
 174+ 93F2              ;         carry reset
 175+ 93F2              ; maths is
 176+ 93F2              ;        hl = y , de= x
 177+ 93F2              ;        hl = xhi,ylo + (yhigh * xlow)
 178+ 93F2              ;        hl = yhih & xlo + x
 179+ 93F2              ;
 180+ 93F2              ;
 181+ 93F2              ; uses  : af, bc, de, hl
 182+ 93F2 C5           mulDEbyHL:              push    bc
 183+ 93F3 7A                                   ld a,d                      ; a = xh
 184+ 93F4 54                                   ld d,h                      ; d = yh
 185+ 93F5 67                                   ld h,a                      ; h = xh
 186+ 93F6 4B                                   ld c,e                      ; c = xl
 187+ 93F7 45                                   ld b,l                      ; b = yl
 188+ 93F8 ED 30                                mul                         ; yh * yl
 189+ 93FA EB                                   ex de,hl
 190+ 93FB ED 30                                mul                         ; xh * yl
 191+ 93FD 19                                   add hl,de                   ; add cross products
 192+ 93FE 59                                   ld e,c
 193+ 93FF 50                                   ld d,b
 194+ 9400 ED 30                                mul                         ; yl * xl
 195+ 9402 7D                                   ld a,l                      ; cross products lsb
 196+ 9403 82                                   add a,d                     ; add to msb final
 197+ 9404 67                                   ld h,a
 198+ 9405 6B                                   ld l,e                      ; hl = final
 199+ 9406                                      ; 83 cycles, 19 bytes
 200+ 9406 AF                                   xor a                       ; reset carry
 201+ 9407 C1                                   pop     bc
 202+ 9408 C9                                   ret
 203+ 9409
 204+ 9409
 205+ 9409              ; CHL = multiplicand D = multiplier
 206+ 9409              ; DCHL = CHL * D
 207+ 9409 7A           mulCHLbyDSigned:        ld      a,d                 ; get sign from d
 208+ 940A AC                                   xor     h                   ; xor with h to get resultant sign
 209+ 940B E6 80                                and     SignOnly8Bit        ; .
 210+ 940D FD 67                                ld      iyh,a               ; iyh = copy of sign
 211+ 940F 79                                   ld      a,c                 ; now CHL = ABS (CHL)
 212+ 9410 E6 7F                                and     SignMask8Bit        ; .
 213+ 9412 4F                                   ld      c,a                 ; .
 214+ 9413 7A                                   ld      a,d                 ; d = ABS D
 215+ 9414 E6 7F                                and     SignMask8Bit        ; .
 216+ 9416              ; At this point CHL = ABS (HLE), A = ABS(D)
 217+ 9416 57           .mul1:                  ld      d,a                 ; first do D * L
 218+ 9417 5D                                   ld      e,l                 ; .
 219+ 9418 ED 30                                mul     de                  ; DE = L * D
 220+ 941A 08                                   ex      af,af'              ; save multiplier
 221+ 941B 6B                                   ld      l,e                 ; L = p0
 222+ 941C 7A                                   ld      a,d                 ; carry byte
 223+ 941D 08                                   ex      af,af'              ; retrieve muliplier and save carry byte along with flags
 224+ 941E 5C           .mul2:                  ld      e,h                 ; byte 2 of multiplicand
 225+ 941F 57                                   ld      d,a                 ; and multiplier
 226+ 9420 ED 30                                mul     de                  ; now its D & L
 227+ 9422 08                                   ex      af,af'              ; get back carry byte with flags
 228+ 9423 83           .carrybyte1:            add     a,e                 ; add low byte carry to result and retain carry too through next instructions
 229+ 9424 67                                   ld      h,a                 ; h = P1
 230+ 9425 7A                                   ld      a,d                 ; a = carry byte
 231+ 9426 08                                   ex      af,af'              ; save carry byte and get back multiplier with flags
 232+ 9427 59           .mul3:                  ld      e,c                 ; byte 3 of multiplicand
 233+ 9428 57                                   ld      d,a                 ;
 234+ 9429 ED 30                                mul     de                  ;
 235+ 942B 08                                   ex      af,af'              ; get back carry byte and carry prior to first add
 236+ 942C 8B                                   adc     a,e                 ;
 237+ 942D FD B4                                or      iyh                 ; recover saved resultant sign
 238+ 942F 4F                                   ld      c,a                 ; c byte 3. Note the value range allowed can never cause a byte 3 carry
 239+ 9430 C9                                   ret
 240+ 9431
 241+ 9431              ;  CHL = 53456 D = 1E
 242+ 9431              ;  56 * 1E = A14 L = 14 carry = 0A
 243+ 9431              ;  34 * 1E = 618 H = 18 +A = 22 carry = 6
 244+ 9431              ;  5  * 1E = 096 C = 96 + 6 = 9C
 245+ 9431              ;  CHL = 9C2214
 246+ 9431
 247+ 9431              ; DELC = HLE * D, uses HL, DE, C , A , IYH
 248+ 9431              ; HLE = multiplicand D = multiplier
 249+ 9431              ; tested by mathstestsun.asm all passed
 250+ 9431 7A           mulHLEbyDSigned:        ld      a,d                 ; get sign from d
 251+ 9432 AC                                   xor     h                   ; xor with h to get resultant sign
 252+ 9433 E6 80                                and     SignOnly8Bit        ; .
 253+ 9435 FD 67                                ld      iyh,a               ; iyh = copy of sign
 254+ 9437 7C                                   ld      a,h                 ; now HLE = ABS (HLE)
 255+ 9438 E6 7F                                and     SignMask8Bit        ; .
 256+ 943A 67                                   ld      h,a                 ; .
 257+ 943B 7A                                   ld      a,d                 ; d = ABS D
 258+ 943C E6 7F                                and     SignMask8Bit        ; .
 259+ 943E 57                                   ld      d,a                 ; .
 260+ 943F              ; At this point HLE = ABS (HLE), A = ABS(D)
 261+ 943F ED 30        .mul1:                  mul     de                  ; C = E * D
 262+ 9441 08                                   ex      af,af'              ; save mulitplier
 263+ 9442 4B                                   ld      c,e                 ; C = p0
 264+ 9443 7A                                   ld      a,d                 ; save carry and get back multiplier
 265+ 9444 08                                   ex      af,af'
 266+ 9445 5D           .mul2:                  ld      e,l                 ; L = L * D
 267+ 9446 57                                   ld      d,a                 ; .
 268+ 9447 ED 30                                mul     de                  ; .
 269+ 9449 08                                   ex      af,af'              ; .
 270+ 944A 83           .carrybyte1:            add     a,e                 ; L = L + carry byte
 271+ 944B 6F                                   ld      l,a                 ; .
 272+ 944C 7A                                   ld      a,d
 273+ 944D 08                                   ex      af,af'              ; save new carry byte
 274+ 944E 5C           .mul3:                  ld      e,h                 ; e = H * D
 275+ 944F 57                                   ld      d,a
 276+ 9450 ED 30                                mul     de
 277+ 9452 08                                   ex      af,af'
 278+ 9453 8B                                   adc     a,e                 ;
 279+ 9454 5F                                   ld      e,a
 280+ 9455 FD 54                                ld      d,iyh
 281+ 9457 C9                                   ret
 282+ 9458
 283+ 9458
 284+ 9458              ; multiplication of two S156-bit numbers into a 16-bit 2'd compliment product
 285+ 9458              ; enter : de = 16-bit multiplicand
 286+ 9458              ;         hl = 16-bit multiplicand
 287+ 9458              ; exit  : hl = 16-bit product
 288+ 9458              ;         carry reset
 289+ 9458              ;
 290+ 9458              ; uses  : af, bc, de, hl
 291+ 9458 00           mulDEbyHLSignByte       DB      0
 292+ 9459 AF           mulDEbyHLSgnTo2c:       xor     a
 293+ 945A 32 58 94                             ld      (mulDEbyHLSignByte),a
 294+ 945D 7A           .SignDE:                ld      a,d
 295+ 945E ED 27 80                             test    $80
 296+ 9461 28 08                                jr      z,.SignHL
 297+ 9463 E6 7F        .NegativeDE:            and     $7F
 298+ 9465 57                                   ld      d,a
 299+ 9466 3E 80                                ld      a,$80
 300+ 9468 32 58 94                             ld      (mulDEbyHLSignByte),a
 301+ 946B 7C           .SignHL:                ld      a,h
 302+ 946C ED 27 80                             test    $80
 303+ 946F 28 0B                                jr      z,.AbsoluteMultiply
 304+ 9471 E6 7F        .NegativeHL:            and     $7F
 305+ 9473 67                                   ld      h,a
 306+ 9474 3A 58 94                             ld      a,(mulDEbyHLSignByte)
 307+ 9477 EE 80                                xor     $80
 308+ 9479 32 58 94                             ld      (mulDEbyHLSignByte),a
 309+ 947C CD F2 93     .AbsoluteMultiply:      call    mulDEbyHL
 310+ 947F 3A 58 94     .RecoverSign:           ld      a,(mulDEbyHLSignByte)
 311+ 9482 ED 27 80                             test    $80
 312+ 9485 C8                                   ret     z
 313+ 9486 AF           .Negateghl: 			xor 	a
 314+ 9487 95                                   sub 	l
 315+ 9488 6F                                   ld 		l,a
 316+ 9489 9F                                   sbc 	a,a
 317+ 948A 94                                   sub 	h
 318+ 948B 67                                   ld 		h,a
 319+ 948C C9                                   ret
 320+ 948D
 321+ 948D AF           mulDESgnbyHLUnsgnTo2c:  xor     a
 322+ 948E 32 58 94                             ld      (mulDEbyHLSignByte),a
 323+ 9491 7A           .SignDE:                ld      a,d
 324+ 9492 ED 27 80                             test    $80
 325+ 9495 28 08                                jr      z,.AbsoluteMultiply
 326+ 9497 E6 7F        .NegativeDE:            and     $7F
 327+ 9499 57                                   ld      d,a
 328+ 949A 3E 80                                ld      a,$80
 329+ 949C 32 58 94                             ld      (mulDEbyHLSignByte),a
 330+ 949F CD F2 93     .AbsoluteMultiply:      call    mulDEbyHL
 331+ 94A2 3A 58 94     .RecoverSign:           ld      a,(mulDEbyHLSignByte)
 332+ 94A5 ED 27 80                             test    $80
 333+ 94A8 C8                                   ret     z
 334+ 94A9 AF           .Negateghl:             xor 	a
 335+ 94AA 95                                   sub 	l
 336+ 94AB 6F                                   ld 		l,a
 337+ 94AC 9F                                   sbc 	a,a
 338+ 94AD 94                                   sub 	h
 339+ 94AE 67                                   ld 		h,a
 340+ 94AF C9                                   ret
 341+ 94B0
 342+ 94B0
# file closed: ./Maths/multiply.asm
 132  94B0                  INCLUDE "./Maths/asm_square.asm"
# file opened: ./Maths/asm_square.asm
   1+ 94B0              ; "ASM_SQUA : TESTGOOD"
   2+ 94B0              ; "AP = A^2 A = low,P = hi"
   3+ 94B0
   4+ 94B0              inline_squde: MACRO
   5+ 94B0 ~            			ld	e,a
   6+ 94B0 ~            			ld  d,a
   7+ 94B0 ~            			mul
   8+ 94B0              			ENDM
   9+ 94B0
  10+ 94B0              inline_squa: MACRO
  11+ 94B0 ~            			ld	e,a
  12+ 94B0 ~            			ld  d,a
  13+ 94B0 ~            			mul
  14+ 94B0 ~            			ld	a,e
  15+ 94B0              			ENDM
  16+ 94B0
  17+ 94B0
  18+ 94B0              asm_squa:
  19+ 94B0 E6 7F        	and SignMask8Bit
  20+ 94B2              ; "ASM SQUA2 : TESTGOOD"
  21+ 94B2              ; "AP = A^2 A = low,P = hi singed"
  22+ 94B2              asm_squa2:
  23+ 94B2 5F           	ld e, a
  24+ 94B3 57           	ld d,a
  25+ 94B4 ED 30        	mul
  26+ 94B6 ED 53 63 83  	ld (varP),de
  27+ 94BA 7B           	ld a,e
  28+ 94BB C9           	ret
# file closed: ./Maths/asm_square.asm
 133  94BC                  INCLUDE "./Maths/asm_sqrt.asm"
# file opened: ./Maths/asm_sqrt.asm
   1+ 94BC              ; "ASM SQRT : TESTGOOD"
   2+ 94BC              ; "16-bit integer square root"
   3+ 94BC              ; "call with de = number to square root"
   4+ 94BC              ; "returns   hl = square root"
   5+ 94BC              ; "corrupts  bc, de"
   6+ 94BC              asm_sqrt:
   7+ 94BC 01 00 80     	ld bc,$8000
   8+ 94BF 61           	ld h,c
   9+ 94C0 69           	ld l,c
  10+ 94C1              .sqrloop:
  11+ 94C1 CB 38        	srl b
  12+ 94C3 CB 19        	rr c
  13+ 94C5 09           	add hl,bc
  14+ 94C6 EB           	ex de,hl
  15+ 94C7 ED 52        	sbc hl,de
  16+ 94C9 38 04        	jr c,.sqrbit
  17+ 94CB EB           	ex de,hl
  18+ 94CC 09           	add hl,bc
  19+ 94CD 18 05        	jr .sqrfi
  20+ 94CF              .sqrbit:
  21+ 94CF 19           	add hl,de
  22+ 94D0 EB           	ex de,hl
  23+ 94D1 B7           	or a
  24+ 94D2 ED 42        	sbc hl,bc
  25+ 94D4              .sqrfi:
  26+ 94D4 CB 3C        	srl h
  27+ 94D6 CB 1D        	rr l
  28+ 94D8 CB 38        	srl b
  29+ 94DA CB 19        	rr c
  30+ 94DC 30 E3        	jr nc,.sqrloop
  31+ 94DE C9           	ret
  32+ 94DF
  33+ 94DF
  34+ 94DF              sqrtQR:					; Q = SQR(Qlo.Rhi) Q <~127
  35+ 94DF 3A 66 84     	ld		a,(varQ)
  36+ 94E2 5F           	ld		e,a
  37+ 94E3 3A 67 84     	ld		a,(varR)
  38+ 94E6 57           	ld		d,a
  39+ 94E7 CD BC 94     	call	asm_sqrt
  40+ 94EA 7D               ld      a,l
  41+ 94EB 32 66 84     	ld		(varQ),a
  42+ 94EE C9           	ret
  43+ 94EF
# file closed: ./Maths/asm_sqrt.asm
 134  94EF                  INCLUDE "./Maths/asm_divide.asm"
# file opened: ./Maths/asm_divide.asm
   1+ 94EF              ;
   2+ 94EF              ;   Set flags E to 11111110
   3+ 94EF              ;   Loop:   A << 2
   4+ 94EF              ;           if carry was 0
   5+ 94EF              ;               if a >= D
   6+ 94EF              ;                   A = A - D
   7+ 94EF              ;                   clear carry (probably irrelevant really)
   8+ 94EF              ;           else
   9+ 94EF
  10+ 94EF              ;               sla flags << bringing in carry of 1
  11+ 94EF              ;               if bit 7 of flag was set then loop
  12+ 94EF              ;                                        elase a = e and exit
  13+ 94EF              ;
  14+ 94EF              ;
  15+ 94EF
  16+ 94EF
  17+ 94EF              AEquAmul256DivD:        JumpIfAGTENusng  d, .Ll28Exit255
  17+ 94EF BA          >                        cp     d
  17+ 94F0 D2 0E 95    >                        jp		nc,.Ll28Exit255
  18+ 94F3 1E FE                                ld      e,%11111110                 ; Set R to have bits 1-7 set, so we can rotate through 7
  19+ 94F5 CB 27        .DivideLoop:            sla     a
  20+ 94F7 38 0D                                jr      c,.LL29
  21+ 94F9                                      JumpIfALTNusng  d, .SkipSub         ; will jump if carry set, so we need to reset on the rol
  21+ 94F9 BA          >                        cp      d
  21+ 94FA DA FF 94    >                        jp		c, .SkipSub
  22+ 94FD 92                                   sub     d
  23+ 94FE                                      ClearCarryFlag                      ; reset clarry as it will be complimented for rotate as 6502 does carry flags inverted
  23+ 94FE B7          >                        or a
  24+ 94FF              .SkipSub:               FlipCarryFlag                       ; if we did the subtract the carry will be clear so we need to invert to roll in.
  24+ 94FF 3F          >                        ccf
  25+ 9500 CB 13                                rl      e
  26+ 9502 38 F1                                jr      c,.DivideLoop
  27+ 9504 7B                                   ld      a,e
  28+ 9505 C9                                   ret
  29+ 9506 92           .LL29:                  sub     d                           ; A >= Q, so set A = A - Q
  30+ 9507                                      SetCarryFlag                        ; Set the C flag to rotate into the result in R
  30+ 9507 37          >                        scf
  31+ 9508 CB 13                                rl      e                           ; rotate counter e left
  32+ 950A 38 E9                                jr      c,.DivideLoop               ; if a bit was spat off teh end then loop
  33+ 950C 7B                                   ld      a,e                         ; stick result in a
  34+ 950D C9                                   ret
  35+ 950E 3E FF        .Ll28Exit255:           ld  a,255                           ; Fail with FF as result
  36+ 9510 C9                                   ret
  37+ 9511
  38+ 9511
  39+ 9511              ; Divide 8-bit values
  40+ 9511              ; In: Divide E by divider C
  41+ 9511              ; Out: A = result, B = rest
  42+ 9511              ;
  43+ 9511              ;;;Div8:
  44+ 9511              ;;;    xor a
  45+ 9511              ;;;    ld b,8
  46+ 9511              ;;;Div8_Loop:
  47+ 9511              ;;;    rl e
  48+ 9511              ;;;    rla
  49+ 9511              ;;;    sub c
  50+ 9511              ;;;    jr nc,Div8_NoAdd
  51+ 9511              ;;;    add a,c
  52+ 9511              ;;;Div8_NoAdd:
  53+ 9511              ;;;    djnz Div8_Loop
  54+ 9511              ;;;    ld b,a0
  55+ 9511              ;;;    ld a,e
  56+ 9511              ;;;    rla
  57+ 9511              ;;;    cpl
  58+ 9511              ;;;    ret
  59+ 9511
  60+ 9511              ;;Inputs: DE is the numerator, BC is the divisor
  61+ 9511              ;;Outputs: DE is the result
  62+ 9511              ;;         A is a copy of E
  63+ 9511              ;;         HL is the remainder
  64+ 9511              ;;         BC is not changed
  65+ 9511              ;; so DE = DE /BC
  66+ 9511              ;140 bytes
  67+ 9511              ;145cc
  68+ 9511
  69+ 9511              MacroDEDivBC:       MACRO
  70+ 9511 ~                                rla
  71+ 9511 ~                                adc     hl,hl
  72+ 9511 ~                                sbc     hl,bc
  73+ 9511 ~                                jr      nc,$+3
  74+ 9511 ~                                add     hl,bc
  75+ 9511                                  ENDM
  76+ 9511
  77+ 9511              DEequDEDivBC:
  78+ 9511 AF               xor a
  79+ 9512 ED 62            sbc hl,hl
  80+ 9514 7A               ld a,d
  81+ 9515                  MacroDEDivBC
  81+ 9515 17          >                    rla
  81+ 9516 ED 6A       >                    adc     hl,hl
  81+ 9518 ED 42       >                    sbc     hl,bc
  81+ 951A 30 01       >                    jr      nc,$+3
  81+ 951C 09          >                    add     hl,bc
  82+ 951D                  MacroDEDivBC
  82+ 951D 17          >                    rla
  82+ 951E ED 6A       >                    adc     hl,hl
  82+ 9520 ED 42       >                    sbc     hl,bc
  82+ 9522 30 01       >                    jr      nc,$+3
  82+ 9524 09          >                    add     hl,bc
  83+ 9525                  MacroDEDivBC
  83+ 9525 17          >                    rla
  83+ 9526 ED 6A       >                    adc     hl,hl
  83+ 9528 ED 42       >                    sbc     hl,bc
  83+ 952A 30 01       >                    jr      nc,$+3
  83+ 952C 09          >                    add     hl,bc
  84+ 952D                  MacroDEDivBC
  84+ 952D 17          >                    rla
  84+ 952E ED 6A       >                    adc     hl,hl
  84+ 9530 ED 42       >                    sbc     hl,bc
  84+ 9532 30 01       >                    jr      nc,$+3
  84+ 9534 09          >                    add     hl,bc
  85+ 9535                  MacroDEDivBC
  85+ 9535 17          >                    rla
  85+ 9536 ED 6A       >                    adc     hl,hl
  85+ 9538 ED 42       >                    sbc     hl,bc
  85+ 953A 30 01       >                    jr      nc,$+3
  85+ 953C 09          >                    add     hl,bc
  86+ 953D                  MacroDEDivBC
  86+ 953D 17          >                    rla
  86+ 953E ED 6A       >                    adc     hl,hl
  86+ 9540 ED 42       >                    sbc     hl,bc
  86+ 9542 30 01       >                    jr      nc,$+3
  86+ 9544 09          >                    add     hl,bc
  87+ 9545                  MacroDEDivBC
  87+ 9545 17          >                    rla
  87+ 9546 ED 6A       >                    adc     hl,hl
  87+ 9548 ED 42       >                    sbc     hl,bc
  87+ 954A 30 01       >                    jr      nc,$+3
  87+ 954C 09          >                    add     hl,bc
  88+ 954D                  MacroDEDivBC
  88+ 954D 17          >                    rla
  88+ 954E ED 6A       >                    adc     hl,hl
  88+ 9550 ED 42       >                    sbc     hl,bc
  88+ 9552 30 01       >                    jr      nc,$+3
  88+ 9554 09          >                    add     hl,bc
  89+ 9555 17               rla
  90+ 9556 2F               cpl
  91+ 9557 57               ld d,a
  92+ 9558
  93+ 9558 7B               ld a,e
  94+ 9559                  MacroDEDivBC
  94+ 9559 17          >                    rla
  94+ 955A ED 6A       >                    adc     hl,hl
  94+ 955C ED 42       >                    sbc     hl,bc
  94+ 955E 30 01       >                    jr      nc,$+3
  94+ 9560 09          >                    add     hl,bc
  95+ 9561                  MacroDEDivBC
  95+ 9561 17          >                    rla
  95+ 9562 ED 6A       >                    adc     hl,hl
  95+ 9564 ED 42       >                    sbc     hl,bc
  95+ 9566 30 01       >                    jr      nc,$+3
  95+ 9568 09          >                    add     hl,bc
  96+ 9569                  MacroDEDivBC
  96+ 9569 17          >                    rla
  96+ 956A ED 6A       >                    adc     hl,hl
  96+ 956C ED 42       >                    sbc     hl,bc
  96+ 956E 30 01       >                    jr      nc,$+3
  96+ 9570 09          >                    add     hl,bc
  97+ 9571                  MacroDEDivBC
  97+ 9571 17          >                    rla
  97+ 9572 ED 6A       >                    adc     hl,hl
  97+ 9574 ED 42       >                    sbc     hl,bc
  97+ 9576 30 01       >                    jr      nc,$+3
  97+ 9578 09          >                    add     hl,bc
  98+ 9579                  MacroDEDivBC
  98+ 9579 17          >                    rla
  98+ 957A ED 6A       >                    adc     hl,hl
  98+ 957C ED 42       >                    sbc     hl,bc
  98+ 957E 30 01       >                    jr      nc,$+3
  98+ 9580 09          >                    add     hl,bc
  99+ 9581                  MacroDEDivBC
  99+ 9581 17          >                    rla
  99+ 9582 ED 6A       >                    adc     hl,hl
  99+ 9584 ED 42       >                    sbc     hl,bc
  99+ 9586 30 01       >                    jr      nc,$+3
  99+ 9588 09          >                    add     hl,bc
 100+ 9589                  MacroDEDivBC
 100+ 9589 17          >                    rla
 100+ 958A ED 6A       >                    adc     hl,hl
 100+ 958C ED 42       >                    sbc     hl,bc
 100+ 958E 30 01       >                    jr      nc,$+3
 100+ 9590 09          >                    add     hl,bc
 101+ 9591                  MacroDEDivBC
 101+ 9591 17          >                    rla
 101+ 9592 ED 6A       >                    adc     hl,hl
 101+ 9594 ED 42       >                    sbc     hl,bc
 101+ 9596 30 01       >                    jr      nc,$+3
 101+ 9598 09          >                    add     hl,bc
 102+ 9599 17               rla
 103+ 959A 2F               cpl
 104+ 959B 5F               ld e,a
 105+ 959C C9               ret
 106+ 959D
 107+ 959D
 108+ 959D
 109+ 959D              ;divdide by 16 using undocumented instrunctions
 110+ 959D              ;Input: BC = Dividend, DE = Divisor, HL = 0
 111+ 959D              ;Output: BC = Quotient, HL = Remainder
 112+ 959D              ; Our use
 113+ 959D              ; BC = A0
 114+ 959D              ; DE = 0C
 115+ 959D              ; so BC = a * 256 / C
 116+ 959D              DIV16Amul256dCUNDOC:    JumpIfAGTENusng	  c,DEV16ATooLarge                                          ; first off if a > c ten return 255
 116+ 959D B9          >                        cp     c
 116+ 959E D2 C9 95    >                        jp		nc,DEV16ATooLarge
 117+ 95A1 47                                   ld      b,a
 118+ 95A2 59                                   ld      e,c
 119+ 95A3 0E 00                                ld      c,0
 120+ 95A5 16 00                                ld      d,0
 121+ 95A7 C3 B4 95                             jp      DIV16UNDOC
 122+ 95AA 47           DIV16Amul256dQUNDOC:    ld      b,a
 123+ 95AB 0E 00                                ld      c,0
 124+ 95AD 21 66 84                             ld      hl,varQ
 125+ 95B0 7E                                   ld      a,(hl)
 126+ 95B1 16 00                                ld      d,0
 127+ 95B3 5F                                   ld      e,a
 128+ 95B4              DIV16BCDivDEUNDOC:
 129+ 95B4 21 00 00     DIV16UNDOC:             ld      hl,0
 130+ 95B7 78                                   ld      a,b
 131+ 95B8 06 10                                ld      b,16
 132+ 95BA CB 31        DIV16UNDOCLOOP:         sll	c		; unroll 16 times
 133+ 95BC 17                                   rla			; ...
 134+ 95BD ED 6A                                adc	hl,hl		; ...
 135+ 95BF ED 52                                sbc	hl,de		; ...
 136+ 95C1 30 02                                jr	nc,DIV16UNDOCSKIP		; ...
 137+ 95C3 19                                   add	hl,de		; ...
 138+ 95C4 0D                                   dec	c		; ...
 139+ 95C5 10 F3        DIV16UNDOCSKIP:         djnz DIV16UNDOCLOOP
 140+ 95C7 47                                   ld   b,a
 141+ 95C8 C9                                   ret
 142+ 95C9 01 FF 00     DEV16ATooLarge:         ld     bc,$00FF
 143+ 95CC C9                                   ret
 144+ 95CD
 145+ 95CD              ; "> asm_div8 C_Div_D - C is the numerator, D is the denominator, A is the remainder, B is 0, C is the result of C/D,D,E,H,L are not changed"
 146+ 95CD 06 08        asm_div8:               ld b,8
 147+ 95CF AF                                   xor a
 148+ 95D0 CB 21        .div8_loop:	            sla c
 149+ 95D2 17                                   rla
 150+ 95D3 BA                                   cp d
 151+ 95D4 38 02                                jr c,.div8_skip
 151+ 95D6
 152+ 95D6 0C                                   inc c
 153+ 95D7 92                                   sub d
 154+ 95D8 10 F6        .div8_skip:	            djnz .div8_loop
 155+ 95DA C9                                   ret
 156+ 95DB              ; ">asm_div16: HL_Div_C: HL is the numerator,  C is the denominator, output A is the remainder, B is 0, C,DE is not changedHL is the quotient"
 157+ 95DB 06 10        asm_div16:              ld b,16
 158+ 95DD AF                                   xor a
 159+ 95DE CB 25        div16_loop:	            sla l
 160+ 95E0 CB 14                                rl	h
 161+ 95E2              ;    add hl,hl
 162+ 95E2 17                                   rla
 163+ 95E3 B9                                   cp c
 164+ 95E4 38 02                                jr c,div16_skip
 165+ 95E6 2C                                   inc l
 166+ 95E7 91                                   sub c
 167+ 95E8 10 F4        div16_skip:		        djnz div16_loop
 168+ 95EA C9                                   ret
 169+ 95EB              ;
 170+ 95EB              ; Divide 16-bit values (with 16-bit result)
 171+ 95EB              ; In: Divide BC by divider DE
 172+ 95EB              ; Out: BC = result, HL = rest
 173+ 95EB              ;
 174+ 95EB              HLDivC_Iteration: 	MACRO
 175+ 95EB ~            					add	hl,hl		; unroll 16 times
 176+ 95EB ~            					rla				; ...
 177+ 95EB ~            					cp	c			; ...
 178+ 95EB ~            					jr	1F
 179+ 95EB ~            					sub	c			; ...
 180+ 95EB ~            1:
 181+ 95EB ~            					inc	l			; ...
 182+ 95EB              					ENDM
 183+ 95EB
 184+ 95EB
 185+ 95EB
 186+ 95EB              ; ">div1616: BC = BC / DE. HL = remainder"
 187+ 95EB 21 00 00     Div1616:            ld hl,0
 188+ 95EE 78                               ld a,b
 189+ 95EF 06 08                            ld b,8
 190+ 95F1 17           .Div16_Loop1:       rla
 191+ 95F2 ED 6A                            adc hl,hl
 192+ 95F4 ED 52                            sbc hl,de
 193+ 95F6 30 01                            jr nc,.Div16_NoAdd1
 194+ 95F8 19                               add hl,de
 195+ 95F9 10 F6        .Div16_NoAdd1:      djnz .Div16_Loop1
 196+ 95FB 17                               rla
 197+ 95FC 2F                               cpl
 198+ 95FD 47                               ld b,a
 199+ 95FE 79                               ld a,c
 200+ 95FF 48                               ld c,b
 201+ 9600 06 08                            ld b,8
 202+ 9602 17           .Div16_Loop2:       rla
 203+ 9603 ED 6A                            adc hl,hl
 204+ 9605 ED 52                            sbc hl,de
 205+ 9607 30 01                            jr nc,.Div16_NoAdd2
 206+ 9609 19                               add hl,de
 207+ 960A 10 F6        .Div16_NoAdd2:      djnz .Div16_Loop2
 208+ 960C 17                               rla
 209+ 960D 2F                               cpl
 210+ 960E 41                               ld b,c
 211+ 960F 4F                               ld c,a
 212+ 9610 C9                               ret
 213+ 9611
 214+ 9611
 215+ 9611
 216+ 9611              BCDIVDE_Iteration: MACRO
 217+ 9611 ~            				   rla
 218+ 9611 ~            				   adc	hl,hl
 219+ 9611 ~            				   add	hl,de
 220+ 9611 ~            				   jr	c,1F
 221+ 9611 ~            				   sbc	hl,de
 222+ 9611 ~            1:
 223+ 9611              				   ENDM
 224+ 9611
 225+ 9611
 226+ 9611              ; ">BC_Div_DE: BC = BC / DE. HL = remainder fast divide with unrolled loop"
 227+ 9611              ;BC/DE ==> BC, remainder in HL
 228+ 9611              ;NOTE: BC/0 returns 0 as the quotient.
 229+ 9611              ;min: 738cc
 230+ 9611              ;max: 898cc
 231+ 9611              ;avg: 818cc
 232+ 9611              ;144 bytes
 233+ 9611 AF           BC_Div_DE:              xor a
 234+ 9612 67                                   ld h,a
 235+ 9613 6F                                   ld l,a
 236+ 9614 93                                   sub e
 237+ 9615 5F                                   ld e,a
 238+ 9616 9F                                   sbc a,a
 239+ 9617 92                                   sub d
 240+ 9618 57                                   ld d,a
 241+ 9619 78                                   ld a,b
 242+ 961A                                      BCDIVDE_Iteration
 242+ 961A 17          >				   rla
 242+ 961B ED 6A       >				   adc	hl,hl
 242+ 961D 19          >				   add	hl,de
 242+ 961E 38 02       >				   jr	c,1F
 242+ 9620 ED 52       >				   sbc	hl,de
 242+ 9622             >1:
 243+ 9622                                      BCDIVDE_Iteration
 243+ 9622 17          >				   rla
 243+ 9623 ED 6A       >				   adc	hl,hl
 243+ 9625 19          >				   add	hl,de
 243+ 9626 38 02       >				   jr	c,1F
 243+ 9628 ED 52       >				   sbc	hl,de
 243+ 962A             >1:
 244+ 962A                                      BCDIVDE_Iteration
 244+ 962A 17          >				   rla
 244+ 962B ED 6A       >				   adc	hl,hl
 244+ 962D 19          >				   add	hl,de
 244+ 962E 38 02       >				   jr	c,1F
 244+ 9630 ED 52       >				   sbc	hl,de
 244+ 9632             >1:
 245+ 9632                                      BCDIVDE_Iteration
 245+ 9632 17          >				   rla
 245+ 9633 ED 6A       >				   adc	hl,hl
 245+ 9635 19          >				   add	hl,de
 245+ 9636 38 02       >				   jr	c,1F
 245+ 9638 ED 52       >				   sbc	hl,de
 245+ 963A             >1:
 246+ 963A                                      BCDIVDE_Iteration
 246+ 963A 17          >				   rla
 246+ 963B ED 6A       >				   adc	hl,hl
 246+ 963D 19          >				   add	hl,de
 246+ 963E 38 02       >				   jr	c,1F
 246+ 9640 ED 52       >				   sbc	hl,de
 246+ 9642             >1:
 247+ 9642                                      BCDIVDE_Iteration
 247+ 9642 17          >				   rla
 247+ 9643 ED 6A       >				   adc	hl,hl
 247+ 9645 19          >				   add	hl,de
 247+ 9646 38 02       >				   jr	c,1F
 247+ 9648 ED 52       >				   sbc	hl,de
 247+ 964A             >1:
 248+ 964A                                      BCDIVDE_Iteration
 248+ 964A 17          >				   rla
 248+ 964B ED 6A       >				   adc	hl,hl
 248+ 964D 19          >				   add	hl,de
 248+ 964E 38 02       >				   jr	c,1F
 248+ 9650 ED 52       >				   sbc	hl,de
 248+ 9652             >1:
 249+ 9652                                      BCDIVDE_Iteration
 249+ 9652 17          >				   rla
 249+ 9653 ED 6A       >				   adc	hl,hl
 249+ 9655 19          >				   add	hl,de
 249+ 9656 38 02       >				   jr	c,1F
 249+ 9658 ED 52       >				   sbc	hl,de
 249+ 965A             >1:
 250+ 965A 17                                   rla
 251+ 965B 47                                   ld b,a
 252+ 965C
 253+ 965C 79                                   ld a,c
 254+ 965D                                      BCDIVDE_Iteration
 254+ 965D 17          >				   rla
 254+ 965E ED 6A       >				   adc	hl,hl
 254+ 9660 19          >				   add	hl,de
 254+ 9661 38 02       >				   jr	c,1F
 254+ 9663 ED 52       >				   sbc	hl,de
 254+ 9665             >1:
 255+ 9665                                      BCDIVDE_Iteration
 255+ 9665 17          >				   rla
 255+ 9666 ED 6A       >				   adc	hl,hl
 255+ 9668 19          >				   add	hl,de
 255+ 9669 38 02       >				   jr	c,1F
 255+ 966B ED 52       >				   sbc	hl,de
 255+ 966D             >1:
 256+ 966D                                      BCDIVDE_Iteration
 256+ 966D 17          >				   rla
 256+ 966E ED 6A       >				   adc	hl,hl
 256+ 9670 19          >				   add	hl,de
 256+ 9671 38 02       >				   jr	c,1F
 256+ 9673 ED 52       >				   sbc	hl,de
 256+ 9675             >1:
 257+ 9675                                      BCDIVDE_Iteration
 257+ 9675 17          >				   rla
 257+ 9676 ED 6A       >				   adc	hl,hl
 257+ 9678 19          >				   add	hl,de
 257+ 9679 38 02       >				   jr	c,1F
 257+ 967B ED 52       >				   sbc	hl,de
 257+ 967D             >1:
 258+ 967D                                      BCDIVDE_Iteration
 258+ 967D 17          >				   rla
 258+ 967E ED 6A       >				   adc	hl,hl
 258+ 9680 19          >				   add	hl,de
 258+ 9681 38 02       >				   jr	c,1F
 258+ 9683 ED 52       >				   sbc	hl,de
 258+ 9685             >1:
 259+ 9685                                      BCDIVDE_Iteration
 259+ 9685 17          >				   rla
 259+ 9686 ED 6A       >				   adc	hl,hl
 259+ 9688 19          >				   add	hl,de
 259+ 9689 38 02       >				   jr	c,1F
 259+ 968B ED 52       >				   sbc	hl,de
 259+ 968D             >1:
 260+ 968D                                      BCDIVDE_Iteration
 260+ 968D 17          >				   rla
 260+ 968E ED 6A       >				   adc	hl,hl
 260+ 9690 19          >				   add	hl,de
 260+ 9691 38 02       >				   jr	c,1F
 260+ 9693 ED 52       >				   sbc	hl,de
 260+ 9695             >1:
 261+ 9695                                      BCDIVDE_Iteration
 261+ 9695 17          >				   rla
 261+ 9696 ED 6A       >				   adc	hl,hl
 261+ 9698 19          >				   add	hl,de
 261+ 9699 38 02       >				   jr	c,1F
 261+ 969B ED 52       >				   sbc	hl,de
 261+ 969D             >1:
 262+ 969D 17                                   rla
 263+ 969E 4F                                   ld c,a
 264+ 969F C9                                   ret
 265+ 96A0
 266+ 96A0              ;Inputs:
 267+ 96A0              ;     DE,BC are 8.8 Fixed Point numbers
 268+ 96A0              ;Outputs:
 269+ 96A0              ;     DE is the 8.8 Fixed Point result (rounded to the least significant bit)
 270+ 96A0              ;if DE is 0 : 122cc or 136cc if BC is negative
 271+ 96A0              ;if |BC|>=128*|DE| : 152cc or 166cc if BC is negative
 272+ 96A0              ;Otherwise:
 273+ 96A0              ;min: 1107cc
 274+ 96A0              ;max: 1319cc
 275+ 96A0              ;avg: 1201cc
 276+ 96A0 78           BC_Div_DE_88:           ld a,b  ; First, find out if the output is positive or negative
 277+ 96A1 AA                                   xor d
 278+ 96A2 F5                                   push af   ;sign bit is the result sign bit
 279+ 96A3              ; Now make sure the inputs are positive
 280+ 96A3 A8                                   xor b     ;A now has the value of B, since I XORed it with D twice (cancelling)
 281+ 96A4 F2 AD 96                             jp p,BC_Div_DE_88_lbl1   ;if Positive, don't negate
 282+ 96A7 AF                                   xor a
 283+ 96A8 91                                   sub c
 284+ 96A9 4F                                   ld c,a
 285+ 96AA 9F                                   sbc a,a
 286+ 96AB 90                                   sub b
 287+ 96AC 47                                   ld b,a
 288+ 96AD 7A           BC_Div_DE_88_lbl1:      ld a,d  ;now make DE negative to optimize the remainder comparison
 289+ 96AE B2                                   or d
 290+ 96AF FA B8 96                             jp m,BC_Div_DE_88_lbl2
 291+ 96B2 AF                                   xor a
 292+ 96B3 93                                   sub e
 293+ 96B4 5F                                   ld e,a
 294+ 96B5 9F                                   sbc a,a
 295+ 96B6 92                                   sub d
 296+ 96B7 57                                   ld d,a
 297+ 96B8 B3           BC_Div_DE_88_lbl2:      or e      ;if DE is 0, we can call it an overflow ;A is the current value of D
 298+ 96B9 28 1D                                jr z,div_fixed88_overflow
 299+ 96BB 26 00                                ld h,0          ;The accumulator gets set to B if no overflow.;We can use H=0 to save a few cc in the meantime
 300+ 96BD 78                                   ld a,b;if B+DE>=0, then we'll have overflow
 301+ 96BE 83                                   add a,e
 302+ 96BF 7A                                   ld a,d
 303+ 96C0 8C                                   adc a,h
 304+ 96C1 38 15                                jr c,div_fixed88_overflow
 305+ 96C3 68                                   ld l,b  ;Now we can load the accumulator/remainder with B;H is already 0
 306+ 96C4 79                                   ld a,c
 307+ 96C5 CD E0 96                             call div_fixed88_sub
 308+ 96C8 4F                                   ld c,a
 309+ 96C9 78                                   ld a,b      ;A is now 0
 310+ 96CA CD E0 96                             call div_fixed88_sub
 311+ 96CD 51                                   ld d,c
 312+ 96CE 5F                                   ld e,a
 313+ 96CF F1                                   pop af
 314+ 96D0 F0                                   ret p
 315+ 96D1 AF                                   xor a
 316+ 96D2 93                                   sub e
 317+ 96D3 5F                                   ld e,a
 318+ 96D4 9F                                   sbc a,a
 319+ 96D5 92                                   sub d
 320+ 96D6 57                                   ld d,a
 321+ 96D7 C9                                   ret
 322+ 96D8
 323+ 96D8 11 FF 7F     div_fixed88_overflow:   ld de,$7FFF
 324+ 96DB F1                                   pop af
 325+ 96DC F0                                   ret p
 326+ 96DD 13                                   inc de
 327+ 96DE 1C                                   inc e
 328+ 96DF C9                                   ret
 329+ 96E0
 330+ 96E0              ;min: 456cc
 331+ 96E0              ;max: 536cc
 332+ 96E0              ;avg: 496cc
 333+ 96E0 06 08        div_fixed88_sub:        ld b,8
 334+ 96E2 17           BC_Div_DE_88_lbl3:      rla
 335+ 96E3 ED 6A                                adc hl,hl
 336+ 96E5 19                                   add hl,de
 337+ 96E6 38 02                                jr c,$+4
 338+ 96E8 ED 52                                sbc hl,de
 339+ 96EA 10 F6                                djnz BC_Div_DE_88_lbl3
 340+ 96EC 8F                                   adc a,a
 341+ 96ED C9                                   ret
 342+ 96EE
# file closed: ./Maths/asm_divide.asm
 135  96EE                  INCLUDE "./Maths/asm_unitvector.asm"
# file opened: ./Maths/asm_unitvector.asm
   1+ 96EE              asm_tis2:
   2+ 96EE              ; ">TIS2 A = (A / Q * 96) so A = -96 ---- 96  range "
   3+ 96EE              ; ">DOES NOT DO SIGNED YET"
   4+ 96EE F5           	push af
   5+ 96EF E6 7F            and SignMask8Bit
   6+ 96F1 57           	ld d,a				;; d = A
   7+ 96F2 3A 66 84     	ld a,(varQ)
   8+ 96F5 5F           	ld e,a
   9+ 96F6 7A           	ld a,d
  10+ 96F7 BB           	cp e
  11+ 96F8 30 11        	jr nc, .tis2_set96	;; jump if a >= Q
  12+ 96FA 1E 60        	ld e, 96
  13+ 96FC ED 30        	mul				; de = d * 96 (also a * 96 )
  14+ 96FE EB           	ex de,hl
  15+ 96FF 3A 66 84     	ld a,(varQ)
  16+ 9702 4F           	ld c,a
  17+ 9703 CD DB 95     	call asm_div16
  18+ 9706 F1           	pop af
  19+ 9707 E6 80        	and $80
  20+ 9709 B5           	or l
  21+ 970A C9           	ret
  22+ 970B              .tis2_set96:
  23+ 970B F1           	pop af
  24+ 970C E6 80        	and $80
  25+ 970E F6 96        	or $96
  26+ 9710 C9           	ret
  27+ 9711
  28+ 9711
  29+ 9711              asm_unit_vector:
  30+ 9711              squareregfx:
  31+ 9711 3A A7 9E     	ld a,(UBnkXScaled)
  32+ 9714 57           	ld d,a
  33+ 9715 5F           	ld e,a
  34+ 9716 ED 30        	mul
  35+ 9718 EB           	ex de,hl
  36+ 9719              squareregfy:
  37+ 9719 3A A9 9E     	ld a, (UBnkYScaled)
  38+ 971C 57           	ld d,a
  39+ 971D 5F           	ld e,a
  40+ 971E ED 30        	mul
  41+ 9720 19           	add hl,de
  42+ 9721              squareregfz:
  43+ 9721 3A AB 9E     	ld a, (UBnkZScaled)
  44+ 9724 57           	ld d,a
  45+ 9725 5F           	ld e,a
  46+ 9726 ED 30        	mul
  47+ 9728 19           	add hl,de
  48+ 9729 EB           	ex de,hl			; de de to number to root
  49+ 972A              hlequsquareroot:
  50+ 972A CD BC 94     	call asm_sqrt		; hl = sqrt (fx^2 + fy^2 + fx^2)
  51+ 972D E5           	push hl				; save it for work 3 copies
  52+ 972E E5           	push hl				; save it for work
  53+ 972F E5           	push hl				; save it for work
  54+ 9730              normfx:
  55+ 9730 3A A7 9E     	ld a,(UBnkXScaled)
  56+ 9733 E1           	pop hl				; get copy #1
  57+ 9734 7D           	ld a,l				; we assume only l had worthwhile data but could spill into h
  58+ 9735 4F           	ld c,a
  59+ 9736 CD EE 96     	call asm_tis2
  60+ 9739 32 A7 9E     	ld (UBnkXScaled),a
  61+ 973C              normfy:
  62+ 973C 3A A9 9E     	ld a,(UBnkYScaled)
  63+ 973F E1           	pop hl				; get copy #2
  64+ 9740 7D           	ld a,l
  65+ 9741 4F           	ld c,a
  66+ 9742 CD EE 96     	call asm_tis2
  67+ 9745 32 A9 9E     	ld (UBnkYScaled),a
  68+ 9748              normfz:
  69+ 9748 3A AB 9E     	ld a,(UBnkZScaled)
  70+ 974B E1           	pop hl				; get copy #2
  71+ 974C 7D           	ld a,l
  72+ 974D 4F           	ld c,a
  73+ 974E CD EE 96     	call asm_tis2
  74+ 9751 32 AB 9E     	ld (UBnkZScaled),a
  75+ 9754              asm_unit_vector_end:
  76+ 9754 C9           	ret
  77+ 9755
# file closed: ./Maths/asm_unitvector.asm
 136  9755                  INCLUDE "./Maths/compare16.asm"
# file opened: ./Maths/compare16.asm
   1+ 9755              ; Input:
   2+ 9755              ;       HL = 1st value
   3+ 9755              ;       DE = 2nd value
   4+ 9755              ; Output:
   5+ 9755              ;       CF, ZF = results of comparison:
   6+ 9755              ;
   7+ 9755              ;               CF      ZF      Result
   8+ 9755              ;               -----------------------------------
   9+ 9755              ;               0       0       HL > DE
  10+ 9755              ;               0       1       HL == DE
  11+ 9755              ;               1       0       HL < DE
  12+ 9755              ;               1       1       Impossible
  13+ 9755              ;
  14+ 9755
  15+ 9755 E5           compare16HLDE:      push    hl
  16+ 9756 A7                               and     a
  17+ 9757 ED 52                            sbc     hl,de
  18+ 9759 E1                               pop     hl
  19+ 975A C9                               ret
  20+ 975B
  21+ 975B              ; With compare signed we do ABS comparison
  22+ 975B              ; this is used for view ports as we just want to know if its +/- out side of 90 degrees
  23+ 975B
  24+ 975B E5 D5        compare16HLDEABS:   push    hl,,de
  25+ 975D 7C                               ld      a,h                                     ; Quick pass see of both the same sign
  26+ 975E E6 7F                            and     SignMask8Bit
  27+ 9760 67                               ld      h,a
  28+ 9761 7A                               ld      a,d                                     ; Quick pass see of both the same sign
  29+ 9762 E6 7F                            and     SignMask8Bit
  30+ 9764 57                               ld      d,a
  31+ 9765 A7                               and     a
  32+ 9766 ED 52                            sbc     hl,de
  33+ 9768 D1 E1                            pop     hl,,de
  34+ 976A C9                               ret
  35+ 976B
  36+ 976B
# file closed: ./Maths/compare16.asm
 137  976B                  INCLUDE "./Maths/negate16.asm"
# file opened: ./Maths/negate16.asm
   1+ 976B              ;;----------------------------------------------------------------------------------------------------------------------
   2+ 976B              ;; 16-bit negate
   3+ 976B              negate16:
   4+ 976B              negate16hl:
   5+ 976B                      ; Input:
   6+ 976B                      ;       HL = value
   7+ 976B                      ; Output:
   8+ 976B                      ;       HL = -value
   9+ 976B                      ; Destroys:
  10+ 976B                      ;       AF
  11+ 976B                      ;
  12+ 976B AF           	xor 	a
  13+ 976C 95           	sub 	l
  14+ 976D 6F           	ld 		l,a
  15+ 976E 9F           	sbc 	a,a
  16+ 976F 94           	sub 	h
  17+ 9770 67           	ld 		h,a
  18+ 9771 C9           	ret
  19+ 9772
  20+ 9772              negate16de:
  21+ 9772 AF           	xor 	a
  22+ 9773 93           	sub 	e
  23+ 9774 5F           	ld 		e,a
  24+ 9775 9F           	sbc 	a,a
  25+ 9776 92           	sub 	d
  26+ 9777 57           	ld 		d,a
  27+ 9778 C9           	ret
  28+ 9779
  29+ 9779              negate16bc:
  30+ 9779 AF           	xor 	a
  31+ 977A 91           	sub 	c
  32+ 977B 4F           	ld 		c,a
  33+ 977C 9F           	sbc 	a,a
  34+ 977D 90           	sub 	b
  35+ 977E 47           	ld 		b,a
  36+ 977F C9           	ret
  37+ 9780
  38+ 9780
  39+ 9780              macronegate16hl:	MACRO
  40+ 9780 ~            					xor 	a
  41+ 9780 ~            					sub 	l
  42+ 9780 ~            					ld 		l,a
  43+ 9780 ~            					sbc 	a,a
  44+ 9780 ~            					sub 	h
  45+ 9780 ~            					ld 		h,a
  46+ 9780              					ENDM
  47+ 9780
  48+ 9780              macronegate16de:	MACRO
  49+ 9780 ~            					xor 	a
  50+ 9780 ~                                sub 	e
  51+ 9780 ~                                ld 		e,a
  52+ 9780 ~                                sbc 	a,a
  53+ 9780 ~                                sub 	d
  54+ 9780 ~                                ld 		d,a
  55+ 9780              					ENDM
  56+ 9780              macronegate16bc:	MACRO
  57+ 9780 ~            					xor 	a
  58+ 9780 ~                                sub 	c
  59+ 9780 ~                                ld 		c,a
  60+ 9780 ~                                sbc 	a,a
  61+ 9780 ~                                sub 	b
  62+ 9780 ~                                ld 		b,a
  63+ 9780              					ENDM
  64+ 9780
  65+ 9780              macronegate16ix:	MACRO
  66+ 9780 ~            					xor 	a
  67+ 9780 ~                                sub 	ixl
  68+ 9780 ~                                ld 		ixl,a
  69+ 9780 ~                                sbc 	a,a
  70+ 9780 ~                                sub 	ixh
  71+ 9780 ~                                ld 		ixh,a
  72+ 9780              					ENDM
# file closed: ./Maths/negate16.asm
 138  9780                  INCLUDE "./Maths/normalise96.asm"
# file opened: ./Maths/normalise96.asm
   1+ 9780 DD 68        AequAdivDmul96Unsg:     ld			ixl,b						; Get sign bit passed in as bit 7 in b
   2+ 9782                                      JumpIfAGTENusng d, TISXAccGTEQ			; if A >= Q then return with a 1 (unity i.e. 96) with the correct sign
   2+ 9782 BA          >                        cp     d
   2+ 9783 D2 98 97    >                        jp		nc,TISXAccGTEQ
   3+ 9786 4F                                   ld			c,a
   4+ 9787 CD CD 95                             call		asm_div8
   5+ 978A 79                                   ld			a,c							; a = result
   6+ 978B CB 3F                                srl			a							; result / 4
   7+ 978D 47                                   ld			b,a							; t = t /4
   8+ 978E CB 3F                                srl			a							; result / 8
   9+ 9790 80                                   add			a,b							; result /8 + result /4
  10+ 9791 47                                   ld			b,a							; b = 3/8*Acc (max = 96)
  11+ 9792 DD 7D                                ld			a,ixl						; copy of Acc to look at sign bit
  12+ 9794 E6 80                                and			$80							; recover sign only
  13+ 9796 B0                                   or			b							; now put b back in so we have a leading sign bit (note not 2's compliment)
  14+ 9797 C9                                   ret
  15+ 9798              TISXAccGTEQ:
  16+ 9798              ;TI4:										;\ clean to +/- unity
  17+ 9798 DD 7D                                ld			a,ixl     					; get saved sign from b
  18+ 979A E6 80                                and			$80							; copy of Acc
  19+ 979C F6 60                                or			$60							; unity
  20+ 979E C9                                   ret
  21+ 979F
  22+ 979F
  23+ 979F
  24+ 979F
  25+ 979F              normaliseXX1596fast:
  26+ 979F                  ; .NORM	\ -> &3BD6 \ Normalize 3-vector length of XX15
  27+ 979F 3A A7 9E     	ld		a,(XX15)		    ; XX15+0
  28+ 97A2 DD 67        	ld		ixh,a               ; ixh = signed x component
  29+ 97A4 E6 7F        	and		SignMask8Bit                 ; a = unsigned version
  30+ 97A6              N96SQX:
  31+ 97A6              	inline_squde				; Use inline square for speed	objective is SQUA \ P.A =A7*A7 x^2
  31+ 97A6 5F          >			ld	e,a
  31+ 97A7 57          >			ld  d,a
  31+ 97A8 ED 30       >			mul
  32+ 97AA 62           	ld		h,d					; h == varR d = varO e= varA
  33+ 97AB 6B           	ld		l,e					; l == varQ  															:: so HL = XX15[x]^2
  34+ 97AC              N96SQY:
  35+ 97AC 3A A8 9E     	ld		a,(XX15+1)
  36+ 97AF DD 6F        	ld		ixl,a               ; ixl = signed y componet
  37+ 97B1 E6 7F        	and		SignMask8Bit                 ; = abs
  38+ 97B3              	inline_squde				; Use inline square for speed	objective is SQUA \ P.A =A7*A7 x^2		:: so DE = XX15[y]^2
  38+ 97B3 5F          >			ld	e,a
  38+ 97B4 57          >			ld  d,a
  38+ 97B5 ED 30       >			mul
  39+ 97B7 19           	add		hl,de				; hl = XX15[x]^2 + XX15[y]^2
  40+ 97B8              N96SQZ:
  41+ 97B8 3A A9 9E     	ld		a,(XX15+2)			; Note comments say \ ZZ15+2  should be \ XX15+2 as per code
  42+ 97BB FD 67        	ld		iyh,a               ; iyh = signed
  43+ 97BD E6 7F        	and		SignMask8Bit                 ; unsigned
  44+ 97BF              	inline_squde				; Use inline square for speed	objective is SQUA \ P.A =A7*A7 x^2		:: so DE = XX15[z]^2
  44+ 97BF 5F          >			ld	e,a
  44+ 97C0 57          >			ld  d,a
  44+ 97C1 ED 30       >			mul
  45+ 97C3              N96SQADD:
  46+ 97C3 19           	add		hl,de				; hl = XX15[x]^2 + XX15[y]^2 + XX15[z]^2
  47+ 97C4 EB           	ex		de,hl				; hl => de ready for square root
  48+ 97C5              N96SQRT:
  49+ 97C5 CD BC 94     	call	asm_sqrt			; hl = sqrt(XX15[x]^2 + XX15[y]^2 + XX15[z]^2), we just are interested in l which is the new Q
  50+ 97C8              N96NORMX:
  51+ 97C8 3A A7 9E     	ld		a,(XX15+0)
  52+ 97CB E6 7F        	and		SignMask8Bit
  53+ 97CD 4F           	ld		c,a
  54+ 97CE 55           	ld		d,l					; Q(i.e. l) => D, later we can just pop into de
  55+ 97CF CD F6 99     	call	AequAdivDmul96	; does not use HL so we can retain it
  56+ 97D2 47           	ld		b,a				;++SGN
  57+ 97D3 DD 7C        	ld		a,ixh			;++SGN
  58+ 97D5 E6 80        	and		$80				;++SGN
  59+ 97D7 B0           	or		b				;++SGN
  60+ 97D8 32 A7 9E     	ld		(XX15+0),a
  61+ 97DB              N96NORMY:
  62+ 97DB 3A A8 9E     	ld		a,(XX15+1)
  63+ 97DE E6 7F        	and		SignMask8Bit
  64+ 97E0 4F           	ld		c,a
  65+ 97E1 55           	ld		d,l					; Q(i.e. l) => D, later we can just pop into de
  66+ 97E2 CD F6 99     	call	AequAdivDmul96     	; does not use HL so we can retain it
  67+ 97E5 47           	ld		b,a				;++SGN
  68+ 97E6 DD 7D        	ld		a,ixl			;++SGN
  69+ 97E8 E6 80        	and		$80				;++SGN
  70+ 97EA B0           	or		b				;++SGN
  71+ 97EB 32 A8 9E     	ld		(XX15+1),a
  72+ 97EE              N96NORMZ:
  73+ 97EE 3A A9 9E     	ld		a,(XX15+2)
  74+ 97F1 E6 7F        	and		SignMask8Bit
  75+ 97F3 4F           	ld		c,a
  76+ 97F4 55           	ld		d,l					; Q(i.e. l) => D, later we can just pop into de
  77+ 97F5 CD F6 99     	call	AequAdivDmul96	; does not use HL so we can retain it
  78+ 97F8 47           	ld		b,a				;++SGN
  79+ 97F9 FD 7C        	ld		a,iyh			;++SGN
  80+ 97FB E6 80        	and		$80				;++SGN
  81+ 97FD B0           	or		b				;++SGN
  82+ 97FE 32 A9 9E     	ld		(XX15+2),a
  83+ 9801 C9           	ret
  84+ 9802
  85+ 9802              ; Normalise vector
  86+ 9802              ; scale Q = Sqrt (X^2 + Y^2 + Z^2)
  87+ 9802              ; X = X / Q with 96 = 1 , i.e X = X / Q * 3/8
  88+ 9802              ; Y = Y / Q with 96 = 1 , i.e Y = Y / Q * 3/8
  89+ 9802              ; Z = Z / Q with 96 = 1 , i.e Z = Z / Q * 3/8
  90+ 9802              ;
  91+ 9802              ;
  92+ 9802              ;
  93+ 9802
  94+ 9802              ; .NORM	\ -> &3BD6 \ Normalize 3-vector length of XX15
  95+ 9802 3A A7 9E     normaliseXX1596:        ld		a,(XX15)		    ; XX15+0
  96+ 9805                                      inline_squde				; Use inline square for speed	objective is SQUA \ P.A =A7*A7 x^2
  96+ 9805 5F          >			ld	e,a
  96+ 9806 57          >			ld  d,a
  96+ 9807 ED 30       >			mul
  97+ 9809 7A                                   ld		a,d
  98+ 980A 32 67 84                             ld		(varR),a			; R	 \ hi sum later use b
  99+ 980D 7B                                   ld		a,e
 100+ 980E 32 66 84                             ld		(varQ),a			; Q	 \ lo sum later use c
 101+ 9811 32 63 83                             ld		(varP),a			; P	 \ lo sum later just drop
 102+ 9814 3A A8 9E                             ld		a,(XX15+1)
 103+ 9817                                      inline_squde				; Use inline square for speed	objective is SQUA \ P.A =A7*A7 x^2
 103+ 9817 5F          >			ld	e,a
 103+ 9818 57          >			ld  d,a
 103+ 9819 ED 30       >			mul
 104+ 981B 7A                                   ld		a,d
 105+ 981C 32 82 84                             ld		(varT),a			; T	 \ hi sum
 106+ 981F 7B                                   ld		a,e
 107+ 9820 32 63 83                             ld		(varP),a			; P	 \ lo sum
 108+ 9823 21 66 84                             ld		hl,varQ
 109+ 9826 8E                                   adc		a,(hl)				; +Q
 110+ 9827 32 66 84                             ld		(varQ),a			; =>Q
 111+ 982A 3A 82 84                             ld		a,(varT)			;
 112+ 982D 21 67 84                             ld		hl,varR
 113+ 9830 8E                                   adc		a,(hl)				;  R
 114+ 9831 32 67 84                             ld		(varR),a			; R
 115+ 9834 3A A9 9E                             ld		a,(XX15+2)			; Note comments say \ ZZ15+2  should be \ XX15+2 as per code
 116+ 9837                                      inline_squde				; Use inline square for speed	objective is SQUA \ P.A =A7*A7 x^2
 116+ 9837 5F          >			ld	e,a
 116+ 9838 57          >			ld  d,a
 116+ 9839 ED 30       >			mul
 117+ 983B 7A                                   ld		a,d
 118+ 983C 32 82 84                             ld		(varT),a			; T	 \ hi sum
 119+ 983F 7B                                   ld		a,e
 120+ 9840 32 63 83                             ld		(varP),a			; P	 \ lo sum
 121+ 9843 21 66 84                             ld		hl,varQ
 122+ 9846 8E                                   adc		a,(hl)				; +Q
 123+ 9847 32 66 84                             ld		(varQ),a			; =>Q  xlo2 + ylo2 + zlo2
 124+ 984A 3A 82 84                             ld		a,(varT)			; T temp Hi
 125+ 984D 21 67 84                             ld		hl,varR
 126+ 9850 8E                                   adc		a,(hl)				; +R
 127+ 9851 32 67 84                             ld		(varR),a			; R
 128+ 9854 CD DF 94                             call	sqrtQR				; Q = SQR(Qlo.Rhi) Q <~127
 129+ 9857 3A A7 9E                             ld		a,(XX15+0)
 130+ 985A CD F0 99                             call	AequAdivQmul96		;  TIS2 \ *96/Q
 131+ 985D 32 A7 9E                             ld		(XX15+0),a
 132+ 9860 3A A8 9E                             ld		a,(XX15+1)
 133+ 9863 CD F0 99                             call	AequAdivQmul96		;  TIS2 \ *96/Q
 134+ 9866 32 A8 9E                             ld		(XX15+1),a
 135+ 9869 3A A8 9E                             ld		a,(XX15+1)
 136+ 986C CD F0 99                             call	AequAdivQmul96		;  TIS2 \ *96/Q
 137+ 986F 32 A8 9E                             ld		(XX15+1),a
 138+ 9872 C9                                   ret
 139+ 9873
 140+ 9873
# file closed: ./Maths/normalise96.asm
 139  9873                  INCLUDE "./Maths/binary_to_decimal.asm"
# file opened: ./Maths/binary_to_decimal.asm
   1+ 9873              ;Number in hl to decimal ASCII
   2+ 9873              ;Thanks to z80 Bits
   3+ 9873              ;inputs:	hl = number to ASCII
   4+ 9873              ;example: hl=300 outputs '00300'
   5+ 9873              ;destroys: af, bc, hl, de used
   6+ 9873              DispHLtoDE:
   7+ 9873              ; "DispHL, writes HL to DE address"
   8+ 9873 01 F0 D8     	ld	bc,-10000
   9+ 9876 CD 8C 98     	call	Num1
  10+ 9879 01 18 FC     	ld	bc,-1000
  11+ 987C CD 8C 98     	call	Num1
  12+ 987F 01 9C FF     	ld	bc,-100
  13+ 9882 CD 8C 98     	call	Num1
  14+ 9885 0E F6        	ld	c,-10
  15+ 9887 CD 8C 98     	call	Num1
  16+ 988A 0E FF        	ld	c,-1
  17+ 988C              Num1:
  18+ 988C 3E 2F        	ld	a,'0'-1
  19+ 988E              .Num2:
  20+ 988E 3C           	inc	a
  21+ 988F 09           	add	hl,bc
  22+ 9890 38 FC        	jr	c,.Num2
  23+ 9892 ED 42        	sbc	hl,bc
  24+ 9894 12           	ld	(de),a
  25+ 9895 13           	inc	de
  26+ 9896 C9           	ret
  27+ 9897
  28+ 9897              DispAtoDE:
  29+ 9897 26 00        	ld h,0
  30+ 9899 6F           	ld l,a
  31+ 989A C3 73 98     	jp DispHLtoDE
  32+ 989D
  33+ 989D              DispPriceAtoDE:
  34+ 989D 26 00        	ld h,0
  35+ 989F 6F           	ld l,a
  36+ 98A0 01 9C FF     	ld	bc,-100
  37+ 98A3 CD B3 98     	call	.NumLeadBlank1
  38+ 98A6 0E F6        	ld	c,-10
  39+ 98A8 CD 8C 98     	call	Num1
  40+ 98AB 3E 2E        	ld		a,'.'					; we could assume preformat but
  41+ 98AD 12           	ld		(de),a					; we can optimse that later TODO
  42+ 98AE 13           	inc		de						; with just an inc De
  43+ 98AF 0E FF        	ld	c,-1
  44+ 98B1 18 D9        	jr		Num1
  45+ 98B3              .NumLeadBlank1:
  46+ 98B3 3E 2F        	ld	a,'0'-1
  47+ 98B5              .NumLeadBlank2:
  48+ 98B5 3C           	inc	a
  49+ 98B6 09           	add	hl,bc
  50+ 98B7 38 FC        	jr	c,.NumLeadBlank2
  51+ 98B9 FE 30        	cp	'0'
  52+ 98BB 20 02        	jr	nz,.DontBlank
  53+ 98BD              .Blank:
  54+ 98BD 3E 20        	ld	a,' '
  55+ 98BF              .DontBlank:
  56+ 98BF ED 42        	sbc	hl,bc
  57+ 98C1 12           	ld	(de),a
  58+ 98C2 13           	inc	de
  59+ 98C3 C9           	ret
  60+ 98C4
  61+ 98C4              DispQtyAtoDE:
  62+ 98C4 FE 00        	cp	0
  63+ 98C6 28 23        	jr	z,.NoStock
  64+ 98C8 26 00        	ld h,0
  65+ 98CA 6F           	ld l,a
  66+ 98CB 01 9C FF     	ld	bc,-100
  67+ 98CE CD DA 98     	call	.NumLeadBlank1
  68+ 98D1 0E F6        	ld	c,-10
  69+ 98D3 CD DA 98     	call	.NumLeadBlank1
  70+ 98D6 0E FF        	ld	c,-1
  71+ 98D8 18 B2        	jr		Num1
  72+ 98DA              .NumLeadBlank1:
  73+ 98DA 3E 2F        	ld	a,'0'-1
  74+ 98DC              .NumLeadBlank2:
  75+ 98DC 3C           	inc	a
  76+ 98DD 09           	add	hl,bc
  77+ 98DE 38 FC        	jr	c,.NumLeadBlank2
  78+ 98E0 FE 30        	cp	'0'
  79+ 98E2 20 02        	jr	nz,.DontBlank
  80+ 98E4              .Blank:
  81+ 98E4 3E 20        	ld	a,' '
  82+ 98E6              .DontBlank:
  83+ 98E6 ED 42        	sbc	hl,bc
  84+ 98E8 12           	ld	(de),a
  85+ 98E9 13           	inc	de
  86+ 98EA C9           	ret
  87+ 98EB              .NoStock:
  88+ 98EB 3E 20        	ld	a,' '
  89+ 98ED 12           	ld	(de),a
  90+ 98EE 13           	inc	de
  91+ 98EF 12           	ld	(de),a
  92+ 98F0 13           	inc	de
  93+ 98F1 3E 2D        	ld	a,'-'
  94+ 98F3 12           	ld	(de),a
  95+ 98F4 13           	inc de
  96+ 98F5 C9           	ret
  97+ 98F6
  98+ 98F6
  99+ 98F6              ;### CLCN32 -> Converts 32Bit-Value in ASCII-String (terminated by 0)
 100+ 98F6              ;### Input      DE,IX=32bit value, IY=destination address
 101+ 98F6              ;### Output     IY=last char in destination string
 102+ 98F6              ;### Destroyed AF,BC,DE,HL,IX
 103+ 98F6 01 00 00 00  clcn32t dw 1,0,     10,0,     100,0,     1000,0,       10000,0
 103+ 98FA 0A 00 00 00
 103+ 98FE 64 00 00 00
 103+ 9902 E8 03 00 00
 103+ 9906 10 27 00 00
 104+ 990A A0 86 01 00          dw $86a0,1, $4240,$0f, $9680,$98, $e100,$05f5, $ca00,$3b9a
 104+ 990E 40 42 0F 00
 104+ 9912 80 96 98 00
 104+ 9916 00 E1 F5 05
 104+ 991A 00 CA 9A 3B
 105+ 991E 00 00 00 00  clcn32z ds 4
 106+ 9922
 107+ 9922              ; As per display but shifts final digit by 1 and puts in "." for 1 decimal place
 108+ 9922 CD 31 99     DispDEIXtoIY1DP:        call    DispDEIXtoIY
 109+ 9925 FD 7E 00                             ld      a,(IY+0)
 110+ 9928 FD 77 01                             ld      (IY+1),a
 111+ 992B 3E 2E                                ld      a,"."
 112+ 992D FD 77 00                             ld      (IY+0),a
 113+ 9930 C9                                   ret
 114+ 9931
 115+ 9931 DD 22 1E 99  DispDEIXtoIY:           ld (clcn32z),ix
 116+ 9935 ED 53 20 99                          ld (clcn32z+2),de
 117+ 9939 DD 21 1A 99                          ld ix,clcn32t+36
 118+ 993D 06 09                                ld b,9
 119+ 993F 0E 00                                ld c,0
 120+ 9941 3E 30        .clcn321:               ld a,'0'
 121+ 9943 B7                                   or a
 122+ 9944 DD 5E 00     .clcn322:               ld e,(ix+0)
 123+ 9947 DD 56 01                             ld d,(ix+1)
 124+ 994A 2A 1E 99                             ld hl,(clcn32z)
 125+ 994D ED 52                                sbc hl,de
 126+ 994F 22 1E 99                             ld (clcn32z),hl
 127+ 9952 DD 5E 02                             ld e,(ix+2)
 128+ 9955 DD 56 03                             ld d,(ix+3)
 129+ 9958 2A 20 99                             ld hl,(clcn32z+2)
 130+ 995B ED 52                                sbc hl,de
 131+ 995D 22 20 99                             ld (clcn32z+2),hl
 132+ 9960 38 04                                jr c,.clcn325
 133+ 9962 0C                                   inc c
 134+ 9963 3C                                   inc a
 135+ 9964 18 DE                                jr .clcn322
 136+ 9966 DD 5E 00     .clcn325:               ld e,(ix+0)
 137+ 9969 DD 56 01                             ld d,(ix+1)
 138+ 996C 2A 1E 99                             ld hl,(clcn32z)
 139+ 996F 19                                   add hl,de
 140+ 9970 22 1E 99                             ld (clcn32z),hl
 141+ 9973 DD 5E 02                             ld e,(ix+2)
 142+ 9976 DD 56 03                             ld d,(ix+3)
 143+ 9979 2A 20 99                             ld hl,(clcn32z+2)
 144+ 997C ED 5A                                adc hl,de
 145+ 997E 22 20 99                             ld (clcn32z+2),hl
 146+ 9981 11 FC FF                             ld de,-4
 147+ 9984 DD 19                                add ix,de
 148+ 9986 0C                                   inc c
 149+ 9987 0D                                   dec c
 150+ 9988 28 05                                jr z,.clcn323
 151+ 998A FD 77 00                             ld (iy+0),a
 152+ 998D FD 23                                inc iy
 153+ 998F 10 B0        .clcn323:               djnz .clcn321
 154+ 9991 3A 1E 99                             ld a,(clcn32z)
 155+ 9994 C6 30                                add A,'0'
 156+ 9996 FD 77 00                             ld (iy+0),a
 157+ 9999 FD 36 01 00                          ld (iy+1),0
 158+ 999D C9                                   ret
 159+ 999E
# file closed: ./Maths/binary_to_decimal.asm
 140  999E                  include "./Maths/ADDHLDESignBC.asm"
# file opened: ./Maths/ADDHLDESignBC.asm
   1+ 999E              ;; calcs HLB + DEC where B and C are signs
   2+ 999E              ;; result HL with A as sign
   3+ 999E              ;; special handling if result is zero forcign sign bit to be zero
   4+ 999E 78           ADDHLDESignBC:          ld      a,b
   5+ 999F E6 80                                and     SignOnly8Bit
   6+ 99A1 A9                                   xor     c                           ;if b sign and c sign were different then bit 7 of a will be 1 which means
   7+ 99A2                                      JumpIfNegative ADDHLDEsBCOppSGN     ;Signs are opposite there fore we can subtract to get difference
   7+ 99A2 FA B0 99    >                        jp		m, ADDHLDEsBCOppSGN
   8+ 99A5 78           ADDHLDEsBCSameSigns:    ld      a,b
   9+ 99A6 B1                                   or      c
  10+ 99A7                                      JumpIfNegative ADDHLDEsBCSameNeg        ; optimisation so we can just do simple add if both positive
  10+ 99A7 FA AC 99    >                        jp		m, ADDHLDEsBCSameNeg
  11+ 99AA 19                                   add     hl,de                       ; both positive so a will already be zero
  12+ 99AB C9                                   ret
  13+ 99AC 19           ADDHLDEsBCSameNeg:      add     hl,de
  14+ 99AD 78                                   ld      a,b
  15+ 99AE B1                                   or      c                           ; now set bit for negative value, we won't bother with overflow for now TODO
  16+ 99AF C9                                   ret
  17+ 99B0 B7           ADDHLDEsBCOppSGN:       or      a
  18+ 99B1 ED 52                                sbc     hl,de
  19+ 99B3 38 02                                jr      c,ADDHLDEsBCOppInvert
  20+ 99B5 78           ADDHLDEsBCOppSGNNoCarry: ld      a,b                                               ; we got here so hl > de therefore we can just take hl's previous sign bit
  21+ 99B6 C9                                   ret
  22+ 99B7              ADDHLDEsBCOppInvert:    NegHL                         ; if result was zero then set sign to zero (which doing h or l will give us for free)
  22+ 99B7 AF          >                    xor a
  22+ 99B8 95          >                    sub l
  22+ 99B9 6F          >                    ld l,a
  22+ 99BA 9F          >                    sbc a,a
  22+ 99BB 94          >                    sub h
  22+ 99BC 67          >                    ld h,a
  23+ 99BD 78                                   ld      a,b
  24+ 99BE EE 80                                xor     SignOnly8Bit                ; flip sign bit
  25+ 99C0 C9                                   ret
  26+ 99C1
# file closed: ./Maths/ADDHLDESignBC.asm
 141  99C1                  INCLUDE "./Maths/Utilities/AequAdivQmul96-TIS2.asm"
# file opened: ./Maths/Utilities/AequAdivQmul96-TIS2.asm
   1+ 99C1              AequAdivQmul96ABS:      JumpIfAGTENusng d, .TIS2AccGTEQ			; if A >= Q then return with a 1 (unity i.e. 96) with the correct sign
   1+ 99C1 BA          >                        cp     d
   1+ 99C2 D2 DD 99    >                        jp		nc,.TIS2AccGTEQ
   2+ 99C5 06 FE                                ld			b,$FE						; division roll (replaced varT)
   3+ 99C7 CB 27        .TIS2RollTLoop:			sla			a
   4+ 99C9                                      JumpIfALTNusng d,.TIS2SkipSub           ; a < d so don;t subtract
   4+ 99C9 BA          >                        cp      d
   4+ 99CA DA E0 99    >                        jp		c, .TIS2SkipSub
   5+ 99CD 9A                                   sbc			a,d							; do subtraction with carry
   6+ 99CE 37                                   scf
   7+ 99CF CB 10                                rl			b							; T rolled left to push bit out the end
   8+ 99D1 38 F4                                jr			c,.TIS2RollTLoop				; if we still have not hit the empty marker continue
   9+ 99D3 78           .TIS2SKIPCont:	        ld			a,b							; T
  10+ 99D4 CB 3F                                srl			a							; result / 2
  11+ 99D6 CB 3F                                srl			a							; result / 4
  12+ 99D8 47                                   ld			b,a							; t = t /4
  13+ 99D9 CB 3F                                srl			a							; result / 8
  14+ 99DB 80                                   add			a,b							; result /8 + result /4
  15+ 99DC C9                                   ret
  16+ 99DD 3E 60        .TIS2AccGTEQ:           ld			a,$60							; unity
  17+ 99DF C9                                   ret
  18+ 99E0 B7           .TIS2SkipSub:           or			a
  19+ 99E1 CB 10                                rl			b							; T rolled left to push bit out the end
  20+ 99E3 38 E2                                jr			c,.TIS2RollTLoop				; if we still have not hit the empty marker continue
  21+ 99E5 C3 D3 99                             jp			.TIS2SKIPCont
  22+ 99E8
  23+ 99E8
  24+ 99E8              ; USES 			A DE BC
  25+ 99E8              ; DOES NOT USE 	HL
  26+ 99E8              TIS2962C:		; two's compliment entry point, exits not 2's compliment
  27+ 99E8 CB 7F        	bit			7,a
  28+ 99EA 28 04        	jr			z,AequAdivQmul96
  29+ 99EC ED 44        	neg										; revers 2s'c and just set neg bit
  30+ 99EE CB FF        	set			7,a
  31+ 99F0              ; Note negative numbers are bit 7 set not 2's compliment
  32+ 99F0              AequAdivQmul96:								; TIS296:			; .tis2 A = A /Q *96 (or A = A * 3/8 * Q) Reduce Acc in NORM routine i.e. *96/Q clamps at +- 96
  33+ 99F0              TIS2:
  34+ 99F0 4F           	ld			c,a							; copy of Acc
  35+ 99F1 3A 66 84     	ld			a,(varQ)
  36+ 99F4 57           	ld			d,a							; d = varQ
  37+ 99F5 79           	ld			a,c							; recover a
  38+ 99F6              AequAdivDmul96:
  39+ 99F6 4F           	ld			c,a							; copy of Acc as we need the sign, alternate entry point assuming D preloaded, wastes an "ld c,a" but simplifies code
  40+ 99F7 E6 7F        	and			SignMask8Bit				; ignore sign
  41+ 99F9              	JumpIfAGTENusng d, .TIS2AccGTEQ			; if A >= Q then return with a 1 (unity i.e. 96) with the correct sign
  41+ 99F9 BA          >                        cp     d
  41+ 99FA D2 1A 9A    >                        jp		nc,.TIS2AccGTEQ
  42+ 99FD 06 FE        	ld			b,$FE						; division roll (replaced varT)
  43+ 99FF              .TIS2RollTLoop:									; .TIL2	; roll T
  44+ 99FF CB 27        	sla			a
  45+ 9A01              	JumpIfALTNusng d,.TIS2SkipSub            ; a < d so don;t subtract
  45+ 9A01 BA          >                        cp      d
  45+ 9A02 DA 20 9A    >                        jp		c, .TIS2SkipSub
  46+ 9A05 9A           	sbc			a,d							; do subtraction with carry
  47+ 9A06 37           	scf
  48+ 9A07 CB 10        	rl			b							; T rolled left to push bit out the end
  49+ 9A09 38 F4        	jr			c,.TIS2RollTLoop				; if we still have not hit the empty marker continue
  50+ 9A0B              .TIS2SKIPCont:
  51+ 9A0B 78           	ld			a,b							; T
  52+ 9A0C CB 3F        	srl			a							; result / 2
  53+ 9A0E CB 3F        	srl			a							; result / 4
  54+ 9A10 47           	ld			b,a							; t = t /4
  55+ 9A11 CB 3F        	srl			a							; result / 8
  56+ 9A13 80           	add			a,b							; result /8 + result /4
  57+ 9A14 47           	ld			b,a							; b = 3/8*Acc (max = 96)
  58+ 9A15 79           	ld			a,c							; copy of Acc to look at sign bit
  59+ 9A16 E6 80        	and			$80							; recover sign only
  60+ 9A18 B0           	or			b							; now put b back in so we have a leading sign bit (note not 2's compliment)
  61+ 9A19 C9           	ret
  62+ 9A1A              .TIS2AccGTEQ:
  63+ 9A1A              ;TI4:										;\ clean to +/- unity
  64+ 9A1A 79           	ld			a,c
  65+ 9A1B E6 80        	and			$80							; copy of Acc
  66+ 9A1D F6 60        	or			$60							; unity
  67+ 9A1F C9           	ret
  68+ 9A20              .TIS2SkipSub:
  69+ 9A20 B7           	or			a
  70+ 9A21 CB 10        	rl			b							; T rolled left to push bit out the end
  71+ 9A23 38 DA        	jr			c,.TIS2RollTLoop				; if we still have not hit the empty marker continue
  72+ 9A25 C3 0B 9A     	jp			.TIS2SKIPCont
  73+ 9A28
# file closed: ./Maths/Utilities/AequAdivQmul96-TIS2.asm
 142  9A28                  INCLUDE "./Maths/Utilities/AequAmulQdiv256-FMLTU.asm"
# file opened: ./Maths/Utilities/AequAmulQdiv256-FMLTU.asm
   1+ 9A28              fmltu:
   2+ 9A28              AequAmulQdiv256:
   3+ 9A28              ; "ASM_FMUTKL .FMLTU	\ -> &2847  \ A=A*Q/256unsg  Fast multiply"
   4+ 9A28 57           	ld	d,a
   5+ 9A29 3A 66 84     	ld	a,(varQ)
   6+ 9A2C 5F           	ld	e,a
   7+ 9A2D ED 30        	mul
   8+ 9A2F 7A           	ld	a,d				; we get only the high byte which is like doing a /256 if we think of a as low
   9+ 9A30 C9           	ret
  10+ 9A31
# file closed: ./Maths/Utilities/AequAmulQdiv256-FMLTU.asm
 143  9A31                  INCLUDE "./Maths/Utilities/PRequSpeedDivZZdiv8-DV42-DV42IYH.asm"
# file opened: ./Maths/Utilities/PRequSpeedDivZZdiv8-DV42-DV42IYH.asm
   1+ 9A31              ; "DV42,DV42IYH DE = P.R, c = R"
   2+ 9A31              DV42IYH:									; as per DV42 but using iyl for Y reg
   3+ 9A31 21 46 87     		ld		hl,varDustZ
   4+ 9A34 FD 7D        		ld		a,iyl
   5+ 9A36 ED 31        		add		hl,a
   6+ 9A38 7E           		ld		a,(hl)
   7+ 9A39 C3 45 9A     		jp		DV41
   8+ 9A3C              DV42:										; travel step of dust particle front/rear
   9+ 9A3C 21 46 87     		ld		hl,varDustZ
  10+ 9A3F 3A 51 83     		ld		a,(regY)
  11+ 9A42 ED 31        		add		hl,a
  12+ 9A44 7E           		ld		a,(hl)						; a = SZ[y]
  13+ 9A45              DV41:										; P.R = speed/ (ZZ/8) dust left/right
  14+ 9A45 5F           		ld		e,a							; using E as Q var replacement
  15+ 9A46 3A 62 84     		ld		a,(DELTA)					; DELTA \ speed, how far has dust moved based on its z-coord.
  16+ 9A49              DVID4:										; P-R=A/Qunsg  \P.R = A/Q unsigned called by Hall
  17+ 9A49 06 08        		ld		b,8							; counter
  18+ 9A4B CB 27        		sla		a							;
  19+ 9A4D 57           		ld		d,a							; use d for - p = delta * 2
  20+ 9A4E AF           		xor		a
  21+ 9A4F              DVL4:										; counter x loop (b reg)
  22+ 9A4F CB 17        		rl		a							; a = a * 2
  23+ 9A51 38 03        		jr		c,DV8						; jump on carry
  24+ 9A53 BB           		cp		e							; var Q
  25+ 9A54 38 02        		jr		c,DV5						; skip subtraction
  26+ 9A56              DV8:
  27+ 9A56 9B           		sbc		a,e							; a = a - q (with carry)
  28+ 9A57 37           		scf									;  carry gets set
  29+ 9A58              DV5:										; skipped subtraction
  30+ 9A58 CB 12        		rl		d							; d (P hi)
  31+ 9A5A 10 F3        		djnz	DVL4						; dec b and loop loop X, hi left in P.
  32+ 9A5C              .CalcRemainder:								; BFRDIV R=A*256/Q
  33+ 9A5C              ; Note we are not going to call LL28+4 but inline code here:
  34+ 9A5C 06 FE        		ld		b,$FE						; remainder R for AofQ *256/Q
  35+ 9A5E 4F           		ld		c,a							; use c as R var
  36+ 9A5F              .RollRemainder:
  37+ 9A5F CB 27        		sla		a
  38+ 9A61 38 11        		jr		c,.Reduce					; if a >> generates carry reduce
  39+ 9A63 B8           		cp		b							; a < q?
  40+ 9A64 30 01        		jr		nc,.DontSBC
  41+ 9A66              .DoSBC:										; a is < q
  42+ 9A66 98           		sbc		a,b							; 	a -= q
  43+ 9A67              .DontSBC:
  44+ 9A67 CB 11        		rl		c							; r << 1
  45+ 9A69 38 F4        		jr		c, .RollRemainder			; if rol generated a carry, continue
  46+ 9A6B 79           		ld		a,c
  47+ 9A6C 32 67 84     		ld		(varR),a					; for backwards compat
  48+ 9A6F 7A           		ld		a,d
  49+ 9A70 32 63 83     		ld		(varP),a
  50+ 9A73 C9           		ret									; R (c) left with remainder
  51+ 9A74              .Reduce:									; a geneated a carry
  52+ 9A74 98           		sbc		a,b							; a = a - (q +1)
  53+ 9A75 37           		scf									; set carry flag for rl
  54+ 9A76 CB 11        		rl		c							; r << 1 briging in carry
  55+ 9A78 38 E5        		jr		c,	.RollRemainder			; if a carry fell off bit 7 then repeat
  56+ 9A7A 79           		ld		a,c
  57+ 9A7B 32 67 84     		ld		(varR),a					; for backwards compat
  58+ 9A7E 7A           		ld		a,d
  59+ 9A7F 32 63 83     		ld		(varP),a
  60+ 9A82 C9           		ret
  61+ 9A83              .AnswerTooBig:
  62+ 9A83 0E FF        		ld		c,$FF						; arse its too big
  63+ 9A85 79           		ld		a,c
  64+ 9A86 32 67 84     		ld		(varR),a					; for backwards compat
  65+ 9A89 7A           		ld		a,d
  66+ 9A8A 32 63 83     		ld		(varP),a
  67+ 9A8D C9           		ret
  68+ 9A8E
# file closed: ./Maths/Utilities/PRequSpeedDivZZdiv8-DV42-DV42IYH.asm
 144  9A8E                  INCLUDE "./Maths/Utilities/AequDmulEdiv256usgn-DEFMUTL.asm"
# file opened: ./Maths/Utilities/AequDmulEdiv256usgn-DEFMUTL.asm
   1+ 9A8E
   2+ 9A8E              asm_defmutl:
   3+ 9A8E              AequDmulEdiv256usgn:
   4+ 9A8E              ; "ASM_FMUTKL .FMLTU	\ -> &2847  \ A=D*E/256unsg  Fast multiply"
   5+ 9A8E ED 30        	mul
   6+ 9A90 7A           	ld	a,d				; we get only the high byte which is like doing a /256 if we think of a as low
   7+ 9A91 C9           	ret
   8+ 9A92
   9+ 9A92
# file closed: ./Maths/Utilities/AequDmulEdiv256usgn-DEFMUTL.asm
 145  9A92                  INCLUDE "./Maths/Utilities/APequQmulA-MULT1.asm"
# file opened: ./Maths/Utilities/APequQmulA-MULT1.asm
   1+ 9A92              APequQmulA:
   2+ 9A92              asm_mult1:
   3+ 9A92              ; "ASM_MULT1 (DE) A(hi).P(lo) = Q * A first part of MAD, multiply and add. Visited Quite often. A=hi P = lo also returns result in DE"
   4+ 9A92 FE 00        	cp	0
   5+ 9A94 28 1F        	jr	z,.mul0			; quick exit if its Q * 0
   6+ 9A96 5F           	ld	e,a
   7+ 9A97 3A 66 84     	ld	a,(varQ)
   8+ 9A9A 57           	ld	d,a
   9+ 9A9B FE 00        	cp	0				; compare a
  10+ 9A9D 28 16        	jr	z,.mul0			; quick exit if its 0 * a
  11+ 9A9F AB           	xor	e				; -- = + +- = - -+ = - ++ = +
  12+ 9AA0 E6 80        	and $80				; get the resultant sign and save into b
  13+ 9AA2 47           	ld	b,a
  14+ 9AA3 7A           	ld	a,d
  15+ 9AA4 E6 7F        	and	SignMask8Bit	; now strip off sign bits
  16+ 9AA6 57           	ld	d,a
  17+ 9AA7 7B           	ld	a,e
  18+ 9AA8 E6 7F        	and SignMask8Bit
  19+ 9AAA 5F           	ld	e,a
  20+ 9AAB ED 30        	mul					; zxn de = d * e
  21+ 9AAD 7B           	ld	a,e
  22+ 9AAE 32 63 83     	ld	(varP),a		; p = lo
  23+ 9AB1 7A           	ld	a,d				; a = hi
  24+ 9AB2 B0           	or	b				; de goes to a and varP also re-do sign bit
  25+ 9AB3 57           	ld	d,a				; we will work with de having result as we may bin vars later
  26+ 9AB4 C9           	ret
  27+ 9AB5              .mul0:
  28+ 9AB5 AF           	xor	a
  29+ 9AB6 32 63 83     	ld	(varP),a
  30+ 9AB9 57           	ld	d,a
  31+ 9ABA 5F           	ld  e,a
  32+ 9ABB C9           	ret
  33+ 9ABC
# file closed: ./Maths/Utilities/APequQmulA-MULT1.asm
 146  9ABC                  INCLUDE "./Maths/Utilities/badd_ll38.asm"
# file opened: ./Maths/Utilities/badd_ll38.asm
   1+ 9ABC              baddll38:				;.LL38	\ -> &4812 \ BADD(S)A=R+Q(SA) \ byte add (subtract)   (Sign S)A = R + Q*(Sign from A^S)
   2+ 9ABC              SAEquSRPlusAQ:
   3+ 9ABC              ; Calculate the following between sign-magnitude numbers:
   4+ 9ABC              ;   (S A) = (S R) + (A Q)
   5+ 9ABC              ; where the sign bytes only contain the sign bits, not magnitudes.
   6+ 9ABC              ; note goes wrong at <-127 >128 so need 16 bit version
   7+ 9ABC              ; so need to fix the issue with carry flag not returning a fault correctly
   8+ 9ABC              LL38:
   9+ 9ABC              ;	ld		d,a
  10+ 9ABC              ;	ld		a,(varQ)
  11+ 9ABC              ;	ld		e,a
  12+ 9ABC              ;	ld		a,(varS)
  13+ 9ABC              ;	ld		h,a
  14+ 9ABC              ;	ld		a,(varR)
  15+ 9ABC              ;	ld		l,a
  16+ 9ABC              ;	call	ADDHLDESignedv3
  17+ 9ABC              ;	ld		a,h
  18+ 9ABC              ;	ld		(varS),a
  19+ 9ABC              ;	ld		a,l
  20+ 9ABC              ;	ret
  21+ 9ABC              ; calculation table
  22+ 9ABC              ;   R     Q    Op            Sign calc
  23+ 9ABC              ;	10    5    Add           +    sign same add R sign
  24+ 9ABC              ;   -10   5    ABS Sub       -    sign diff ABS R > S sub R sign
  25+ 9ABC              ;   10   -5    ABS sub       +    sign diff ABS R > S sub R sign
  26+ 9ABC              ;	-10  -5    ABS Add       -    sign same add R sign
  27+ 9ABC              ;   5    10    Add           +    sign same add R sign
  28+ 9ABC              ;   -5   10    Swap ABS SUB  +    sign diff ABS Q > R swap SUB Q sign
  29+ 9ABC              ;   5    -10   swap ABS Sub  -    sign diff ABS Q > R swap SUB R sign
  30+ 9ABC              ;   -5   -10   ABS  add      -    sign same add R sign
  31+ 9ABC
  32+ 9ABC              ;   -10   5    ABS Sub       -    sign diff ABS R > S sub R sign
  33+ 9ABC              ;   10   -5    ABS sub       +    sign diff ABS R > S sub R sign
  34+ 9ABC              ;   -5   10    Swap ABS SUB  +    sign diff ABS Q > R swap SUB Q sign
  35+ 9ABC              ;   5    -10   swap ABS Sub  -    sign diff ABS Q > R swap SUB R sign
  36+ 9ABC
  37+ 9ABC
  38+ 9ABC              ; Calculate sign for Q from A and varS
  39+ 9ABC 21 68 84     	ld		hl,varS							;
  40+ 9ABF AE           	xor		(hl)							;  EOR &83		\ S	\ sign of operator is A xor S
  41+ 9AC0 FA CB 9A     	jp		m,.LL39Subtraction  			; if signs are different then we have subtraction
  42+ 9AC3 3A 66 84     	ld		a,(varQ)						; Q	\ else addition, S already correct
  43+ 9AC6 21 67 84     	ld		hl,varR
  44+ 9AC9 86           	add		a,(hl)							; a = Q + R
  45+ 9ACA C9           	ret										; Done carry set if overflow
  46+ 9ACB              .LL39Subtraction:							; 1 byte subtraction (S)A = R-Q
  47+ 9ACB 3A 67 84     	ld		a,(varR)						; a = R
  48+ 9ACE 21 66 84     	ld		hl,varQ                         ; Q
  49+ 9AD1              ;--	JumpIfALTMemHLusng LL39SwapSubtraction	; if a < (hl) then do LL39SwapSubtraction
  50+ 9AD1              	ClearCarryFlag                          ; we need to not use carry (6502 is different that it uses the compliement)
  50+ 9AD1 B7          >                        or a
  51+ 9AD2 9E           	sbc		a,(hl)							; A = R - Q which as R >= Q will always be a positive result
  52+ 9AD3 38 01            jr      c,.LL39SignCorrection
  53+ 9AD5              ;--    jr      a,.LL39ResultZero
  54+ 9AD5              ;--   JumpIfNegative LL39SignCorrection		; if there was underflow we have to correct sign
  55+ 9AD5              ;--	or		a								; Clear carry flag to say result is correct
  56+ 9AD5 C9           	ret
  57+ 9AD6              .LL39SignCorrection:
  58+ 9AD6 FE 00            cp      0                               ; if its 0 then neg will affect flag so we just zero result to save compute
  59+ 9AD8 28 0E            jr      z,.LL39ResultZero
  60+ 9ADA ED 44            neg                                     ; flip A 2'c value to positive
  61+ 9ADC 08           	ex		af,af'							; save A temporarily
  62+ 9ADD 3A 68 84     	ld		a,(varS)						; Flip Sign bit in varS
  63+ 9AE0 EE 80        	xor		$80							    ;
  64+ 9AE2 32 68 84     	ld		(varS),a                        ; flip sign bit of a
  65+ 9AE5 08           	ex		af,af'                          ; get back a which is the result
  66+ 9AE6                  ClearCarryFlag                          ; clear carry as NEG instrunction sets it for non zero
  66+ 9AE6 B7          >                        or a
  67+ 9AE7 C9           	ret
  68+ 9AE8              .LL39ResultZero:
  69+ 9AE8 32 68 84         ld      (varS),a                        ; a is zero at this stage so set sign as well
  70+ 9AEB                  ClearCarryFlag                          ; clear carry
  70+ 9AEB B7          >                        or a
  71+ 9AEC C9               ret
  72+ 9AED              ;--LL39SwapSubtraction:
  73+ 9AED              ;--	push	bc
  74+ 9AED              ;--	ld		b,a
  75+ 9AED              ;--	ld		a,(hl)
  76+ 9AED              ;--	sub		b
  77+ 9AED              ;--	pop		bc
  78+ 9AED              ;--	ex		af,af'							; do we flip here or negate. i think its flip as its overflowed unsigned
  79+ 9AED              ;--	ld		a,(varS)
  80+ 9AED              ;--	xor		$80
  81+ 9AED              ;--	ld		(varS),a
  82+ 9AED              ;--	ex		af,af'
  83+ 9AED              ;--	ret
  84+ 9AED
  85+ 9AED              ;;;;	baddll38:				;.LL38	\ -> &4812 \ BADD(S)A=R+Q(SA) \ byte add (subtract)   (Sign S)A = R + Q*(Sign from A^S)
  86+ 9AED              ;;;;; Calculate the following between sign-magnitude numbers:
  87+ 9AED              ;;;;;   (S A) = (S R) + (A Q)
  88+ 9AED              ;;;;; where the sign bytes only contain the sign bits, not magnitudes.
  89+ 9AED              ;;;;; note goes wrong at <-127 >128 so need 16 bit version
  90+ 9AED              ;;;;LL38:
  91+ 9AED              ;;;;; Calculate sign for Q from A and varS
  92+ 9AED              ;;;;	ld		hl,varS							;
  93+ 9AED              ;;;;	xor		(hl)							;  EOR &83		\ S	\ sign of operator is A xor S
  94+ 9AED              ;;;;	jp		m,.LL39Subtraction  			; if signs are different then we have subtraction
  95+ 9AED              ;;;;	ld		a,(varQ)						; Q	\ else addition, S already correct
  96+ 9AED              ;;;;	ld		hl,varR
  97+ 9AED              ;;;;	add		a,(hl)							; a = Q + R
  98+ 9AED              ;;;;	ret										; Done
  99+ 9AED              ;;;;.LL39Subtraction:							; 1 byte subtraction (S)A = R-Q
 100+ 9AED              ;;;;	ld		hl,varQ                         ;
 101+ 9AED              ;;;;	ld		a,(hl)
 102+ 9AED              ;;;;	JumpIfAGTENusng 128,LL39Sub16bit		; does this need to be 16 bit
 103+ 9AED              ;;;;	ld		a,(varR)						;
 104+ 9AED              ;;;;	ClearCarryFlag                          ; we need to not use carry (6502 is different that it uses the compliement)
 105+ 9AED              ;;;;	sbc		a,(hl)							; A = R - Q
 106+ 9AED              ;;;;	jr		c,.SignCorrection				; if there was underflow we have to correct sign
 107+ 9AED              ;;;;	or		a								; Clear carry flag to say result is correct
 108+ 9AED              ;;;;	ret
 109+ 9AED              ;;;;.SignCorrection:
 110+ 9AED              ;;;;    neg                                     ; flip A 2'c value to positive
 111+ 9AED              ;;;;	ex		af,af'							; save A temporarily
 112+ 9AED              ;;;;	ld		a,(varS)						; Flip Sign bit in varS
 113+ 9AED              ;;;;	xor		$80							    ;
 114+ 9AED              ;;;;	ld		(varS),a                        ; flip sign bit of a
 115+ 9AED              ;;;;	ex		af,af'                          ; get back a which is the result
 116+ 9AED              ;;;;	ret
 117+ 9AED              ;;;;LL39Sub16Bit:
 118+ 9AED              ;;;;	ld		e,a
 119+ 9AED              ;;;;	ld		d,0
 120+ 9AED              ;;;;	ld		a,(varR)
 121+ 9AED              ;;;;	ld		l,a
 122+ 9AED              ;;;;	ld		h,0
 123+ 9AED              ;;;;	ClearCarryFlag
 124+ 9AED              ;;;;	sbc		hl,de
 125+ 9AED              ;;;;	jr		c,.SignCorrection16bit
 126+ 9AED              ;;;;	bit		7,h
 127+ 9AED              ;;;;	jr		z,.GoodToReturn
 128+ 9AED              ;;;;.Needtonegate:
 129+ 9AED              ;;;;	macronegate16hl
 130+ 9AED              ;;;;.GoodToReturn
 131+ 9AED              ;;;;	ld		a,l
 132+ 9AED              ;;;;	or		a
 133+ 9AED              ;;;;	ret
 134+ 9AED              ;;;;.SignCorrection16bit:
 135+ 9AED              ;;;;	macronegate16hl
 136+ 9AED              ;;;;	ld		a,(varS)						; Flip Sign bit in varS
 137+ 9AED              ;;;;	xor		$80							    ;
 138+ 9AED              ;;;;	ld		(varS),a                        ; flip sign bit of a
 139+ 9AED              ;;;;	ld		a,l
 140+ 9AED              ;;;;	ret
 141+ 9AED
 142+ 9AED
# file closed: ./Maths/Utilities/badd_ll38.asm
 147  9AED                  INCLUDE "./Maths/Utilities/moveship4-MVS4.asm"
# file opened: ./Maths/Utilities/moveship4-MVS4.asm
   1+ 9AED              ; Note comparing hl vs iY, you need at least 3 incs or decs for hl to be slower
   2+ 9AED              ; it may be faster though if we can use hl to avoid memory actions if needed
   3+ 9AED              ; need to optimise mad as push hl pop hl and use de doesn't really improve speed
   4+ 9AED
   5+ 9AED
   6+ 9AED              moveship4Yreg:
   7+ 9AED 3A 51 83     		ld		a,(regY)
   8+ 9AF0 47           		ld		b,a
   9+ 9AF1              moveship4breg:
  10+ 9AF1              		; b = Y index, 9 = nosev, 15 = roofv 21 = sidev
  11+ 9AF1              MVS4PitchAlphaRollBeta:
  12+ 9AF1              MVS4:										;.MVS4	\ -> &52A1 \ Moveship4, Y is matrix row, pitch&roll update to coordinates
  13+ 9AF1 3A 7C 83     		ld		a,(ALPHA)					;  ALPHA
  14+ 9AF4 32 66 84     		ld		(varQ),a					; player ship's roll Q = Alpha
  15+ 9AF7 21 02 00     		ld		hl,UBnKxsgn
  16+ 9AFA 78           		ld		a,b							; from
  17+ 9AFB ED 31        		add		hl,a
  18+ 9AFD 7E           		ld		a,(hl)						; INWK+2,Y
  19+ 9AFE 32 67 84     		ld		(varR),a					; R  \ lo
  20+ 9B01 23           		inc		hl
  21+ 9B02 7E           		ld		a,(hl)						; INWK+3,Y
  22+ 9B03 32 68 84     		ld		(varS),a					; S  \ hi		SR = nosev_y (or axis y)
  23+ 9B06 2B           		dec		hl
  24+ 9B07 2B           		dec		hl
  25+ 9B08 2B           		dec		hl							;
  26+ 9B09 7E           		ld		a,(hl)						; INWK+0,Y
  27+ 9B0A 32 63 83     		ld		(varP),a					; P  \ over-written	 P = nosevx lo
  28+ 9B0D 23           		inc		hl
  29+ 9B0E 7E           		ld		a,(hl)						; INWK+1,Y
  30+ 9B0F EE 80        		xor		$80							; flip sign  AP = nosevx * - 1
  31+ 9B11 CD 67 93     		call	madXAequQmulAaddRS			; MAD	\ DE = X.A = alpha*INWK+1,Y + INWK+2to3,Y
  32+ 9B14 23                   inc     hl
  33+ 9B15 23                   inc     hl
  34+ 9B16 77                   ld      (hl),a                      ; INWK+3,Y \ hi
  35+ 9B17 2B                   dec     hl
  36+ 9B18 3A 50 83             ld      a,(regX)
  37+ 9B1B 77                   ld      (hl),a                      ; INWK+2,Y \ Y=Y-aX   \ their comment
  38+ 9B1C 32 63 83             ld      (varP),a                    ;  P
  39+ 9B1F 2B                   dec     hl
  40+ 9B20 2B                   dec     hl
  41+ 9B21 7E                   ld      a,(hl)                      ; INWK+0,Y
  42+ 9B22 32 67 84             ld      (varR),a                    ;  R	\ lo
  43+ 9B25 23                   inc     hl
  44+ 9B26 7E                   ld      a,(hl)                      ;  INWK+1,Y
  45+ 9B27 32 68 84             ld      (varS),a                    ; S	\ hi
  46+ 9B2A 23                   inc     hl
  47+ 9B2B 23                   inc     hl
  48+ 9B2C 7E                   ld      a,(hl)                      ; INWK+3,Y
  49+ 9B2D CD 67 93             call    madXAequQmulAaddRS          ; MAD	\ X.A = alpha*INWK+3,Y + INWK+0to1,Y
  50+ 9B30 2B                   dec     hl
  51+ 9B31 2B                   dec     hl
  52+ 9B32 77                   ld      (hl),a                      ; INWK+1,Y  \ hi
  53+ 9B33 3A 50 83             ld      a,(regX)
  54+ 9B36 2B                   dec     hl
  55+ 9B37 77                   ld      (hl),a                      ; INWK+0,Y  \ X=X+aY   \ their comment
  56+ 9B38 32 63 83             ld      (varP),a                    ; P
  57+ 9B3B 3A 6E 83             ld      a,(BETA)                    ; BETA
  58+ 9B3E 32 66 84             ld      (varQ),a                    ; Q	\ player ship's pitch
  59+ 9B41 23                   inc     hl
  60+ 9B42 23                   inc     hl
  61+ 9B43 7E                   ld      a,(hl)                      ; INWK+2,Y
  62+ 9B44 32 67 84             ld      (varR),a                    ; R	\ lo
  63+ 9B47 23                   inc     hl
  64+ 9B48 7E                   ld      a,(hl)                      ; INWK+3,Y
  65+ 9B49 32 68 84             ld      (varS),a                    ; S	\ hi
  66+ 9B4C 23                   inc     hl
  67+ 9B4D 7E                   ld      a,(hl)                      ; INWK+4,Y
  68+ 9B4E 32 63 83             ld      (varP),a                    ; P	\ lo
  69+ 9B51 23                   inc     hl
  70+ 9B52 7E                   ld      a,(hl)                      ; INWK+5,Y
  71+ 9B53 EE 80                xor     $80                         ; flip sign hi
  72+ 9B55 CD 67 93             call    madXAequQmulAaddRS          ; MAD	\ X.A =-beta*INWK+5,Y + INWK+2to3,Y
  73+ 9B58 2B                   dec     hl
  74+ 9B59 2B                   dec     hl
  75+ 9B5A 77                   ld      (hl),a                      ; INWK+3,Y \ hi
  76+ 9B5B 3A 50 83             ld      a,(regX)
  77+ 9B5E 2B                   dec     hl
  78+ 9B5F 77                   ld      (hl),a                      ; INWK+2,Y \ Y=Y-bZ  \ their comment
  79+ 9B60 32 63 83             ld      (varP),a                    ; P
  80+ 9B63 23                   inc     hl
  81+ 9B64 23                   inc     hl
  82+ 9B65 7E                   ld      a,(hl)                      ; INWK+4,Y
  83+ 9B66 32 67 84             ld      (varR),a                    ; R	\ lo
  84+ 9B69 23                   inc     hl
  85+ 9B6A 7E                   ld      a,(hl)                      ; INWK+5,Y
  86+ 9B6B 32 68 84             ld      (varS),a                    ; S	\ hi
  87+ 9B6E 2B                   dec     hl
  88+ 9B6F 2B                   dec     hl
  89+ 9B70 7E                   ld      a,(hl)                      ; INWK+3,Y
  90+ 9B71 CD 67 93             call    madXAequQmulAaddRS          ; MAD	\ X.A = beta*INWK+3,Y + INWK+4,5,Y
  91+ 9B74 23                   inc     hl
  92+ 9B75 23                   inc     hl
  93+ 9B76 77                   ld      (hl),a                      ; INWK+5,Y \ hi
  94+ 9B77 3A 50 83             ld      a,(regX)
  95+ 9B7A 2B                   dec     hl
  96+ 9B7B 77                   ld      (hl),a                      ; INWK+4,Y \ Z=Z+bY   \ their comment
  97+ 9B7C C9                   ret
  98+ 9B7D
  99+ 9B7D
# file closed: ./Maths/Utilities/moveship4-MVS4.asm
 148  9B7D                  INCLUDE "./Maths/Utilities/RequAmul256divQ-BFRDIV.asm"
# file opened: ./Maths/Utilities/RequAmul256divQ-BFRDIV.asm
   1+ 9B7D              ;;;LL28:
   2+ 9B7D              ;;;    ld      c,a                         ;
   3+ 9B7D              ;;;    ld      a,(varQ)                    ;
   4+ 9B7D              ;;;    ld      b,a                         ;
   5+ 9B7D              ;;;    ld      a,c                         ; Get varQ into b and retain c
   6+ 9B7D              ;;;RequAmul256divB:                        ;
   7+ 9B7D              ;;;LL28Breg:
   8+ 9B7D              ;;;; "BFRDIV R = (A * 256 / Q)  byte from remainder of division, not signed a = a, b = q, c = r"
   9+ 9B7D              ;;;	cp		b							; Check A >= Q
  10+ 9B7D              ;;;	jr		nc, .AnswerTooBig			; A >= Q? yes too big
  11+ 9B7D              ;;;.CalcRemainder:
  12+ 9B7D              ;;;	ld		c, 	$FE						; set R to $FE
  13+ 9B7D              ;;;.RollRemainder:
  14+ 9B7D              ;;;	sla		a
  15+ 9B7D              ;;;	jr		c,.Reduce					; if a >> generates carry reduce
  16+ 9B7D              ;;;	cp		b							; a < q?
  17+ 9B7D              ;;;	jr		nc,.DontSBC
  18+ 9B7D              ;;;.DoSBC:									; a is < q
  19+ 9B7D              ;;;	sbc		a,b							; 	a -= q
  20+ 9B7D              ;;;.DontSBC:
  21+ 9B7D              ;;;	rl		c							; r << 1
  22+ 9B7D              ;;;	jr		c, .RollRemainder			; if rol generated a carry, continue
  23+ 9B7D              ;;;    ld      a,c
  24+ 9B7D              ;;;    ld      (varR),a
  25+ 9B7D              ;;;	ret									; R (c) left with remainder
  26+ 9B7D              ;;;.Reduce:								; a geneated a carry
  27+ 9B7D              ;;;	sbc		a,b							; a = a - (q +1)
  28+ 9B7D              ;;;	scf									; set carry flag for rl
  29+ 9B7D              ;;;	rl		c							; r << 1 briging in carry
  30+ 9B7D              ;;;	jr		c,	.RollRemainder			; if a carry fell off bit 7 then repeat
  31+ 9B7D              ;;;    ld      a,c
  32+ 9B7D              ;;;    ld      (varR),a
  33+ 9B7D              ;;;	ret
  34+ 9B7D              ;;;.AnswerTooBig:
  35+ 9B7D              ;;;	ld	    c,$FF							; arse its too big
  36+ 9B7D              ;;;    ld      a,c
  37+ 9B7D              ;;;    ld      (varR),a
  38+ 9B7D              ;;;	ret
  39+ 9B7D
  40+ 9B7D              BCequAmul256DivC:
  41+ 9B7D 59             ld    e,c
  42+ 9B7E 67             ld    h,a
  43+ 9B7F 2E 00          ld    l,0
  44+ 9B81              AdivEDivide:                             ; this routine performs the operation BC=HL/E
  45+ 9B81 7B             ld a,e                                 ; checking the divisor; returning if it is zero
  46+ 9B82 B7             or a                                   ; from this time on the carry is cleared
  47+ 9B83 C8             ret z
  48+ 9B84 01 FF FF       ld bc,-1                               ; BC is used to accumulate the result
  49+ 9B87 16 00          ld d,0                                 ; clearing D, so DE holds the divisor
  50+ 9B89              AdivEDivLoop:                            ; subtracting DE from HL until the first overflow
  51+ 9B89 ED 52          sbc hl,de                              ; since the carry is zero, SBC works as if it was a SUB
  52+ 9B8B 03             inc bc                                 ;  note that this instruction does not alter the flags
  53+ 9B8C 30 FB          jr nc,AdivEDivLoop                     ; no carry means that there was no overflow
  54+ 9B8E C9             ret
  55+ 9B8F
  56+ 9B8F              HL_Div_C:
  57+ 9B8F              ; Integer divides HL by C
  58+ 9B8F              ; Result in HL, remainder in A
  59+ 9B8F              ; Clobbers F, B
  60+ 9B8F 06 10                ld b,16
  61+ 9B91 AF                   xor a
  62+ 9B92              HL_Div_C_Loop:
  63+ 9B92 29                   add hl,hl
  64+ 9B93 17                   rla
  65+ 9B94 B9                   cp c
  66+ 9B95 38 02                jr c,HL_DivC_Skip
  67+ 9B97 91                   sub c
  68+ 9B98 2C                   inc l
  69+ 9B99              HL_DivC_Skip:
  70+ 9B99 10 F7                djnz HL_Div_C_Loop
  71+ 9B9B 7D                   ld   a,l
  72+ 9B9C 32 67 84             ld  (varR),a
  73+ 9B9F C9                   ret
  74+ 9BA0
  75+ 9BA0
  76+ 9BA0
  77+ 9BA0              ; Entry point if varQ is populated with demoninator
  78+ 9BA0              RequAmul256divQ:
  79+ 9BA0              BFRDIV:
  80+ 9BA0 F5           		push	af
  81+ 9BA1 3A 66 84     		ld		a,(varQ)
  82+ 9BA4 4F           		ld		c,a
  83+ 9BA5 F1           		pop		af
  84+ 9BA6 FE 00        		cp		0
  85+ 9BA8 CA BF 9B     		jp		z, HLDIVC_0_BY	; fast exit if numerator is 0
  86+ 9BAB              RequAmul256divC:
  87+ 9BAB 2E 00        		ld		l,0
  88+ 9BAD 67           		ld		h,a
  89+ 9BAE              HL_Div_Cold:						; fast entry point if C and HL are already set
  90+ 9BAE 06 10        		ld b,16
  91+ 9BB0 AF           		xor a
  92+ 9BB1              LOOPPOINT:
  93+ 9BB1 29           		add hl,hl
  94+ 9BB2 17           		rla
  95+ 9BB3 B9           		cp c
  96+ 9BB4 38 02        		jr c,SKIPINCSUB
  97+ 9BB6 2C           		inc l
  98+ 9BB7 91           		sub c
  99+ 9BB8              SKIPINCSUB:
 100+ 9BB8 10 F7        		djnz LOOPPOINT
 101+ 9BBA 7D           		ld		a,l
 102+ 9BBB 32 67 84     		ld 		(varR),a
 103+ 9BBE C9           		ret
 104+ 9BBF              HLDIVC_0_BY:
 105+ 9BBF 32 67 84     		ld		(varR),a
 106+ 9BC2 C9           		ret
 107+ 9BC3              ;	push	af
 108+ 9BC3              ;	ld		a,b
 109+ 9BC3              ;	ld		(varQ),a
 110+ 9BC3              ;	pop		af
 111+ 9BC3              ;RequAmul256divQ:
 112+ 9BC3              ;BFRDIV:									;BFRDIV R=A*256/Q   byte from remainder of division
 113+ 9BC3              ;	ld		hl,varQ
 114+ 9BC3              ;	JumpIfAGTENusng	(hl),LL2			;  is A >=  Q ?, if yes, answer too big for 1 byte, R=#&FF
 115+ 9BC3              ;	ld		b,$FE						; b = X
 116+ 9BC3              ;	ld		c,a							; c = R	div roll counter
 117+ 9BC3              ;LL31:									; roll R
 118+ 9BC3              ;	sla		a
 119+ 9BC3              ;	jr		c,LL29						; hop to Reduce
 120+ 9BC3              ;	JumpIfALTNusng (hl)					; Q skip sbc if a < Q
 121+ 9BC3              ;	sbc		a,(hl)						; a = a - Q
 122+ 9BC3              ;	rl		c							; rotate R left
 123+ 9BC3              ;	jr		c,LL31						; loop if R poped out a carry bit
 124+ 9BC3              ;	jr		LL2Good
 125+ 9BC3              ;LL29:									; Reduce
 126+ 9BC3              ;	sbc		a,(hl)
 127+ 9BC3              ;	scf
 128+ 9BC3              ;	rl		c							; roll a carry flag into R
 129+ 9BC3              ;	jr		c,LL31						;  loop R
 130+ 9BC3              ;	jr		LL2Good
 131+ 9BC3              ;LL2:
 132+ 9BC3              ;	ld		c,$FF
 133+ 9BC3              ;LL2Good:
 134+ 9BC3              ;	ld		a,c
 135+ 9BC3              ;	ld		(varR),a
 136+ 9BC3              ;	ret
 137+ 9BC3
# file closed: ./Maths/Utilities/RequAmul256divQ-BFRDIV.asm
 149  9BC3                  INCLUDE "./Maths/Utilities/RequAdivQ-LL61.asm"
# file opened: ./Maths/Utilities/RequAdivQ-LL61.asm
   1+ 9BC3              RequAdivQ:
   2+ 9BC3              	; R = A/Q, U = remainder, code looked a little odd as if R is reminader and U = result
   3+ 9BC3              LL61:										; Handling division R=A/Q for case further down
   4+ 9BC3 4F           	ld		c,a								; c = A
   5+ 9BC4 3A 66 84     	ld		a,(varQ)						; test for divide by 0
   6+ 9BC7 FE 00        	cp		0
   7+ 9BC9 28 16        	jr		z,LL84							; divide by zero error
   8+ 9BCB 57           	ld		d,a								; now we can do C/D
   9+ 9BCC 06 08            ld b,8
  10+ 9BCE AF               xor a
  11+ 9BCF              LL63:										; roll divide loop
  12+ 9BCF CB 21            sla c
  13+ 9BD1 17               rla
  14+ 9BD2 BA               cp d
  15+ 9BD3 38 02            jr c,LL64
  16+ 9BD5 0C               inc c
  17+ 9BD6 92               sub d
  18+ 9BD7              LL64:
  19+ 9BD7 10 F6            djnz LL63
  20+ 9BD9 32 65 84     	ld	(varU),a							; store remainder in U
  21+ 9BDC 79           	ld	a,c
  22+ 9BDD 32 67 84     	ld	(varR),a							; store remainder in R
  23+ 9BE0 C9               ret
  24+ 9BE1              LL84:										; div error  R=U=#5
  25+ 9BE1 3E 32        	ld		a,50
  26+ 9BE3 32 67 84     	ld		(varR),a
  27+ 9BE6 32 65 84     	ld		(varU),a
  28+ 9BE9 C9           	ret
  29+ 9BEA
# file closed: ./Maths/Utilities/RequAdivQ-LL61.asm
 150  9BEA                  INCLUDE "./Maths/Utilities/RSequQmulA-MULT12.asm"
# file opened: ./Maths/Utilities/RSequQmulA-MULT12.asm
   1+ 9BEA              asm_mult12:
   2+ 9BEA              RSequQmulA:
   3+ 9BEA              ; "asm_ult12  R.S = Q * A \ visited quite often S = hi, R = lo, odd that its opposite to mult1"
   4+ 9BEA CD 92 9A     	call APequQmulA
   5+ 9BED 08           	ex 	af,af'
   6+ 9BEE 7A           	ld	a,d
   7+ 9BEF 32 68 84     	ld	(varS),a
   8+ 9BF2 7B           	ld	a,e
   9+ 9BF3 32 67 84     	ld	(varR),a
  10+ 9BF6 08           	ex 	af,af'
  11+ 9BF7 C9           	ret
  12+ 9BF8
# file closed: ./Maths/Utilities/RSequQmulA-MULT12.asm
 151  9BF8                  INCLUDE "./Maths/Utilities/LL28AequAmul256DivD.asm"
# file opened: ./Maths/Utilities/LL28AequAmul256DivD.asm
   1+ 9BF8
   2+ 9BF8              LL28Amul256DivD:        JumpIfAGTENusng  d, .Ll28Exit255
   2+ 9BF8 BA          >                        cp     d
   2+ 9BF9 D2 17 9C    >                        jp		nc,.Ll28Exit255
   3+ 9BFC 1E FE                                ld      e,%11111110                 ; Set R to have bits 1-7 set, so we can rotate through 7
   4+ 9BFE CB 27        .LL31:                  sla     a
   5+ 9C00 38 0D                                jr      c,.LL29
   6+ 9C02                                      JumpIfALTNusng  d, .SkipSub         ; will jump if carry set, so we need to reset on the rol
   6+ 9C02 BA          >                        cp      d
   6+ 9C03 DA 08 9C    >                        jp		c, .SkipSub
   7+ 9C06 92                                   sub     d
   8+ 9C07                                      ClearCarryFlag                      ; reset clarry as it will be complimented for rotate as 6502 does carry flags inverted
   8+ 9C07 B7          >                        or a
   9+ 9C08 3F           .SkipSub:               ccf                                 ; if we did the subtract the carry will be clear so we need to invert to roll in.
  10+ 9C09 CB 13                                rl      e
  11+ 9C0B 38 F1                                jr      c,.LL31
  12+ 9C0D 7B                                   ld      a,e
  13+ 9C0E C9                                   ret
  14+ 9C0F 92           .LL29:                  sub     d                           ; A >= Q, so set A = A - Q
  15+ 9C10 37                                   scf                                 ; Set the C flag to rotate into the result in R
  16+ 9C11 CB 13                                rl      e                           ; rotate counter e left
  17+ 9C13 38 E9                                jr      c,.LL31                     ; if a bit was spat off teh end then loop
  18+ 9C15 7B                                   ld      a,e                         ; stick result in a
  19+ 9C16 C9                                   ret
  20+ 9C17 3E FF        .Ll28Exit255:           ld  a,255                           ; Fail with FF as result
  21+ 9C19 C9                                   ret
  22+ 9C1A
# file closed: ./Maths/Utilities/LL28AequAmul256DivD.asm
 152  9C1A                  INCLUDE "./Maths/Utilities/XAequMinusXAPplusRSdiv96-TIS1.asm"
# file opened: ./Maths/Utilities/XAequMinusXAPplusRSdiv96-TIS1.asm
   1+ 9C1A              XAequMinusXAplusRSdiv96:					;.TIS1	\ -> &293B  \ Tidy subroutine 1  X.A =  (-X*A  + (R.S))/96
   2+ 9C1A              TIS1:
   3+ 9C1A 08           		ex		af,af'
   4+ 9C1B 3A 50 83     		ld		a,(regX)
   5+ 9C1E 47           		ld		b,a
   6+ 9C1F 08           		ex		af,af'
   7+ 9C20              BAequMinusBAplusRSdiv96:					;.TIS1	\ -> &293B  \ Tidy subroutine 1 using B register = X
   8+ 9C20 08           		ex		af,af'
   9+ 9C21 78           		ld		a,b
  10+ 9C22 32 66 84     		ld		(varQ),a
  11+ 9C25 08           		ex		af,af'
  12+ 9C26 EE 80        		xor		$80							;	 flip sign of Acc
  13+ 9C28 CD 67 93     		call	madXAequQmulAaddRS			; \ MAD \ multiply and add (X,A) =  -X*A  + (R,S)
  14+ 9C2B              ; USES 				A BC E
  15+ 9C2B              ; DOES NOT USE		D HL
  16+ 9C2B              Div96:										; .DVID96	\ Their comment A=A/96: answer is A*255/96
  17+ 9C2B 47           		ld		b,a
  18+ 9C2C E6 80        		and		$80							;	hi sign
  19+ 9C2E 5F           		ld		e,a							;   e = varT
  20+ 9C2F 78           		ld		a,b
  21+ 9C30 E6 7F        		and		$7F							;	hi A7
  22+ 9C32 06 FE        		ld		b,$FE						;   slide counter
  23+ 9C34 48           		ld		c,b							;   c == T1 ::  T1
  24+ 9C35              .DVL3:										;   roll T1  clamp Acc to #96 for rotation matrix unity
  25+ 9C35 CB 27        		sla		a
  26+ 9C37 FE 60        		cp		$60							; max 96
  27+ 9C39 30 02        		jr		nc,.DV4
  28+ 9C3B DE 60        		sbc		a,$60							;  SBC #&60
  29+ 9C3D              .DV4:										; skip subtraction
  30+ 9C3D CB 11        		rl		c							;  T1
  31+ 9C3F 38 F4        		jr		c,.DVL3
  32+ 9C41 79           		ld		a,c							;   T1
  33+ 9C42 B3           		or		e							;   restore T sign
  34+ 9C43 C9           		ret
  35+ 9C44
# file closed: ./Maths/Utilities/XAequMinusXAPplusRSdiv96-TIS1.asm
 153  9C44
 154  9C44
 155  9C44              ;--------------------------------------------------------------------------------------------------------------------
 156  9C44                  INCLUDE "./ModelRender/CLIP-LL145.asm"
# file opened: ./ModelRender/CLIP-LL145.asm
   1+ 9C44              ;--------------------------------------------------------------------------------------------------------------------
   2+ 9C44
   3+ 9C44 00           clipDx                  DB      0           ; also XX12+2
   4+ 9C45 00           clipDxHigh              DB      0           ; also XX12+3
   5+ 9C46 00           clipDxHighNonABS        DB      0           ; also XX12+3
   6+ 9C47 00           clipDy                  DB      0           ; also XX12+4
   7+ 9C48 00           clipDyHigh              DB      0           ; also XX12+5
   8+ 9C49 00           clipGradient            DB      0
   9+ 9C4A 00           clipDxySign             DB      0
  10+ 9C4B              varX12p3                equ     clipDxySign
  11+ 9C4B 00           clipXGTY                DB      0
  12+ 9C4C 00           clipFlags               DB      0
  13+ 9C4D 00           SWAP                    DB      0
  14+ 9C4E 00 00        varYX                   DW      0
  15+ 9C50              ;varRegX                 DB      0
  16+ 9C50              ;varXX12p2               DB      0
  17+ 9C50 00           clipXX13                 DB      0
  18+ 9C51
  19+ 9C51
  20+ 9C51              ; bounds check and the start to avoid dxy calcs if off screen, eliminating off screens first saves a lot of uncessary mul/div
  21+ 9C51              ;ClipXX15XX12Line:
  22+ 9C51 ED 4B A9 9E  ClipLine:               ld      bc,(UbnkPreClipY1)          ; bc - XX15(2,3)
  23+ 9C55 DD 2A AD 9E                          ld      ix,(UbnkPreClipY2)          ; ix - XX12(0,1)
  24+ 9C59 2A A7 9E                             ld      hl,(UbnkPreClipX1)          ; hl - XX15(0,1)
  25+ 9C5C ED 5B AB 9E                          ld      de,(UbnkPreClipX2)          ; de - XX15(4,5)
  26+ 9C60 AF                                   xor     a
  27+ 9C61 32 4D 9C                             ld      (SWAP),a                    ; SWAP = 0
  28+ 9C64 7A                                   ld      a,d                         ; A = X2Hi
  29+ 9C65 FD 26 BF     .LL147:                 ld      iyh,$BF                     ; we need to be 191 as its 128 + another bit set from 0 to 6, we are using iyh as regX
  30+ 9C68                                      ;       push    af
  31+ 9C68                                      ;       ld      a,iyh
  32+ 9C68                                      ;       ld      (regX),a
  33+ 9C68                                      ;       pop     af
  34+ 9C68 DD B4                                or      ixh                         ; if (X2Hi L-OR Y2 Hi <> 0) goto LL107             -- X2Y2 off screen
  35+ 9C6A 20 0A                                jr      nz, .LL107
  36+ 9C6C DD 7D                                ld      a,ixl
  37+ 9C6E ED 27 80                             test    $80                         ; if screen hight < y2 lo, i.e y2 lo >127 goto LL107,
  38+ 9C71 20 03                                jr      nz,.LL107
  39+ 9C73 FD 26 00                             ld      iyh, 0                      ; else iyh = regX = 0                                                                        -- X2Y2 on screen
  40+ 9C76                                      ;        push    af
  41+ 9C76                                      ;        ld      a,iyh
  42+ 9C76                                      ;        ld      (regX),a
  43+ 9C76                                      ;        pop     af
  44+ 9C76              ; XX13 = regX (i.e. iyh)      ( if XX13 = XX13 is 191 if (x2, y2) is off-screen else 0) we bin XX13 as not needed
  45+ 9C76              ; so XX13 = 0 if x2_hi = y2_hi = 0, y2_lo is on-screen,  XX13 = 191 if x2_hi or y2_hi are non-zero or y2_lo is off the bottom of the screen
  46+ 9C76 FD 7C        .LL107                  ld      a,iyh
  47+ 9C78 32 50 9C                             ld      (clipXX13),a                ; debug copy iyh to xx13
  48+ 9C7B 7C                                   ld      a,h                         ; If (X1 hi L-OR Y1) hi  goto LL83                   -- X1Y1 off screen and maybe X2Y2
  49+ 9C7C B0                                   or      b                           ;
  50+ 9C7D 20 27                                jr      nz,.LL83                    ;
  51+ 9C7F 79                                   ld      a,c                         ; or (y1 lo > bottom of screen)
  52+ 9C80 ED 27 80                             test    $80                         ; i.e  screen height < y1)
  53+ 9C83 20 21                                jr      nz,.LL83
  54+ 9C85              ; If we get here, (x1, y1) is on-screen
  55+ 9C85 FD 7C                                ld      a,iyh                       ; iyh = xx13 at this point if  XX13 <> 0 goto LL108                                                        -- X1Y1 on screen, if we flagged X2Y2 off screen goto LL108
  56+ 9C87 FE 00                                cp      0
  57+ 9C89 20 15                                jr      nz, .LL108
  58+ 9C8B              ; Finished clipping exit point ----------------------------------------------------------------------------------------
  59+ 9C8B 79           .ClipDone:              ld      a,c                         ; LL146 (Clip Done)               Y1 = y1 lo, x2 = x2 lo, x1 = x1 lo y1 = y1 lo                                   -- Nothing off screen
  60+ 9C8C 32 A8 9E                             ld      (UBnkNewY1),a
  61+ 9C8F DD 7D                                ld      a,ixl
  62+ 9C91 32 AA 9E                             ld      (UBnkNewY2),a
  63+ 9C94 7D                                   ld      a,l
  64+ 9C95 32 A7 9E                             ld      (UBnkNewX1),a
  65+ 9C98 7B                                   ld      a,e
  66+ 9C99 32 A9 9E                             ld      (UBnkNewX2),a
  67+ 9C9C                                      ClearCarryFlag                      ; carry is clear so valid to plot is in XX15(0to3)
  67+ 9C9C B7          >                        or a
  68+ 9C9D C9                                   ret                                 ; 2nd pro different, it swops based on swop flag around here.
  69+ 9C9E              ; Finished out of bounds exit point -----------------------------------------------------------------------------------
  70+ 9C9E 37           .PointsOutofBounds:     scf                                 ; LL109 (ClipFailed) carry flag set as not visible
  71+ 9C9F C9                                   ret
  72+ 9CA0 FD 7C        .LL108:                 ld      a,iyh
  73+ 9CA2 B7                                   or      a
  74+ 9CA3 1F                                   rra
  75+ 9CA4 FD 67                                ld      iyh,a                       ; (X2Y2 Off Screen)         XX13 = 95 (i.e. divide it by 2)                                                 -- X1Y1 on screen X2Y2 off screen
  76+ 9CA6                                      ;        push    af                  ;OPTIMISATION 6/11/21 commented out
  77+ 9CA6                                      ;        ld      a,iyh               ;OPTIMISATION 6/11/21 commented out
  78+ 9CA6                                      ;        ld      (regX),a            ;OPTIMISATION 6/11/21 commented out
  79+ 9CA6                                      ;        pop     af                  ;OPTIMISATION 6/11/21 commented out
  80+ 9CA6 FD 7C        .LL83:                  ld      a,iyh                       ; (Line On screen Test)      if XX13 < 128 then only 1 point is on screen so goto LL115                      -- We only need to deal with X2Y2
  81+ 9CA8 ED 27 80                             test    $80                         ;
  82+ 9CAB 28 28                                jr      z, .LL115                   ;
  83+ 9CAD 7C                                   ld      a,h                         ; If both x1_hi and x2_hi have bit 7 set, jump to LL109  to return from the subroutine with the C flag set, as the entire line is above the top of the screen
  84+ 9CAE A2                                   and     d
  85+ 9CAF                                      JumpIfNegative  .PointsOutofBounds
  85+ 9CAF FA 9E 9C    >                        jp		m, .PointsOutofBounds
  86+ 9CB2 78                                   ld      a,b                         ; If both y1_hi and y2_hi have bit 7 set, jump to LL109  to return from the subroutine with the C flag set, as the entire line is above the top of the screen
  87+ 9CB3 DD A4                                and     ixh
  88+ 9CB5                                      JumpIfNegative  .PointsOutofBounds
  88+ 9CB5 FA 9E 9C    >                        jp		m, .PointsOutofBounds
  89+ 9CB8 7C                                   ld      a,h                         ; If neither (x1_hi - 1) or (x2_hi - 1) have bit 7 set, jump to LL109 to return from the subroutine with the C  flag set, as the line doesn't fit on-screen
  90+ 9CB9 3D                                   dec     a
  91+ 9CBA FD 6F                                ld      iyl,a                       ; using iyl as XX12+2 var
  92+ 9CBC                                      ;        push    af                 ;OPTIMISATION 6/11/21 commented out
  93+ 9CBC                                      ;        ld      a,iyl              ;OPTIMISATION 6/11/21 commented out
  94+ 9CBC                                      ;        ld      (varXX12p2),a      ;OPTIMISATION 6/11/21 commented out
  95+ 9CBC                                      ;        pop     af                 ;OPTIMISATION 6/11/21 commented out
  96+ 9CBC 7A                                   ld      a,d                         ; a = x2 hi
  97+ 9CBD 3D                                   dec     a
  98+ 9CBE FD B5                                or      iyl                         ; (x2 hi -1 ) or (x1 hi -1)
  99+ 9CC0                                      JumpIfPositive .PointsOutofBounds   ; if both x1 and x2hi were > 0 then subtracting 1 would result in 0..254 so either being negative means it was 0 before
  99+ 9CC0 F2 9E 9C    >                        jp		p, .PointsOutofBounds
 100+ 9CC3              ;by here we have eliminated -ve Y1 bounds so can just test for positive high and bit 7 of lo
 101+ 9CC3 DD 7C                                ld      a,ixh
 102+ 9CC5 3D                                   dec     a
 103+ 9CC6 FD 6F                                ld      iyl,a
 104+ 9CC8 78                                   ld      a,b
 105+ 9CC9 3D                                   dec     a
 106+ 9CCA FD B5                                or      iyl
 107+ 9CCC                                      JumpIfPositive .PointsOutofBounds   ; if both x1 and x2hi were > 0 then subtracting 1 would result in 0..254 so either being negative means it was 0 before
 107+ 9CCC F2 9E 9C    >                        jp		p, .PointsOutofBounds
 108+ 9CCF 79                                   ld      a,c
 109+ 9CD0 DD A5                                and     ixl
 110+ 9CD2                                      JumpIfNegative .PointsOutofBounds   ; really if both are > 127
 110+ 9CD2 FA 9E 9C    >                        jp		m, .PointsOutofBounds
 111+ 9CD5              ; Clip line: calulate the line's gradient
 112+ 9CD5              ; here as an optimisation we make sure X1 is always < X2  later on
 113+ 9CD5              .LL115:                 ClearCarryFlag
 113+ 9CD5 B7          >                        or a
 114+ 9CD6 E5 D5        .CalcDX:                push    hl,,de
 115+ 9CD8 EB                                   ex      hl,de                       ; so hl is x2 and de = x1
 116+ 9CD9 ED 52                                sbc     hl,de
 117+ 9CDB                                     ; pop     de                          ; we need de back
 118+ 9CDB 22 44 9C                             ld      (clipDx),hl
 119+ 9CDE 7C                                   ld      a,h
 120+ 9CDF 32 46 9C                             ld      (clipDxHighNonABS),a
 121+ 9CE2                                     ; ld      a,e                         ;a = x2 lo
 122+ 9CE2                                     ; sbc     a,l                         ;a= a - x1
 123+ 9CE2                                     ; ld      (clipDx),a
 124+ 9CE2                                     ; ld      a,d
 125+ 9CE2                                     ; sbc     a,h
 126+ 9CE2                                     ; ld      (clipDxHigh),a                ; later we will just move to sub hl,de
 127+ 9CE2                                     ; ld      (clipDxHighNonABS),a          ; it looks liek we need this later post scale loop
 128+ 9CE2              .CalcDy:                ClearCarryFlag
 128+ 9CE2 B7          >                        or a
 129+ 9CE3 DD E5 E1                             ld      hl,ix
 130+ 9CE6 ED 42                                sbc     hl,bc
 131+ 9CE8 54 5D                                ld      de,hl           ;;OPTIMISATION 6/11/21
 132+ 9CEA 22 47 9C                             ld      (clipDy),hl     ;OPTIMISATION 6/11/21 commented out
 133+ 9CED 7C           .CalcQuadrant:          ld      a,h
 134+ 9CEE                                     ; ld      a,ixl
 135+ 9CEE                                     ; sbc     c
 136+ 9CEE                                     ; ld      (clipDy),a
 137+ 9CEE                                     ; ld      a,ixh
 138+ 9CEE                                     ; sbc     a,b
 139+ 9CEE                                     ; ld      (clipDyHigh),a              ; so A = sign of deltay in effect
 140+ 9CEE                                     ; pop     hl
 141+ 9CEE
 142+ 9CEE              ;So we now have delta_x in XX12(3 2), delta_y in XX12(5 4)  where the delta is (x1, y1) - (x2, y2))
 143+ 9CEE                                    ;  push    hl                          ; Set S = the sign of delta_x * the sign of delta_y, so if bit 7 of S is set, the deltas have different signs
 144+ 9CEE 21 45 9C                             ld      hl,clipDxHigh
 145+ 9CF1 AE                                   xor     (hl)                        ; now a = sign dx xor sign dy
 146+ 9CF2 32 68 84                             ld      (varS),a                    ; DEBGU putting it in var S too for now
 147+ 9CF5 32 4A 9C                             ld      (clipDxySign),a
 148+ 9CF8 3A 48 9C     .AbsDy:                 ld      a,(clipDyHigh)
 149+ 9CFB ED 27 80                             test    $80
 150+ 9CFE 28 0C                                jr      z,.LL110                    ; If delta_y_hi is positive, jump down to LL110 to skip the following
 151+ 9D00 2A 47 9C                             ld      hl,(clipDy)                 ;OPTIMISATION 6/11/21 commented out
 152+ 9D03                                      macronegate16de                     ; Otherwise flip the sign of delta_y to make it  positive, starting with the low bytes
 152+ 9D03 AF          >					xor 	a
 152+ 9D04 93          >                    sub 	e
 152+ 9D05 5F          >                    ld 		e,a
 152+ 9D06 9F          >                    sbc 	a,a
 152+ 9D07 92          >                    sub 	d
 152+ 9D08 57          >                    ld 		d,a
 153+ 9D09 22 47 9C                             ld      (clipDy),hl                 ;OPTIMISATION 6/11/21 commented out
 154+ 9D0C 2A 44 9C     .LL110:                 ld      hl,(clipDx)
 155+ 9D0F 3A 45 9C                             ld      a,(clipDxHigh)
 156+ 9D12 ED 27 80                             test    $80                         ; is it a negative X
 157+ 9D15 28 06                                jr      z,.LL111                    ; If delta_x_hi is positive, jump down to LL110 to skip the following
 158+ 9D17                                      ;ld      hl,(clipDx)                 ;OPTIMISATION 6/11/21 commented out
 159+ 9D17                                      macronegate16hl                     ; Otherwise flip the sign of delta_y to make it  positive, starting with the low bytes
 159+ 9D17 AF          >					xor 	a
 159+ 9D18 95          >					sub 	l
 159+ 9D19 6F          >					ld 		l,a
 159+ 9D1A 9F          >					sbc 	a,a
 159+ 9D1B 94          >					sub 	h
 159+ 9D1C 67          >					ld 		h,a
 160+ 9D1D                                     ; ld      (clipDx),hl                 ;OPTIMISATION 6/11/21 commented out; we still retain the old sign in NonABS version
 161+ 9D1D              .LL111:               ;  push    de
 162+ 9D1D                                     ; ld      hl,(clipDx)                 ;OPTIMISATION 6/11/21 commented out
 163+ 9D1D                                     ; ld      de,(clipDy)                 ;OPTIMISATION 6/11/21 commented out
 164+ 9D1D 7C           .ScaleLoop:             ld      a,h                         ; At this point DX and DY are ABS values
 165+ 9D1E B2                                   or      d
 166+ 9D1F 28 0A                                jr      z,.CalculateDelta
 166+ 9D21
 167+ 9D21                                      ShiftDERight1
 167+ 9D21 CB 3A       >			   srl d
 167+ 9D23 CB 1B       >			   rr  e
 168+ 9D25                                      ShiftHLRight1
 168+ 9D25 CB 3C       >			   srl h
 168+ 9D27 CB 1D       >			   rr  l
 169+ 9D29 18 F2                                jr      .ScaleLoop                  ; scaled down Dx and Dy to 8 bit, Dy may have been negative
 170+ 9D2B              .CalculateDelta:        ;ld      (clipDx),hl                ;OPTIMISATION 6/11/21 commented out
 171+ 9D2B                                      ;ld      (clipDy),de                ;OPTIMISATION 6/11/21 commented out
 172+ 9D2B              ; By now, the high bytes of both |delta_x| and |delta_y| are zero We know that h and d are both = 0 as that's what we tested with a BEQ
 173+ 9D2B AF           .LL113:                 xor     a
 174+ 9D2C 32 82 84                             ld      (varT),a                    ; t = 0
 175+ 9D2F 7D                                   ld      a,l                         ; If delta_x_lo < delta_y_lo, so our line is more vertical than horizontal, jump to LL114
 176+ 9D30                                      JumpIfALTNusng  e, .LL114           ;
 176+ 9D30 BB          >                        cp      e
 176+ 9D31 DA 41 9D    >                        jp		c, .LL114
 177+ 9D34              ; Here Dx >= Dy sp calculate Delta Y / delta X
 178+ 9D34 32 66 84     .DxGTEDy:               ld      (varQ),a                    ; Set Q = delta_x_lo
 179+ 9D37 57                                   ld      d,a                         ; d = also Q for calc
 180+ 9D38 7B                                   ld      a,e                         ; Set A = delta_y_lo
 181+ 9D39 CD EF 94                             call    AEquAmul256DivD; LL28Amul256DivD             ; Call LL28 to calculate:  R (actually a reg) = 256 * A / Q   = 256 * delta_y_lo / delta_x_lo
 182+ 9D3C 32 67 84                             ld      (varR),a                    ;
 183+ 9D3F 18 10                                jr      .LL116                      ; Jump to LL116, as we now have the line's gradient in R
 184+ 9D41              ; Here Delta Y > Delta X so calulate delta X / delta Y
 185+ 9D41 7B           .LL114:                 ld      a,e                         ; Set Q = delta_y_lo
 186+ 9D42 57                                   ld      d,a
 187+ 9D43 32 66 84                             ld      (varQ),a
 188+ 9D46 7D                                   ld      a,l                         ; Set A = delta_x_lo
 189+ 9D47 CD EF 94                             call    AEquAmul256DivD; LL28Amul256DivD             ; Call LL28 to calculate: R = 256 * A / Q  = 256 * delta_x_lo / delta_y_lo
 190+ 9D4A 32 67 84                             ld      (varR),a                    ;
 191+ 9D4D 21 82 84                             ld      hl,varT                     ; T was set to 0 above, so this sets T = &FF
 192+ 9D50 35                                   dec     (hl)
 193+ 9D51 D1           .LL116:                 pop     de                          ; get back X2
 194+ 9D52 E1                                   pop     hl                          ; get back X1 into hl,
 195+ 9D53 3A 67 84                             ld      a,(varR)                    ; Store the gradient in XX12+2 this can be optimised later
 196+ 9D56 32 49 9C                             ld      (clipGradient),a
 197+ 9D59 FD 6F                                ld      iyl,a
 198+ 9D5B                                      ;       push    af                   ;OPTIMISATION 6/11/21 commented out
 199+ 9D5B                                      ;       ld      a,iyl                ;OPTIMISATION 6/11/21 commented out
 200+ 9D5B                                      ;       ld      (varXX12p2),a        ;OPTIMISATION 6/11/21 commented out
 201+ 9D5B                                      ;       pop     af                   ;OPTIMISATION 6/11/21 commented out
 202+ 9D5B 3A 68 84                             ld      a,(varS)
 203+ 9D5E 32 4A 9C                             ld      (clipDxySign),a             ;  Store the type of slope in XX12+3, bit 7 clear means ?Not needed as clipDxySign is used for varS earlier?
 204+ 9D61                                                                          ; top left to bottom right, bit 7 set means top right to bottom left **CODE IS WRONG HERE A TEST IS BL to TR
 205+ 9D61 FD 7C                                ld      a,iyh                       ; iyh was XX13 from earlier
 206+ 9D63 FE 00                                cp      0                           ; If XX13 = 0, skip the following instruction
 207+ 9D65 28 05                                jr      z,.LL138                    ;
 208+ 9D67 ED 27 80                             test    $80                         ; If XX13 is positive, it must be 95. This means (x1, y1) is on-screen but (x2, y2) isn't, so we jump to LLX117 to swap the (x1, y1) and (x2, y2)
 209+ 9D6A 28 13                                jr      z,.LLX117                   ; coordinates around before doing the actual clipping, because we need to clip (x2, y2) but the clipping routine at LL118 only clips (x1, y1)
 210+ 9D6C              ; If we get here, XX13 = 0 or 191, so (x1, y1) is off-screen and needs clipping
 211+ 9D6C CD 93 9D     .LL138                  call    ClipPointHLBC               ; Call LL118 to move (x1, y1) along the line onto the screen, i.e. clip the line at the (x1, y1) end
 212+ 9D6F FD 7C                                ld      a,iyh                       ; If XX13 = 0, i.e. (x2, y2) is on-screen, jump down to LL124 to return with a successfully clipped line
 213+ 9D71 ED 27 80                             test    $80
 214+ 9D74 28 1A                                jr      z,.LL124
 215+ 9D76              ; If we get here, XX13 = 191 (both coordinates are off-screen)
 216+ 9D76 7C           .LL117:                 ld      a,h                         ; If either of x1_hi or y1_hi are non-zero, jump to
 217+ 9D77 B0                                   or      b                           ; LL137 to return from the subroutine with the C flag
 218+ 9D78 C2 9E 9C                             jp      nz, .PointsOutofBounds      ; set, as the line doesn't fit on-screen
 219+ 9D7B B1                                   or      c                           ; if x1 and y1 hi are both zero test bit 8 or Y1 to see if its > 128
 220+ 9D7C FA 9E 9C                             jp      m, .PointsOutofBounds       ; set, as the line doesn't fit on-screen
 221+ 9D7F              ; If we get here, XX13 = 95 or 191, and in both cases (x2, y2) is off-screen, so we now need to swap the (x1, y1) and (x2, y2) coordinates around before doing
 222+ 9D7F              ; the actual clipping, because we need to clip (x2, y2) but the clipping routine at LL118 only clips (x1, y1)
 223+ 9D7F EB           .LLX117:                ex      de,hl                       ;  swap X1 and X2
 224+ 9D80 DD E5                                push    ix                          ;  swap Y1 and Y2
 225+ 9D82 C5                                   push    bc
 226+ 9D83 DD E1                                pop     ix
 227+ 9D85 C1                                   pop     bc
 228+ 9D86 CD 93 9D                             call    ClipPointHLBC               ;  Call LL118 to move (x1, y1) along the line onto the screen, i.e. clip the line at the (x1, y1) end
 229+ 9D89 3A 4D 9C                             ld      a,(SWAP)
 230+ 9D8C 3D                                   dec     a
 231+ 9D8D 32 4D 9C                             ld      (SWAP),a                    ; Set SWAP = &FF to indicate that we just clipped the line at the (x2, y2) end by swapping the coordinates (the DEC does this as we set SWAP to 0 at the start of this subroutine)
 232+ 9D90 C3 8B 9C     .LL124:                 jp      .ClipDone                    ; now put points in place
 233+ 9D93
 234+ 9D93              ; Move a point along a line until it is on-screen point is held in HL(X) BC(Y) LL118
 235+ 9D93              ; iyh still holds XX13 iyl still holds gradient
 236+ 9D93 7C           ClipPointHLBC:          ld      a,h                         ; If x1_hi is positive, jump down to LL119 to skip the following
 237+ 9D94 ED 27 80                             test    $80
 238+ 9D97 28 17                                jr      z,.LL119
 239+ 9D99 32 68 84     .X1isNegative:          ld      (varS),a                    ;  Otherwise x1_hi is negative, i.e. off the left of the screen, so set S = x1_hi
 240+ 9D9C E5 D5 C5                             push    hl,,de,,bc
 241+ 9D9F CD 15 9E                             call    LL120                       ;  Call LL120 to calculate:   (Y X) = (S x1_lo) * XX12+2      if T = 0   = x1 * gradient
 242+ 9DA2                                                                          ;                             (Y X) = (S x1_lo) / XX12+2      if T <> 0  = x1 / gradient
 243+ 9DA2                                                                          ;  with the sign of (Y X) set to the opposite of the line's direction of slope
 244+ 9DA2 C1 D1 E1                             pop    hl,,de,,bc                   ;  get coordinates back
 245+ 9DA5 2A 4E 9C                             ld      hl,(varYX)
 246+ 9DA8              ;                        ex      hl,de
 247+ 9DA8                                  ;    ld      hl,bc
 248+ 9DA8 09                                   add     hl,bc                       ; y1 = y1 + varYX
 249+ 9DA9 44 4D                                ld      bc,hl
 250+ 9DAB 21 00 00                             ld      hl,0                        ; Set x1 = 0
 251+ 9DAE               ;                       pop     de
 252+ 9DAE 18 1A                                jr      .LL134                      ; in BBC is set x to 0 to force jump, we will just jump
 253+ 9DB0 FE 00        .LL119:                 cp      0
 254+ 9DB2 28 16                                jr      z,.LL134                    ;  If x1_hi = 0 then jump down to LL134 to skip the following, as the x-coordinate is already on-screen (as 0 <= (x_hi x_lo) <= 255)
 255+ 9DB4 3D                                   dec     a
 256+ 9DB5 32 68 84                             ld      (varS),a                    ;  Otherwise x1_hi is positive, i.e. x1 >= 256 and off the right side of the screen, so set S = x1_hi - 1
 257+ 9DB8 E5 D5 C5                             push    hl,,de,,bc
 258+ 9DBB CD 15 9E                             call    LL120                      ;  Call LL120 to calculate: (Y X) = (S x1_lo) * XX12+2      if T = 0  = (x1 - 256) * gradient
 259+ 9DBE                                                                          ;                           (Y X) = (S x1_lo) / XX12+2      if T <> 0 = (x1 - 256) / gradient
 260+ 9DBE                                                                          ;  with the sign of (Y X) set to the opposite of theline's direction of slope
 261+ 9DBE C1 D1 E1                             pop     hl,,de,,bc
 262+ 9DC1                                    ;  push    de                          ; Set y1 = y1 + (Y X)
 263+ 9DC1 2A 4E 9C                             ld      hl,(varYX)
 264+ 9DC4                                    ; ex      de,hl                       ;OPTIMISATION 6/11/21 commented out
 265+ 9DC4 09                                   add     hl,bc                        ;OPTIMISATION 6/11/21 simplfied post debug
 266+ 9DC5 44 4D                                ld      bc,hl                        ;OPTIMISATION 6/11/21 simplfied post debug
 267+ 9DC7                                    ; ex      hl,de                       ;OPTIMISATION 6/11/21 commented out
 268+ 9DC7                                    ; ld      hl,bc                       ;OPTIMISATION 6/11/21 commented out
 269+ 9DC7                                    ; add     hl,de                       ; y1 = y1 + varYX
 270+ 9DC7 21 FF 00                             ld      hl,255                      ; Set x1 = 255
 271+ 9DCA                                    ;  pop     de
 272+ 9DCA              ; We have moved the point so the x-coordinate is on screen (i.e. in the range 0-255), so now for they-coordinate
 273+ 9DCA 78           .LL134:                 ld      a,b                         ; If y1_hi is positive, jump down to LL135  to skip the following
 274+ 9DCB ED 27 80                             test    $80                         ;
 275+ 9DCE 28 1A                                jr      z,.LL135                    ;
 276+ 9DD0 32 68 84                             ld      (varS),a                    ; Otherwise y1_hi is negative, i.e. off the top of the screen, so set S = y1_hi
 277+ 9DD3 79                                   ld      a,c                         ; Set R = y1_lo
 278+ 9DD4 32 67 84                             ld      (varR),a                    ;
 279+ 9DD7 E5 D5 C5                             push    hl,,de,,bc
 280+ 9DDA CD 3C 9E                             call    LL123                       ;  Call LL123 to calculate: (Y X) = (S R) / XX12+2      if T = 0  = y1 / gradient
 281+ 9DDD                                                                          ;                           (Y X) = (S R) * XX12+2      if T <> 0 = y1 * gradient
 282+ 9DDD                                                                          ;  with the sign of (Y X) set to the opposite of the line's direction of slope
 283+ 9DDD C1 D1 E1                             pop     hl,,de,,bc
 284+ 9DE0 D5                                   push    de
 285+ 9DE1 EB                                   ex      hl,de                       ; de = x1
 286+ 9DE2 2A 4E 9C                             ld      hl,(varYX)                  ; hl = varYX
 287+ 9DE5 19                                   add     hl,de                       ; we don't need to swap back as its an add, Set x1 = x1 + (Y X)
 288+ 9DE6 D1                                   pop     de                          ; de = x2 again
 289+ 9DE7 01 00 00                             ld      bc,0                        ; Set y1 = 0
 290+ 9DEA 79           .LL135:                 ld      a,c                         ; if bc < 128 then no work to do
 291+ 9DEB E6 80                                and     $80
 292+ 9DED B0                                   or      b                           ; here we see if c bit 8 is set or anything in b as we know if its 0 this would mean there is no need to clip
 293+ 9DEE C8                                   ret     z
 294+ 9DEF E5                                   push    hl
 295+ 9DF0 60 69                                ld      hl,bc
 296+ 9DF2 01 80 00                             ld      bc,128
 297+ 9DF5 B7                                   or      a
 298+ 9DF6 ED 42                                sbc     hl,bc                       ; hl =  (S R) = (y1_hi y1_lo) - 128
 299+ 9DF8 22 67 84                             ld      (varRS), hl                 ; and now RS (or SR)
 300+ 9DFB 7C                                   ld      a,h
 301+ 9DFC E1                                   pop     hl
 302+ 9DFD ED 27 80                             test    $80                         ; If the subtraction underflowed, i.e. if y1 < 192, then y1 is already on-screen, so jump to LL136 to return from the subroutine, as we are done
 303+ 9E00 C0                                   ret     nz
 304+ 9E01              ; If we get here then y1 >= 192, i.e. off the bottom of the screen
 305+ 9E01 E5 D5 C5     .LL139:                 push    hl,,de,,bc
 306+ 9E04 CD 3C 9E                             call    LL123                       ;  Call LL123 to calculate: (Y X) = (S R) / XX12+2      if T = 0  = y1 / gradient
 307+ 9E07                                                                          ;                           (Y X) = (S R) * XX12+2      if T <> 0 = y1 * gradient
 308+ 9E07                                                                          ;  with the sign of (Y X) set to the opposite of the line's direction of slope
 309+ 9E07 C1 D1 E1                             pop     hl,,de,,bc
 310+ 9E0A D5                                   push    de
 311+ 9E0B EB                                   ex      hl,de
 312+ 9E0C 2A 4E 9C                             ld      hl,(varYX)
 313+ 9E0F 19                                   add     hl,de                       ; we don't need to swap back as its an add, Set x1 = x1 + (Y X)
 314+ 9E10 01 7F 00                             ld      bc,127                      ; set bc to 127 bottom of screen
 315+ 9E13 D1                                   pop     de
 316+ 9E14 C9           .LL136:                 ret                                 ;  Return from the subroutine
 317+ 9E15
 318+ 9E15
 319+ 9E15              ; Calculate the following:   * If T = 0  (more vertical than horizontal), (Y X) = (S x1_lo) * XX12+2
 320+ 9E15              ;                            * If T <> 0 (more horizontal than vertical), (Y X) = (S x1_lo) / XX12+2
 321+ 9E15              ;                              giving (Y X) the opposite sign to the slope direction in XX12+3.
 322+ 9E15              ; Other entry points        LL122                Calculate (Y X) = (S R) * Q and set the sign to the opposite of the top byte on the stack
 323+ 9E15 7D           LL120:                  ld      a,l                          ; Set R = x1_lo
 324+ 9E16 32 67 84                             ld      (varR),a
 325+ 9E19 CD 84 9E                             call    LL129                        ;  Call LL129 to do the following:  Q = XX12+2   = line gradient  A = S EOR XX12+3 = S EOR slope direction (S R) = |S R| So A contains the sign of S * slope direction
 326+ 9E1C F5                                   push    af                           ;  Store A on the stack so we can use it later
 327+ 9E1D C5                                   push    bc
 328+ 9E1E 47                                   ld      b,a
 329+ 9E1F 3A 82 84                             ld      a,(varT)                     ; instead : (Y X) = (S R ) / Q
 330+ 9E22 FE 00                                cp      0
 331+ 9E24 78                                   ld      a,b
 332+ 9E25 C1                                   pop     bc                           ; we can't use af as that would disrupt the flags
 333+ 9E26 20 23                                jr      nz, LL121
 334+ 9E28              ; The following calculates:  (Y X) = (S R) * Q using the same shift-and-add algorithm that's documented in MULT1
 335+ 9E28 3A 49 9C     LL122:                  ld      a,(clipGradient)
 336+ 9E2B 32 66 84                             ld      (varQ),a; optimise
 337+ 9E2E CD 42 93                             call    HLequSRmulQdiv256
 338+ 9E31 22 4E 9C                             ld      (varYX),hl
 339+ 9E34 F1                                   pop     af
 340+ 9E35 ED 27 80                             test    $80
 341+ 9E38 CA 77 9E                             jp      z,LL133
 342+ 9E3B C9                                   ret
 343+ 9E3C              ; Calculate the following: * If T = 0,  calculate (Y X) = (S R) / XX12+2 (actually SR & XX12+2 /256)
 344+ 9E3C              ;                          * If T <> 0, calculate (Y X) = (S R) * XX12+2
 345+ 9E3C              ;                          giving (Y X) the opposite sign to the slope direction in XX12+3.
 346+ 9E3C              ;
 347+ 9E3C              ; Other entry points:      LL121                Calculate (Y X) = (S R) / Q and set the sign to the opposite of the top byte on the stack
 348+ 9E3C              ;                          LL133                Negate (Y X) and return from the subroutine
 349+ 9E3C              ;                          LL128                Contains an RTS
 350+ 9E3C CD 84 9E     LL123:                  call    LL129                       ; Call LL129 to do the following: Q = XX12+2   = line gradient  A = S EOR XX12+3 = S EOR slope direction (S R) = |S R| So A contains the sign of S * slope direction
 351+ 9E3F F5                                   push    af                          ; Store A on the stack so we can use it later
 352+ 9E40 C5                                   push    bc                          ; If T is non-zero, so it's more horizontal than vertical, jump down to LL121 to calculate this
 353+ 9E41 47                                   ld      b,a
 354+ 9E42 3A 82 84                             ld      a,(varT)                    ; instead : (Y X) = (S R) * Q *** this looks to be the wrong way roudn for Y!!!!
 355+ 9E45 FE 00                                cp      0
 356+ 9E47 78                                   ld      a,b
 357+ 9E48 C1                                   pop     bc
 358+ 9E49 20 DD                                jr      nz, LL122
 359+ 9E4B              ; The following calculates: (Y X) = (S R) / Q using the same shift-and-subtract algorithm that's documented in TIS2, its actually X.Y=R.S*256/Q
 360+ 9E4B 11 FE FF     LL121:                  ld      de,$FFFE                    ; set XY to &FFFE at start, de holds XY
 361+ 9E4E 2A 67 84                             ld      hl,(varRS)                  ; hl = RS
 362+ 9E51 3A 66 84                             ld      a,(varQ)
 363+ 9E54 47                                   ld      b,a                         ; b = q
 364+ 9E55              .LL130:                 ShiftHLLeft1                        ; RS *= 2
 364+ 9E55 CB 25       >			   sla l
 364+ 9E57 CB 14       >			   rl  h
 365+ 9E59 7C                                   ld      a,h
 366+ 9E5A 38 04                                jr      c,.LL131                    ; if S overflowed skip Q test and do subtractions
 367+ 9E5C                                      JumpIfALTNusng b, .LL132            ; if S <  Q = 256/gradient skip subtractions
 367+ 9E5C B8          >                        cp      b
 367+ 9E5D DA 68 9E    >                        jp		c, .LL132
 368+ 9E60 3F           .LL131:                 ccf                                 ; compliment carry
 369+ 9E61 98                                   sbc     a,b                         ; q
 370+ 9E62 67                                   ld      h,a                         ; h (s)
 371+ 9E63 7D                                   ld      a,l                         ; r
 372+ 9E64 DE 00                                sbc     a,0                         ; 0 - so in effect SR - Q*256
 373+ 9E66 37                                   scf                                 ; set carry for next rolls
 374+ 9E67 3F                                   ccf
 375+ 9E68              .LL132:                 RollDELeft1                         ; Rotate de bits left
 375+ 9E68 CB 13       >               rl  e
 375+ 9E6A CB 12       >               rl  d
 376+ 9E6C 38 E7                                jr      c,.LL130                    ;
 377+ 9E6E ED 53 4E 9C                          ld      (varYX),de
 378+ 9E72 F1                                   pop     af              ; get back sign
 379+ 9E73 ED 27 80                             test    $80
 380+ 9E76 C8                                   ret     z               ; if negative then return with value as is reversed sign
 381+ 9E77 2A 4E 9C     LL133:                  ld      hl,(varYX)      ; may not actually need this?
 382+ 9E7A                                      NegHL
 382+ 9E7A AF          >                    xor a
 382+ 9E7B 95          >                    sub l
 382+ 9E7C 6F          >                    ld l,a
 382+ 9E7D 9F          >                    sbc a,a
 382+ 9E7E 94          >                    sub h
 382+ 9E7F 67          >                    ld h,a
 383+ 9E80 22 4E 9C                             ld      (varYX),hl
 384+ 9E83 C9           LL128:                  ret
 385+ 9E84              ; Do the following, in this order:  Q = XX12+2
 386+ 9E84              ;                                   A = S EOR XX12+3
 387+ 9E84              ;                                   (S R) = |S R|
 388+ 9E84              ; This sets up the variables required above to calculate (S R) / XX12+2 and give the result the opposite sign to XX13+3.
 389+ 9E84 3A 49 9C     LL129:                  ld      a,(clipGradient)
 390+ 9E87 32 66 84                             ld      (varQ),a                    ;Set Q = XX12+2
 391+ 9E8A 3A 68 84                             ld      a,(varS)                    ; If S is positive, jump to LL127
 392+ 9E8D E5 F5                                push    hl,,af
 393+ 9E8F ED 27 80                             test    $80
 394+ 9E92 28 0C                                jr      z,.LL127
 395+ 9E94 2A 67 84                             ld      hl,(varRS)                  ; else SR = | SR|
 396+ 9E97                                      NegHL
 396+ 9E97 AF          >                    xor a
 396+ 9E98 95          >                    sub l
 396+ 9E99 6F          >                    ld l,a
 396+ 9E9A 9F          >                    sbc a,a
 396+ 9E9B 94          >                    sub h
 396+ 9E9C 67          >                    ld h,a
 397+ 9E9D 22 67 84                             ld      (varRS),hl
 398+ 9EA0 21 4A 9C     .LL127:                 ld      hl,clipDxySign
 399+ 9EA3 F1                                   pop     af
 400+ 9EA4 AE                                   xor     (hl)                        ; a = S XOR clipDxySign
 401+ 9EA5 E1                                   pop     hl
 402+ 9EA6 C9                                   ret
 403+ 9EA7
# file closed: ./ModelRender/CLIP-LL145.asm
 157  9EA7
 158  9EA7
 159  9EA7              ; Repurposed XX15 when plotting lines
 160  9EA7              ; Repurposed XX15 before calling clip routine
 161  9EA7              UBnkX1                      equ XX15
 162  9EA7              UBnKx1Lo                    equ XX15
 163  9EA7              UBnKx1Hi                    equ XX15+1
 164  9EA7              UBnkY1                      equ XX15+2
 165  9EA7              UbnKy1Lo                    equ XX15+2
 166  9EA7              UBnkY1Hi                    equ XX15+3
 167  9EA7              UBnkX2                      equ XX15+4
 168  9EA7              UBnkX2Lo                    equ XX15+4
 169  9EA7              UBnkX2Hi                    equ XX15+5
 170  9EA7              ; Repurposed XX12 when plotting lines
 171  9EA7              UBnkY2                      equ XX12+0
 172  9EA7              UbnKy2Lo                    equ XX12+0
 173  9EA7              UBnkY2Hi                    equ XX12+1
 174  9EA7              UBnkDeltaXLo                equ XX12+2
 175  9EA7              UBnkDeltaXHi                equ XX12+3
 176  9EA7              UBnkDeltaYLo                equ XX12+4
 177  9EA7              UBnkDeltaYHi                equ XX12+5
 178  9EA7              UbnkGradient                equ XX12+2
 179  9EA7              UBnkTemp1                   equ XX12+2
 180  9EA7              UBnkTemp1Lo                 equ XX12+2
 181  9EA7              UBnkTemp1Hi                 equ XX12+3
 182  9EA7              UBnkTemp2                   equ XX12+3
 183  9EA7              UBnkTemp2Lo                 equ XX12+3
 184  9EA7              UBnkTemp2Hi                 equ XX12+4
 185  9EA7              ;-- XX15 --------------------------------------------------------------------------------------------------------------------------
 186  9EA7 00           UBnkXScaled                 DB  0               ; XX15+0Xscaled
 187  9EA8 00           UBnkXScaledSign             DB  0               ; XX15+1xsign
 188  9EA9 00           UBnkYScaled                 DB  0               ; XX15+2yscaled
 189  9EAA 00           UBnkYScaledSign             DB  0               ; XX15+3ysign
 190  9EAB 00           UBnkZScaled                 DB  0               ; XX15+4zscaled
 191  9EAC 00           UBnkZScaledSign             DB  0               ; XX15+5zsign
 192  9EAD
 193  9EAD              XX15                        equ UBnkXScaled
 194  9EAD              XX15VecX                    equ XX15
 195  9EAD              XX15VecY                    equ XX15+1
 196  9EAD
 197  9EAD              XX15VecZ                    equ XX15+2
 198  9EAD              UbnkXPoint                  equ XX15
 199  9EAD              UbnkXPointLo                equ XX15+0
 200  9EAD              UbnkXPointHi                equ XX15+1
 201  9EAD              UbnkXPointSign              equ XX15+2
 202  9EAD              UbnkYPoint                  equ XX15+3
 203  9EAD              UbnkYPointLo                equ XX15+3
 204  9EAD              UbnkYPointHi                equ XX15+4
 205  9EAD              UbnkYPointSign              equ XX15+5
 206  9EAD              ; Repurposed XX15 pre clip plines
 207  9EAD              UbnkPreClipX1               equ XX15+0
 208  9EAD              UbnkPreClipY1               equ XX15+2
 209  9EAD              UbnkPreClipX2               equ XX15+4
 210  9EAD              UbnkPreClipY2               equ XX15+6
 211  9EAD              ; Repurposed XX15 post clip lines
 212  9EAD              UBnkNewX1                   equ XX15+0
 213  9EAD              UBnkNewY1                   equ XX15+1
 214  9EAD              UBnkNewX2                   equ XX15+2
 215  9EAD              UBnkNewY2                   equ XX15+3
 216  9EAD              ; Repurposed XX15
 217  9EAD              regXX15fx                   equ UBnkXScaled
 218  9EAD              regXX15fxSgn                equ UBnkXScaledSign
 219  9EAD              regXX15fy                   equ UBnkYScaled
 220  9EAD              regXX15fySgn                equ UBnkYScaledSign
 221  9EAD              regXX15fz                   equ UBnkZScaled
 222  9EAD              regXX15fzSgn                equ UBnkZScaledSign
 223  9EAD              ; Repurposed XX15
 224  9EAD              varX1                       equ UBnkXScaled       ; Reused, verify correct position
 225  9EAD              varY1                       equ UBnkXScaledSign   ; Reused, verify correct position
 226  9EAD              varZ1                       equ UBnkYScaled       ; Reused, verify correct position
 227  9EAD              ; After clipping the coords are two 8 bit pairs
 228  9EAD              UBnkPoint1Clipped           equ UBnkXScaled
 229  9EAD              UBnkPoint2Clipped           equ UBnkYScaled
 230  9EAD              ;-- transmat0 --------------------------------------------------------------------------------------------------------------------------
 231  9EAD              ; Note XX12 comes after as some logic in normal processing uses XX15 and XX12 combines
 232  9EAD 00           UBnkXX12xLo                 DB  0               ; XX12+0
 233  9EAE 00           UBnkXX12xSign               DB  0               ; XX12+1
 234  9EAF 00           UBnkXX12yLo                 DB  0               ; XX12+2
 235  9EB0 00           UBnkXX12ySign               DB  0               ; XX12+3
 236  9EB1 00           UBnkXX12zLo                 DB  0               ; XX12+4
 237  9EB2 00           UBnkXX12zSign               DB  0               ; XX12+5
 238  9EB3 00 00 00...  XX12Save                    DS  6
 239  9EB9 00 00 00...  XX12Save2                   DS  6
 240  9EBF              XX12                        equ UBnkXX12xLo
 241  9EBF              varXX12                     equ UBnkXX12xLo
 242  9EBF              ; Post clipping the results are now 8 bit
 243  9EBF 00           UBnkVisibility              DB  0               ; replaces general purpose xx4 in rendering
 244  9EC0 00           UbnKDrawAsDot               DB  0               ; if 0 then OK, if 1 then just draw dot of line heap
 245  9EC1 00           UBnkProjectedY              DB  0
 246  9EC2 00           UBnkProjectedX              DB  0
 247  9EC3              UBnkProjected               equ UBnkProjectedY  ; resultant projected position
 248  9EC3 00 00 00...  XX15Save                    DS  8
 249  9ECB 00 00 00...  XX15Save2                   DS  8
 250  9ED3 00           VarBackface                 DB 0
 251  9ED4              ; Heap (or array) information for lines and normals
 252  9ED4              ; Coords are stored XY,XY,XY,XY
 253  9ED4              ; Normals
 254  9ED4              ; This needs re-oprganising now.
 255  9ED4              ; Runtime Calculation Store
 256  9ED4
 257  9ED4
 258  9ED4              ;--------------------------------------------------------------------------------------------------------
 259  9ED4
 260  9ED4              ; Bank 58  ------------------------------------------------------------------------------------------------------------------------
 261  9ED4                  SLOT    LAYER1Addr
 262  9ED4                  PAGE    BankLAYER1
 263  9ED4                  ORG     LAYER1Addr, BankLAYER1
 264  E000
 265  E000                  INCLUDE "./Layer1Graphics/layer1_attr_utils.asm"
# file opened: ./Layer1Graphics/layer1_attr_utils.asm
   1+ E000
   2+ E000 00 58        L1AttrRow00:            DW $5800                    ;Row 1    */
   3+ E002 20 58        L1AttrRow01:            DW $5820                    ;Row 2    */
   4+ E004 40 58        L1AttrRow02:            DW $5840                    ;Row 3    */
   5+ E006 60 58        L1AttrRow03:            DW $5860                    ;Row 4    */
   6+ E008 80 58        L1AttrRow04:            DW $5880                    ;Row 5    */
   7+ E00A A0 58        L1AttrRow05:            DW $58A0                    ;Row 6    */
   8+ E00C C0 58        L1AttrRow06:            DW $58C0                    ;Row 7    */
   9+ E00E E0 58        L1AttrRow07:            DW $58E0                    ;Row 8    */
  10+ E010 00 59        L1AttrRow08:            DW $5900                    ;Row 9    */
  11+ E012 20 59        L1AttrRow09:            DW $5920                    ;Row 10   */
  12+ E014 40 59        L1AttrRow10:            DW $5940                    ;Row 11   */
  13+ E016 60 59        L1AttrRow11:            DW $5960                    ;Row 12   */
  14+ E018 80 59        L1AttrRow12:            DW $5980                    ;Row 13   */
  15+ E01A A0 59        L1AttrRow13:            DW $59A0                    ;Row 14   */
  16+ E01C C0 59        L1AttrRow14:            DW $59C0                    ;Row 15   */
  17+ E01E E0 59        L1AttrRow15:            DW $59E0                    ;Row 16   */
  18+ E020 00 5A        L1AttrRow16:            DW $5A00                    ;Row 17   */
  19+ E022 20 5A        L1AttrRow17:            DW $5A20                    ;Row 18   */
  20+ E024 40 5A        L1AttrRow18:            DW $5A40                    ;Row 19   */
  21+ E026 60 5A        L1AttrRow19:            DW $5A60                    ;Row 20   */
  22+ E028 80 5A        L1AttrRow20:            DW $5A80                    ;Row 21   */
  23+ E02A A0 5A        L1AttrRow21:            DW $5AA0                    ;Row 22   */
  24+ E02C C0 5A        L1AttrRow22:            DW $5AC0                    ;Row 23   */
  25+ E02E E0 5A        L1AttrRow23:            DW $5AE0                    ;Row 23   */
  26+ E030
  27+ E030              ; "l2_hilight_row, d = row, e = colour"
  28+ E030 21 00 E0     l1_hilight_row:         ld      hl, L1AttrRow00
  29+ E033 4B                                   ld      c,e
  30+ E034 7A                                   ld      a,d
  31+ E035 CB 27                                sla     a
  32+ E037 ED 31                                add     hl,a
  33+ E039 7E                                   ld      a,(hl)
  34+ E03A 5F                                   ld      e,a
  35+ E03B 23                                   inc     hl
  36+ E03C 7E                                   ld      a,(hl)
  37+ E03D 57                                   ld      d,a
  38+ E03E EB                                   ex      hl,de
  39+ E03F 79                                   ld		a,c
  40+ E040 11 20 00                             ld		de, 32
  41+ E043 CD 65 80                             call	memfill_dma
  42+ E046 C9                                   ret
  43+ E047
# file closed: ./Layer1Graphics/layer1_attr_utils.asm
 266  E047                  INCLUDE "./Layer1Graphics/layer1_cls.asm"
# file opened: ./Layer1Graphics/layer1_cls.asm
   1+ E047 AF           l1_cls_top:             xor     a
   2+ E048 21 00 40                             ld      hl, $4000
   3+ E04B 11 00 08                             ld      de, $0800
   4+ E04E CD 65 80                             call    memfill_dma
   5+ E051 C9                                   ret
   6+ E052
   7+ E052 AF           l1_cls_mid:             xor     a
   8+ E053 21 00 48                             ld      hl, $4800
   9+ E056 11 00 08                             ld      de, $0800
  10+ E059 CD 65 80                             call    memfill_dma
  11+ E05C C9                                   ret
  12+ E05D
  13+ E05D AF           l1_cls_bottom:          xor     a
  14+ E05E 21 00 50                             ld      hl, $5000
  15+ E061 11 00 08                             ld      de, $0800
  16+ E064 CD 65 80                             call    memfill_dma
  17+ E067 C9                                   ret
  18+ E068
  19+ E068              ; Designed specifically to clear a whole character aligned line
  20+ E068 1E 00        l1_cls_line_d:          ld      e,0
  21+ E06A ED 94                                pixelad
  22+ E06C 11 00 01                             ld      de,32 * 8
  23+ E06F AF                                   xor     a
  24+ E070 CD 65 80                             call    memfill_dma
  25+ E073 C9                                   ret
  26+ E074
  27+ E074              ; Designed specifically to clear a whole character aligned 2 lines line, used for say clearing hyperspace message
  28+ E074 1E 00        l1_cls_2_lines_d:       ld      e,0
  29+ E076 ED 94                                pixelad
  30+ E078 11 00 02                             ld      de,32 * 16
  31+ E07B AF                                   xor     a
  32+ E07C CD 65 80                             call    memfill_dma
  33+ E07F C9                                   ret
  34+ E080
  35+ E080 AF           l1_cls:                 xor		a
  36+ E081 21 00 40     l1_cls_to_a:            ld		hl,	$4000
  37+ E084 11 00 18                             ld		de, $1800
  38+ E087 CD 65 80                             call	memfill_dma
  39+ E08A C9                                   ret
  40+ E08B
  41+ E08B 21 00 58     l1_attr_cls_2DlinesA:   ld		hl,	$5800
  42+ E08E 1E 20                                ld      e,32
  43+ E090 ED 30                                mul
  44+ E092 19                                   add     hl,de
  45+ E093 11 40 00                             ld		de, 32 * 2
  46+ E096 CD 65 80                             call	memfill_dma
  47+ E099 C9                                   ret
  48+ E09A
  49+ E09A
  50+ E09A AF           l1_attr_cls:            xor		a
  51+ E09B 21 00 58     l1_attr_cls_to_a:       ld		hl,	$5800
  52+ E09E 11 00 03                             ld		de, $0300
  53+ E0A1 CD 65 80                             call	memfill_dma
  54+ E0A4 C9                                   ret
  55+ E0A5
  56+ E0A5 01 FE FE     l1_set_border:          ld	    bc, 0xFEFE
  57+ E0A8 ED 79                                out		(c),a
  58+ E0AA C9                                   ret
# file closed: ./Layer1Graphics/layer1_cls.asm
 267  E0AB                  INCLUDE "./Layer1Graphics/layer1_print_at.asm"
# file opened: ./Layer1Graphics/layer1_print_at.asm
   1+ E0AB              ; "l1 print char a = character, de = Ypixel Xchar of print"
   2+ E0AB D5 E5        l1_print_char:          push	de,,hl
   3+ E0AD ED 94                                pixelad								; hl = address of de
   4+ E0AF E5                                   push	hl							; save hl for loop
   5+ E0B0 26 00                                ld		h,0
   6+ E0B2 6F                                   ld		l,a
   7+ E0B3 29                                   add		hl,hl						; * 2
   8+ E0B4 29                                   add		hl,hl						; * 4
   9+ E0B5 29                                   add		hl,hl						; * 8 to get byte address
  10+ E0B6 ED 34 00 3C                          add		hl,charactersetaddr			; hl = address of rom char
  11+ E0BA EB                                   ex		de,hl						; save address into de
  12+ E0BB E1                                   pop		hl							; get back hl for loop
  13+ E0BC 06 08                                ld		b,8							; do 8 rows
  14+ E0BE 1A           .PrintCharLoop:         ld		a,(de)						; row byte
  15+ E0BF 13                                   inc		de							; next byte
  16+ E0C0 77                                   ld		(hl),a						; poke to screen
  17+ E0C1 ED 93                                pixeldn								; Down 1 row
  18+ E0C3 10 F9                                djnz	.PrintCharLoop				; loop for 8 bytes
  19+ E0C5 E1 D1                                pop		de,,hl					    ; restore hl
  20+ E0C7 C9                                   ret
  21+ E0C8
  22+ E0C8              ; "l1 PrintAt, pixel row, whole char col, DE = yx, HL = message Addr"
  23+ E0C8              ; now skips ascii code < 32 but moves on cursor by 1 char
  24+ E0C8              l1_print_at:
  25+ E0C8 7E           .PrintLoop:             ld		a,(hl)
  26+ E0C9 FE 00                                cp		0
  27+ E0CB C8                                   ret		z
  28+ E0CC                                      CallIfAGTENusng " ", l1_print_char
  28+ E0CC FE 20       >                        cp      " "
  28+ E0CE D4 AB E0    >                        call	nc,l1_print_char
  29+ E0D1 23                                   inc		hl							; move 1 message character right
  30+ E0D2 7B                                   ld		a,e
  31+ E0D3 C6 08                                add		a,8
  32+ E0D5 5F                                   ld		e,a							; move 1 screen character right
  33+ E0D6 18 F0                                jr		.PrintLoop
  34+ E0D8              .Clearstackandfinish:   ;pop		de                      ; TODO LOOOKS TO BE A ROGUE POPDE
  35+ E0D8 C9                                   ret
  36+ E0D9
  37+ E0D9              ;l1_print_at_wrap:
  38+ E0D9              ;; "l1 PrintAt, pixel row, whole char col, DE = yx, HL = message Addr"
  39+ E0D9              ;	ld      iyh,e
  40+ E0D9              ;.PrintLoop:
  41+ E0D9              ;	ld		a,(hl)
  42+ E0D9              ;	cp		0
  43+ E0D9              ;	ret		z
  44+ E0D9              ;.CountWordCharLen
  45+ E0D9              ;; Need to change to word wrap, so it will loop through string as before
  46+ E0D9              ;; but read up until a null or space, take the character count * 8 for pixels
  47+ E0D9              ;; if that is > 238 then force a premature line wrap
  48+ E0D9              ;
  49+ E0D9              ;
  50+ E0D9              ;    push    iy
  51+ E0D9              ;    call	l1_print_char
  52+ E0D9              ;    pop     iy
  53+ E0D9              ;	inc		hl							; move 1 message character right
  54+ E0D9              ;	ld		a,e
  55+ E0D9              ;    cp      238
  56+ E0D9              ;    jr      nc,.NextLine
  57+ E0D9              ;	add		a,8
  58+ E0D9              ;	ld		e,a							; move 1 screen character right
  59+ E0D9              ;	jr		.PrintLoop
  60+ E0D9              ;.Clearstackandfinish:
  61+ E0D9              ;	pop		de
  62+ E0D9              ;	ret
  63+ E0D9              ;.NextLine:
  64+ E0D9              ;    ld      a,(hl)
  65+ E0D9              ;    cp      " "
  66+ E0D9              ;    ld      e,iyh
  67+ E0D9              ;    ld      a,d
  68+ E0D9              ;    add     a,8
  69+ E0D9              ;    ld      d,a
  70+ E0D9              ;    jr		.PrintLoop
  71+ E0D9
  72+ E0D9              ; Counts next word at hl, uses e and forces a wrap if it would over flow puts value in c
  73+ E0D9 E5           L1LenWordAtHL:          push    hl
  74+ E0DA D5                                   push    de
  75+ E0DB 7E           .CountLoop:             ld      a,(hl)
  76+ E0DC FE 00                                cp      0
  77+ E0DE 28 0F                                jr      z,.CountDone
  78+ E0E0 FE 20                                cp      32
  79+ E0E2 28 0B                                jr      z,.CountDone
  80+ E0E4 7B                                   ld      a,e
  81+ E0E5 C6 08                                add     a,8
  82+ E0E7 5F                                   ld      e,a
  83+ E0E8 FE EE                                cp      238
  84+ E0EA 30 07                                jr      nc,.TooLong
  85+ E0EC 23                                   inc     hl
  86+ E0ED 18 EC                                jr      .CountLoop
  87+ E0EF D1           .CountDone:             pop     de
  88+ E0F0 E1                                   pop     hl
  89+ E0F1 AF                                   xor     a
  90+ E0F2 C9                                   ret
  91+ E0F3 D1           .TooLong                pop     de
  92+ E0F4 E1                                   pop     hl
  93+ E0F5 3E FF                                ld      a,$FF
  94+ E0F7 C9                                   ret
  95+ E0F8
  96+ E0F8 7E           L1PrintWordAtHL:        ld      a,(hl)
  97+ E0F9 FE 00                                cp      0
  98+ E0FB C8                                   ret     z
  99+ E0FC FE 20                                cp      32
 100+ E0FE 28 0F                                jr      z,.ItsASpace
 101+ E100 FD E5                                push    iy
 102+ E102 CD AB E0                             call	l1_print_char
 103+ E105 FD E1                                pop     iy
 104+ E107 7B                                   ld      a,e
 105+ E108 C6 08                                add     a,8
 106+ E10A 5F                                   ld      e,a
 107+ E10B 23                                   inc     hl
 108+ E10C C3 F8 E0                             jp      L1PrintWordAtHL
 109+ E10F 23           .ItsASpace:             inc     hl      ;  Just a bodge for now
 110+ E110 7B                                   ld      a,e
 111+ E111 C6 08                                add     a,8
 112+ E113 5F                                   ld      e,a
 113+ E114 C9                                   ret
 114+ E115
 115+ E115
 116+ E115              ; "l1 PrintAt, pixel row, whole char col, DE = yx, HL = message Addr"
 117+ E115              ; Now has full word level wrapping
 118+ E115 FD 63        l1_print_at_wrap:       ld      iyh,e
 119+ E117 7E           .PrintLoop:             ld		a,(hl)
 120+ E118 FE 00                                cp		0
 121+ E11A C8                                   ret		z
 122+ E11B CD D9 E0     .CountWordCharLen:      call    L1LenWordAtHL
 123+ E11E FE FF                                cp      $FF
 124+ E120 28 06                                jr      z,.WrapNextLine
 125+ E122 CD F8 E0     .NotTooLong:            call    L1PrintWordAtHL
 126+ E125              ; Need to change to word wrap, so it will loop through string as before
 127+ E125              ; but read up until a null or space, take the character count * 8 for pixels
 128+ E125              ; if that is > 238 then force a premature line wrap
 129+ E125 18 F0                                jr		.PrintLoop
 130+ E127              .Clearstackandfinish:   ;op		de
 131+ E127 C9                                   ret
 132+ E128              .WrapNextLine:
 133+ E128 FD 5C        .NextLine:              ld      e,iyh
 134+ E12A 7A                                   ld      a,d
 135+ E12B C6 08                                add     a,8
 136+ E12D 57                                   ld      d,a
 137+ E12E 18 E7                                jr		.PrintLoop
 138+ E130
 139+ E130
# file closed: ./Layer1Graphics/layer1_print_at.asm
 268  E130
 269  E130                  SLOT    LAYER2Addr
 270  E130                  PAGE    BankLAYER2
 271  E130                  ORG     LAYER2Addr
 272  E000
 273  E000                  INCLUDE "./Layer2Graphics/layer2_bank_select.asm"
# file opened: ./Layer2Graphics/layer2_bank_select.asm
   1+ E000
   2+ E000 00           varL2_BANK_SELECTED			 DB	0
   3+ E001 00           varL2_BUFFER_MODE            DB 0
   4+ E002 00           varL2_ACCESS_MODE            DB 0
   5+ E003
   6+ E003 3E 08        asm_l2_double_buffer_on:    ld      a,8
   7+ E005 32 01 E0                                 ld      (varL2_BUFFER_MODE),a
   8+ E008 C9                                       ret
   9+ E009
  10+ E009 AF           asm_l2_double_buffer_off:   xor     a
  11+ E00A 32 01 E0                                 ld      (varL2_BUFFER_MODE),a
  12+ E00D C9                                       ret
  13+ E00E
  14+ E00E 01 3B 12     asm_disable_l2_readwrite:   ld      bc, IO_LAYER2_PORT
  15+ E011 ED 70                                    in      (c)
  16+ E013 32 02 E0                                 ld      (varL2_ACCESS_MODE),a
  17+ E016 E6 FA                                    and     LAYER2_DISABLE_MEM_ACCESS
  18+ E018 ED 79                                    out     (c),a
  19+ E01A C9                                       ret
  20+ E01B
  21+ E01B 3A 02 E0     asm_restore_l2_readwrite:   ld      a,(varL2_ACCESS_MODE)
  22+ E01E E6 05                                    and     LAYER2_READ_WRITE_MASK
  23+ E020 57                                       ld      d,a
  24+ E021 01 3B 12                                 ld      bc, IO_LAYER2_PORT
  25+ E024 ED 70                                    in      (c)
  26+ E026 32 02 E0                                 ld      (varL2_ACCESS_MODE),a
  27+ E029 A2                                       and     d
  28+ E02A ED 79                                    out     (c),a
  29+ E02C C9                                       ret
  30+ E02D
  31+ E02D 01 3B 12     asm_enable_l2_readwrite:    ld      bc, IO_LAYER2_PORT
  32+ E030 ED 70                                    in      (c)
  33+ E032 F6 05                                    or      LAYER2_READ_WRITE_MASK
  34+ E034 ED 79                                    out     (c),a
  35+ E036 C9                                       ret
  36+ E037
  37+ E037              ; "asm_l2_bank_select"
  38+ E037              ; " a = sepecific bank mask value to select, does not set varL2_BANK_SELECTED"
  39+ E037 57           asm_l2_bank_select:         ld      d,a
  40+ E038 3A 01 E0                                 ld      a,(varL2_BUFFER_MODE)
  41+ E03B F6 03                                    or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK
  42+ E03D B2                                       or      d; | LAYER2_SHADOW_SCREEN_MASK
  43+ E03E 01 3B 12                                 ld 		bc, IO_LAYER2_PORT
  44+ E041 ED 79                                    out 	(c),a
  45+ E043 C9                                       ret
  46+ E044              ;  "asm_l2_bank_select a = sepecific bank number to select, dsets varL2_BANK_SELECTED"
  47+ E044 32 00 E0     asm_l2_bank_n_select:       ld		(varL2_BANK_SELECTED),a
  48+ E047 FE 00                                    cp		0
  49+ E049 20 04                                    jr 		nz,.nottopbank
  50+ E04B 3E 00        .topbank:                   ld		a,LAYER2_SHIFTED_SCREEN_TOP
  51+ E04D 18 E8                                    jr		asm_l2_bank_select
  52+ E04F FE 01        .nottopbank:                cp		1
  53+ E051 20 04                                    jr 		nz,.notmiddlebank
  54+ E053 3E 40        .middlebank:                ld		a,LAYER2_SHIFTED_SCREEN_MIDDLE
  55+ E055 18 E0                                    jr		asm_l2_bank_select
  56+ E057 3E 80        .notmiddlebank:             ld		a,LAYER2_SHIFTED_SCREEN_BOTTOM ; default to bottom
  57+ E059 18 DC                                    jr		asm_l2_bank_select
  58+ E05B              		; Note no ret as its handled by above routines
  59+ E05B
  60+ E05B              ; "asm_l2_row_bank_select"
  61+ E05B              ; "A (unsinged) = y row of pixel line from top, sets the bank to top middle or bottom and adjusts a reg to row memory address"
  62+ E05B              ; "Could optimise by holding the previous bank but given its only an out statement it may not save T states at all"
  63+ E05B              ; "destroys BC call de is safe a = adjusted poke pixel row"
  64+ E05B FE 40        asm_l2_row_bank_select:     cp 		64			; row < 64?
  65+ E05D 30 11                                    jr 		nc, .l2rowGTE64
  66+ E05F 08           .l2rowLT64:                 ex		af,af'
  67+ E060                                          ;ld		a, LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_TOP | LAYER2_SHADOW_SCREEN_MASK
  68+ E060 3A 01 E0                                 ld      a,(varL2_BUFFER_MODE)
  69+ E063 F6 03                                    or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_TOP
  70+ E065 01 3B 12                                 ld 		bc, IO_LAYER2_PORT
  71+ E068 ED 79                                    out 	(c),a
  72+ E06A AF                                       xor		a						; set a to 0
  73+ E06B 32 00 E0                                 ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
  74+ E06E 08                                       ex		af,af'					; return pixel poke unharmed
  75+ E06F C9                                       ret
  76+ E070 FE 80        .l2rowGTE64:                cp 		128
  77+ E072 30 14                                    jr 		nc, .l2rowGTE128
  78+ E074 08           .l2row64to127:              ex		af,af'
  79+ E075                                  ;		ld		a, LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_MIDDLE | LAYER2_SHADOW_SCREEN_MASK
  80+ E075 3A 01 E0                                 ld      a,(varL2_BUFFER_MODE)
  81+ E078 F6 43                                    or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_MIDDLE
  82+ E07A 01 3B 12                                 ld 		bc, IO_LAYER2_PORT
  83+ E07D ED 79                                    out 	(c),a
  84+ E07F 3E 01                                    ld		a,1						; set a to 1
  85+ E081 32 00 E0                                 ld		(varL2_BANK_SELECTED),a	; save selected bank
  86+ E084 08                                       ex		af,af'
  87+ E085 D6 40                                    sub		64
  88+ E087 C9                                       ret
  89+ E088 08           .l2rowGTE128:               ex		af,af'
  90+ E089                                  ;		ld		a, LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_BOTTOM | LAYER2_SHADOW_SCREEN_MASK
  91+ E089 3A 01 E0                                 ld      a,(varL2_BUFFER_MODE)
  92+ E08C F6 83                                    or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_BOTTOM
  93+ E08E
  94+ E08E 01 3B 12                                 ld 		bc, IO_LAYER2_PORT
  95+ E091 ED 79                                    out 	(c),a
  96+ E093 3E 01                                    ld		a,1						; set a to 2
  97+ E095 32 00 E0                                 ld		(varL2_BANK_SELECTED),a	; save selected bank
  98+ E098 08                                       ex		af,af'
  99+ E099 D6 80                                    sub		128
 100+ E09B C9                                       ret
 101+ E09C
# file closed: ./Layer2Graphics/layer2_bank_select.asm
 274  E09C                  INCLUDE "./Layer2Graphics/layer2_cls.asm"
# file opened: ./Layer2Graphics/layer2_cls.asm
   1+ E09C
   2+ E09C 00           l2_cls_byte	            DB 0
   3+ E09D              ; ">DMA Command BLOCK"
   4+ E09D
   5+ E09D 83 C3 C7 CB  l2_fill                 DB DMA_DISABLE,  DMA_RESET, DMA_RESET_PORT_A_TIMING, DMA_RESET_PORT_B_TIMING ,DMA_WRO_BLOCK_PORTA_A2B_XFR
   5+ E0A1 7D
   6+ E0A2 9C E0        l2_fill_astrt           DW l2_cls_byte
   7+ E0A4 00 40        l2_fill_length          DB $00,$40
   8+ E0A6 24 10 AD                             DB DMA_WR1_P1FIXED_MEMORY ,DMA_WR2_P2INC_MEMORY ,DMA_WR4_CONT_MODE
   9+ E0A9 00 00        l2_fill_bstrt           DB $00,$00
  10+ E0AB 82 CF B3 87                          DB DMA_STOP_AT_END, DMA_LOAD, DMA_FORCE_READY, DMA_ENABLE
  11+ E0AF              l2_fill_cmd_len	        EQU $ - l2_fill
  12+ E0AF
  13+ E0AF              l2_cls_dma_bank:
  14+ E0AF              ; ">l2_cls_dma_bank"
  15+ E0AF              ; ">sets a bank to"
  16+ E0AF 32 9C E0     .set_colour:            ld (l2_cls_byte),a
  17+ E0B2 21 9D E0     .write_dma:             ld hl, l2_fill
  18+ E0B5 06 12                                ld b, l2_fill_cmd_len
  19+ E0B7 0E 6B                                ld	c,IO_DATAGEAR_DMA_PORT
  20+ E0B9 ED B3                                otir
  21+ E0BB C9                                   ret
  22+ E0BC
  23+ E0BC 3E 00        l2_set_color_upper2:    ld      a,0
  24+ E0BE CD 5B E0                             call asm_l2_row_bank_select
  25+ E0C1 3A 9C E0                             ld      a,(l2_cls_byte)
  26+ E0C4 CD AF E0                             call l2_cls_dma_bank
  27+ E0C7 3E 40                                ld a,64								; pretend we are plotting pixel on row 64 to force mid selection
  28+ E0C9 CD 5B E0                             call asm_l2_row_bank_select
  29+ E0CC 3A 9C E0                             ld      a,(l2_cls_byte)
  30+ E0CF CD AF E0                             call l2_cls_dma_bank
  31+ E0D2 C9                                   ret
  32+ E0D3
  33+ E0D3
  34+ E0D3 3E 00        l2_cls_upper_two_thirds:ld a,0								; pretend we are plotting pixel on row 0 to force top selection
  35+ E0D5 CD 5B E0                             call asm_l2_row_bank_select
  36+ E0D8 3E E3                                ld 	a,COLOUR_TRANSPARENT
  37+ E0DA CD AF E0                             call l2_cls_dma_bank
  38+ E0DD 3E 40                                ld a,64								; pretend we are plotting pixel on row 64 to force mid selection
  39+ E0DF CD 5B E0                             call asm_l2_row_bank_select
  40+ E0E2 3E E3                                ld 	a,COLOUR_TRANSPARENT
  41+ E0E4 CD AF E0                             call l2_cls_dma_bank
  42+ E0E7 C9                                   ret
  43+ E0E8
  44+ E0E8 3E 80        l2_cls_lower_third:     ld a,128							; pretend we are plotting pixel on row 64 to force mid selection
  45+ E0EA CD 5B E0                             call asm_l2_row_bank_select
  46+ E0ED 3E E3                                ld 	a,COLOUR_TRANSPARENT
  47+ E0EF CD AF E0                             call l2_cls_dma_bank
  48+ E0F2 C9                                   ret
  49+ E0F3
  50+ E0F3 CD D3 E0     l2_cls:                 call l2_cls_upper_two_thirds
  51+ E0F6 CD E8 E0                             call l2_cls_lower_third
  52+ E0F9 C9                                   ret
  53+ E0FA
# file closed: ./Layer2Graphics/layer2_cls.asm
 275  E0FA                  INCLUDE "./Layer2Graphics/layer2_initialise.asm"
# file opened: ./Layer2Graphics/layer2_initialise.asm
   1+ E0FA
   2+ E0FA ED 91 12 08  l2_initialise:          nextreg		LAYER2_RAM_PAGE_REGISTER,          	LAYER2_SCREEN_BANK1
   3+ E0FE ED 91 13 0B                          nextreg		LAYER2_RAM_SHADOW_REGISTER,     	LAYER2_SHADOW_BANK1
   4+ E102 ED 91 14 E3                          nextreg		TRANSPARENCY_COLOUR_REGISTER, 		COLOUR_TRANSPARENT
   5+ E106 C9                                   ret
   6+ E107
# file closed: ./Layer2Graphics/layer2_initialise.asm
 276  E107                  INCLUDE "./Layer2Graphics/l2_flip_buffers.asm"
# file opened: ./Layer2Graphics/l2_flip_buffers.asm
   1+ E107              l2_flip_buffers:        GetNextReg LAYER2_RAM_PAGE_REGISTER
   1+ E107 C5          >            push bc
   1+ E108 01 3B 24    >                ld bc,$243B
   1+ E10B 3E 12       >                    ld a,LAYER2_RAM_PAGE_REGISTER
   1+ E10D ED 79       >                    out (c),a
   1+ E10F 04          >                    inc b
   1+ E110 ED 78       >                in a,(c)
   1+ E112 C1          >            pop bc
   2+ E113 57                                   ld      d,a
   3+ E114                                      GetNextReg LAYER2_RAM_SHADOW_REGISTER
   3+ E114 C5          >            push bc
   3+ E115 01 3B 24    >                ld bc,$243B
   3+ E118 3E 13       >                    ld a,LAYER2_RAM_SHADOW_REGISTER
   3+ E11A ED 79       >                    out (c),a
   3+ E11C 04          >                    inc b
   3+ E11D ED 78       >                in a,(c)
   3+ E11F C1          >            pop bc
   4+ E120 5F                                   ld      e,a
   5+ E121 ED 92 12                             nextreg LAYER2_RAM_PAGE_REGISTER, a
   6+ E124 7A                                   ld      a,d
   7+ E125 ED 92 13                             nextreg LAYER2_RAM_SHADOW_REGISTER, a
   8+ E128 C9                                   ret
   9+ E129
# file closed: ./Layer2Graphics/l2_flip_buffers.asm
 277  E129                  INCLUDE "./Layer2Graphics/layer2_plot_pixel.asm"
# file opened: ./Layer2Graphics/layer2_plot_pixel.asm
   1+ E129              l2_plot_pixel:
   2+ E129              ; ">l2_plot_pixel b= row number, c = column number, a = pixel col"
   3+ E129 F5           	push    af
   4+ E12A 78               ld      a,b
   5+ E12B              l2_pp_row_valid:
   6+ E12B                  JumpIfAGTENusng ScreenHeight,l2_pp_dont_plot
   6+ E12B FE C0       >                        cp     ScreenHeight
   6+ E12D D2 3B E1    >                        jp		nc,l2_pp_dont_plot
   7+ E130 C5           	push    bc								; bank select destroys bc so need to save it
   8+ E131              ;	ld      a,b
   9+ E131 CD 5B E0     	call    asm_l2_row_bank_select
  10+ E134 C1           	pop     bc
  11+ E135 47           	ld      b,a
  12+ E136 60           	ld      h,b								; hl now holds ram address after bank select
  13+ E137 69           	ld      l,c
  14+ E138 F1           	pop     af								; a = colour to plott
  15+ E139 77           	ld      (hl),a
  16+ E13A C9           	ret
  17+ E13B              l2_pp_dont_plot:
  18+ E13B F1               pop     af
  19+ E13C C9               ret
  20+ E13D
  21+ E13D              l2_plot_pixel_no_bank:
  22+ E13D              ; ">l2_plot_pixel_no_bank b= row number, c = column number, a = pixel col"
  23+ E13D              ; This version assues pixel is in the same bank as previously plotted ones. optimised for horizontal lines
  24+ E13D E5           	push 	hl
  25+ E13E 60           	ld 		h,b								; hl now holds ram address after bank select
  26+ E13F 69           	ld 		l,c
  27+ E140 77           	ld 		(hl),a
  28+ E141 E1           	pop		hl
  29+ E142 C9           	ret
  30+ E143
  31+ E143              l2_plot_pixel_y_test:
  32+ E143 F5           	push	af
  33+ E144 78           	ld		a,b
  34+ E145 FE C0        	cp		192
  35+ E147 30 03        	jr		nc,.clearup
  36+ E149 F1           	pop		af
  37+ E14A 18 DD        	jr		l2_plot_pixel
  38+ E14C              .clearup:
  39+ E14C F1           	pop		af
  40+ E14D C9           	ret
  41+ E14E
  42+ E14E              l2_point_pixel_y_safe:	MACRO
  43+ E14E ~            						push	hl
  44+ E14E ~            						push	bc
  45+ E14E ~            						call	l2_plot_pixel
  46+ E14E ~            						pop		bc
  47+ E14E ~            						pop		hl
  48+ E14E              						ENDM
  49+ E14E
# file closed: ./Layer2Graphics/layer2_plot_pixel.asm
 278  E14E                  INCLUDE "./Layer2Graphics/layer2_print_character.asm"
# file opened: ./Layer2Graphics/layer2_print_character.asm
   1+ E14E
   2+ E14E              l2_print_chr_at:
   3+ E14E              ; "l2_print_chr_at, bc = col,row, d= character, e = colour"
   4+ E14E              ; "Need a version that also prints absence of character"
   5+ E14E 7A           	ld		a,d
   6+ E14F FE 20        	cp		32
   7+ E151 38 3F        	jr		c,.InvalidCharacter		; Must be between 32 and 127
   8+ E153 FE 7F        	cp		127
   9+ E155 30 3B        	jr		nc,.InvalidCharacter
  10+ E157              .ValidCharater:
  11+ E157 26 00        	ld		h,0
  12+ E159 6A           	ld		l,d
  13+ E15A 29           	add		hl,hl						; * 2
  14+ E15B 29           	add		hl,hl						; * 4
  15+ E15C 29           	add		hl,hl						; * 8 to get byte address
  16+ E15D ED 34 00 3C  	add		hl,charactersetaddr			; hl = address of rom char
  17+ E161 04           	inc		b							; start + 1 pixel x and y as we only print 7x7
  18+ E162 23           	inc		hl							; skip first byte
  19+ E163 16 07        	ld		d,7
  20+ E165              .PrintCharLoop:
  21+ E165 D5           	push	de
  22+ E166 7E           	ld		a,(hl)
  23+ E167 FE 00        	cp		0
  24+ E169 28 21        	jr		z,.NextRowNoBCPop
  25+ E16B              .PrintARow:
  26+ E16B C5           	push	bc							; save row col
  27+ E16C 16 07        	ld		d,7							; d is loop row number now
  28+ E16E              .PrintPixelLoop:
  29+ E16E 0C           	inc		c							; we start at col 1 not 0 so can move inc here
  30+ E16F              .PrintTheRow:
  31+ E16F CB 27        	sla		a							; scroll char 1 pixel as we read from bit 7
  32+ E171 F5           	push	af							; save character byte
  33+ E172 CB 7F        	bit		7,a							; If left most pixel set then plot
  34+ E174 20 04        	jr		nz,.PixelToPrint
  35+ E176              .NoPixelToPrint:
  36+ E176 3E E3        	ld		a,$E3
  37+ E178 18 01        	jr		.HaveSetPixelColour
  38+ E17A              .PixelToPrint:
  39+ E17A 7B           	ld		a,e							; Get Colour
  40+ E17B              .HaveSetPixelColour
  41+ E17B E5           	push	hl
  42+ E17C              ;	push	bc							; at the moment we don't do paging on first plot so need to preserve BC
  43+ E17C              .BankOnFirstOnly:
  44+ E17C F5           	push	af
  45+ E17D 7A           	ld		a,d
  46+ E17E FE 07        	cp		7
  47+ E180 28 11        	jr		z,.PlotWithBank
  48+ E182              .PlotNoBank:
  49+ E182 F1           	pop		af
  50+ E183 60           	ld 		h,b								; hl now holds ram address after bank select
  51+ E184 69           	ld 		l,c
  52+ E185 77           	ld 		(hl),a
  53+ E186              .IterateLoop:
  54+ E186              ;	pop		bc
  55+ E186 E1           	pop		hl
  56+ E187 F1           	pop		af							; a= current byte shifted
  57+ E188 15           	dec		d						 	; do dec after inc as we amy
  58+ E189 20 E3        	jr		nz,.PrintPixelLoop
  59+ E18B              .NextRow:
  60+ E18B C1           	pop		bc							; Current Col Row
  61+ E18C              .NextRowNoBCPop:
  62+ E18C D1           	pop		de							; d= row loop
  63+ E18D 04           	inc		b							; Down 1 row
  64+ E18E 23           	inc		hl							; Next character byte
  65+ E18F 15           	dec		d							; 1 done now
  66+ E190 20 D3        	jr		nz,.PrintCharLoop
  67+ E192              .InvalidCharacter:
  68+ E192 C9           	ret
  69+ E193              .PlotWithBank:
  70+ E193 F1           	pop		af
  71+ E194 CD 29 E1     	call	l2_plot_pixel				; This will shift bc to poke row
  72+ E197 18 ED        	jr		.IterateLoop
  73+ E199
  74+ E199              l2_print_at:
  75+ E199              ; "l2_print_at bc= colrow, hl = addr of message, e = colour"
  76+ E199              ; "No error trapping, if there is no null is will just cycle on the line"
  77+ E199 7E           	ld	a,(hl)							; Return if empty string
  78+ E19A FE 00        	cp	0
  79+ E19C C8           	ret	z
  80+ E19D E5           	push	hl
  81+ E19E D5           	push	de
  82+ E19F C5           	push	bc
  83+ E1A0 57           	ld		d,a							; bc = pos, de = char and colour
  84+ E1A1 CD 4E E1     	call 	l2_print_chr_at
  85+ E1A4 C1           	pop		bc
  86+ E1A5 D1           	pop		de
  87+ E1A6 E1           	pop		hl
  88+ E1A7              .Move8Pixlestoright:
  89+ E1A7 08           	ex		af,af'
  90+ E1A8 79           	ld		a,c
  91+ E1A9 C6 08        	add		8
  92+ E1AB 4F           	ld		c,a
  93+ E1AC 08           	ex		af,af'
  94+ E1AD 23           	inc		hl
  95+ E1AE 18 E9        	jr		l2_print_at					; Just loop until 0 found
  96+ E1B0
  97+ E1B0
  98+ E1B0              ; "l2_print_chr_at, bc = col,row, d= character, e = colour"
  99+ E1B0              ; "Need a version that also prints absence of character"
 100+ E1B0              ; removed blank line optimisation as we need spaces printed
 101+ E1B0 7A           l2_print_7chr_at:       ld		a,d
 102+ E1B1 FE 1F                                cp		31
 103+ E1B3 38 3D                                jr		c,.InvalidCharacter		; Must be between 32 and 127
 104+ E1B5 FE 7F                                cp		127
 105+ E1B7 30 39                                jr		nc,.InvalidCharacter
 106+ E1B9 26 00        .ValidCharater:         ld		h,0
 107+ E1BB 6A                                   ld		l,d
 108+ E1BC 29                                   add		hl,hl						; * 2
 109+ E1BD 29                                   add		hl,hl						; * 4
 110+ E1BE 29                                   add		hl,hl						; * 8 to get byte address
 111+ E1BF ED 34 00 3C                          add		hl,charactersetaddr			; hl = address of rom char
 112+ E1C3 04                                   inc		b							; start + 1 pixel x and y as we only print 7x7
 113+ E1C4 23                                   inc		hl							; skip first byte
 114+ E1C5 16 07                                ld		d,7
 115+ E1C7 D5           .PrintCharLoop:         push	de
 116+ E1C8 7E                                   ld		a,(hl)
 117+ E1C9                                      ;cp		0
 118+ E1C9                                      ;jr		z,.NextRowNoBCPop
 119+ E1C9 C5           .PrintARow:             push	bc							; save row col
 120+ E1CA 16 06                                ld		d,6							; d is loop row number now
 121+ E1CC 0C           .PrintPixelLoop:        inc		c							; we start at col 1 not 0 so can move inc here
 122+ E1CD 28 1C                                jr		z,.NextRow
 123+ E1CF CB 27                                sla		a							; scroll char 1 pixel as we read from bit 7
 124+ E1D1 F5                                   push	af							; save character byte
 125+ E1D2 CB 7F                                bit		7,a							; If left most pixel set then plot
 126+ E1D4 20 04                                jr		nz,.PixelToPrint
 127+ E1D6 3E E3        .NoPixelToPrint:        ld		a,$E3
 128+ E1D8 18 01                                jr		.HaveSetPixelColour
 129+ E1DA 7B           .PixelToPrint:          ld		a,e							; Get Colour
 130+ E1DB E5           .HaveSetPixelColour		push	hl
 131+ E1DC                                      ;	push	bc							; at the moment we don't do paging on first plot so need to preserve BC
 132+ E1DC F5           .BankOnFirstOnly:       push	af
 133+ E1DD 7A                                   ld		a,d
 134+ E1DE FE 06                                cp		6
 135+ E1E0 28 11                                jr		z,.PlotWithBank
 136+ E1E2 F1           .PlotNoBank:            pop		af
 137+ E1E3 60                                   ld 		h,b								; hl now holds ram address after bank select
 138+ E1E4 69                                   ld 		l,c
 139+ E1E5 77                                   ld 		(hl),a
 140+ E1E6              .IterateLoop:	        ;	pop		bc
 141+ E1E6 E1                                   pop		hl
 142+ E1E7 F1                                   pop		af							; a= current byte shifted
 143+ E1E8 15                                   dec		d						 	; do dec after inc as we amy
 144+ E1E9 20 E1                                jr		nz,.PrintPixelLoop
 145+ E1EB C1           .NextRow:               pop		bc							; Current Col Row
 146+ E1EC D1           .NextRowNoBCPop:	    pop		de							; d= row loop
 147+ E1ED 04                                   inc		b							; Down 1 row
 148+ E1EE 23                                   inc		hl							; Next character byte
 149+ E1EF 15                                   dec		d							; 1 done now
 150+ E1F0 20 D5                                jr		nz,.PrintCharLoop
 151+ E1F2 C9           .InvalidCharacter:      ret
 152+ E1F3 F1           .PlotWithBank:          pop		af
 153+ E1F4 CD 29 E1                             call	l2_plot_pixel				; This will shift bc to poke row
 154+ E1F7 18 ED                                jr		.IterateLoop
 155+ E1F9
 156+ E1F9              ; "l2_print_7at bc= colrow, hl = addr of message, e = colour"
 157+ E1F9              ; "No error trapping, if there is no null is will just cycle on the line"
 158+ E1F9 7E           l2_print_7at:           ld	a,(hl)							; Return if empty string
 159+ E1FA FE 00                                cp	0
 160+ E1FC C8                                   ret	z
 161+ E1FD E5                                   push	hl
 162+ E1FE D5                                   push	de
 163+ E1FF C5                                   push	bc
 164+ E200 57                                   ld		d,a							; bc = pos, de = char and colour
 165+ E201 CD B0 E1                             call 	l2_print_7chr_at
 166+ E204 C1                                   pop		bc
 167+ E205 D1                                   pop		de
 168+ E206 E1                                   pop		hl
 169+ E207 08           .Move7Pixlestoright:	ex		af,af'
 170+ E208 79                                   ld		a,c
 171+ E209 C6 07                                add		7
 172+ E20B 4F                                   ld		c,a
 173+ E20C 08                                   ex		af,af'
 174+ E20D 23                                   inc		hl
 175+ E20E 18 E9                                jr		l2_print_7at					; Just loop until 0 found
 176+ E210
 177+ E210
# file closed: ./Layer2Graphics/layer2_print_character.asm
 279  E210                  INCLUDE "./Layer2Graphics/layer2_draw_box.asm"
# file opened: ./Layer2Graphics/layer2_draw_box.asm
   1+ E210              ; "l2_draw_thick_box bc=rowcol, de=heightwidth h=color"
   2+ E210              ; TODO DMA Optimise
   3+ E210 C5 D5 E5     l2_draw_fill_box:       push    bc,,de,,hl
   4+ E213 53                                   ld      d,e
   5+ E214 5C                                   ld      e,h
   6+ E215 CD 8A E2                             call    l2_draw_horz_line           ; "bc = left side row,col, d = length, e = color"
   7+ E218 E1 D1 C1                             pop     bc,,de,,hl
   8+ E21B 04                                   inc     b
   9+ E21C 15                                   dec     d
  10+ E21D C8                                   ret     z
  11+ E21E 18 F0                                jr      l2_draw_fill_box
  12+ E220
  13+ E220              ; "l2_draw_box bc=rowcol, de=heightwidth a=color"
  14+ E220 C5 D5 F5     l2_draw_box:            push	bc,,de,,af
  15+ E223 53                                   ld		d,e
  16+ E224 5F                                   ld		e,a
  17+ E225 14                                   inc		d
  18+ E226 CD 8A E2                             call	l2_draw_horz_line
  19+ E229 F1 D1 C1                             pop		bc,,de,,af
  20+ E22C C5 D5 F5     .bottomhorzline:	    push	bc,,de,,af
  21+ E22F 67                                   ld		h,a							;save color whilst b = row + height
  22+ E230 78                                   ld		a,b
  23+ E231 82                                   add		a,d
  24+ E232 47                                   ld		b,a
  25+ E233 53                                   ld		d,e							; d = width
  26+ E234 14                                   inc		d							; Extra pixel for width
  27+ E235 5C                                   ld		e,h							; e = colour
  28+ E236 CD 8A E2                             call	l2_draw_horz_line
  29+ E239 F1 D1 C1                             pop		bc,,de,,af
  30+ E23C C5 D5 F5     .leftvertline:          push	bc,,de,,af
  31+ E23F 04                                   inc		b							; save 2 pixles
  32+ E240 15                                   dec		d
  33+ E241 5F                                   ld		e,a							; e = color
  34+ E242 CD DB E2                             call	l2_draw_vert_line
  35+ E245 F1 D1 C1                             pop		bc,,de,,af
  36+ E248 04           .rightvertline:         inc		b							; save 2 pixles
  37+ E249 15                                   dec		d
  38+ E24A 67                                   ld		h,a							;save color whilst c = col + width
  39+ E24B 79                                   ld		a,c
  40+ E24C 83                                   add		a,e
  41+ E24D 4F                                   ld		c,a
  42+ E24E 5C                                   ld		e,h							; e = color
  43+ E24F CD DB E2                             call	l2_draw_vert_line
  44+ E252 C9                                   ret
  45+ E253
# file closed: ./Layer2Graphics/layer2_draw_box.asm
 280  E253                  INCLUDE "./Layer2Graphics/asm_l2_plot_horizontal.asm"
# file opened: ./Layer2Graphics/asm_l2_plot_horizontal.asm
   1+ E253
   2+ E253              ;; NOTE DMA is little endian
   3+ E253 00           l2_horz_pixel           DB 0
   4+ E254
   5+ E254 83 C3 C7 CB  l2_horz_line            DB DMA_DISABLE,  DMA_RESET, DMA_RESET_PORT_A_TIMING, DMA_RESET_PORT_B_TIMING ,DMA_WRO_BLOCK_PORTA_A2B_XFR
   5+ E258 7D
   6+ E259 53 E2        l2_horz_colr            DW l2_horz_pixel
   7+ E25B 00           l2_horz_lenlo           DB 0
   8+ E25C 00           l2_horz_lenhi           DB 0
   9+ E25D 24 10 AD                             DB DMA_WR1_P1FIXED_MEMORY, DMA_WR2_P2INC_MEMORY, DMA_WR4_CONT_MODE
  10+ E260 00 00        l2_horz_target          DB $00, $00
  11+ E262 CF 87                                DB DMA_LOAD, DMA_ENABLE
  12+ E264              l2_horz_cmd_len	        EQU $ - l2_horz_line
  13+ E264
  14+ E264
  15+ E264              ; "l2_draw_horz_dma"
  16+ E264              ; "plot at bc for length d colour e using dma, assumes bank already selected"
  17+ E264 7B           l2_draw_horz_dma:       ld		a,e                                               ; T=4      ;
  18+ E265 32 53 E2                             ld		(l2_horz_pixel),a                                 ; T=13     ;
  19+ E268 5A                                   ld      e,d ; saved 3 t states ld		a,d                                               ; T=4      ; e=d   4
  20+ E269 16 00                                ld      d,0; saved 3 t states ld 		(l2_horz_lenlo),a                                 ; T=13     ; d = 0  7
  21+ E26B ED 53 5B E2                          ld      (l2_horz_lenlo),de; saved 3 t states xor 	a                                                 ; T=4      ; t 20  31
  22+ E26F                                      ; saved 3 t states ld ld 		(l2_horz_lenhi),a                                 ; T=13     ;
  23+ E26F                                    ; saved 4 t states  ld		h,b                           ;          ;
  24+ E26F                                    ; saved 4 t states  ld		l,c                           ;          ;
  25+ E26F ED 43 60 E2                          ld      (l2_horz_target),bc ; saved 4 t states  was , hl  ; T=20     ;
  26+ E273 21 54 E2     .write_dma:             ld 		hl, l2_horz_line                                  ;          ;
  27+ E276 06 10                                ld 		b, l2_horz_cmd_len                                ;
  28+ E278 0E 6B                                ld		c,IO_DATAGEAR_DMA_PORT                            ;
  29+ E27A ED B3                                otir                                                      ;
  30+ E27C C9                                   ret
  31+ E27D
  32+ E27D              ; "bc = left side row,col, d = length, e = color"
  33+ E27D D5           l2_draw_horz_dma_bank:  push 	de							; save length and colour
  34+ E27E C5                                   push 	bc							; save row col
  35+ E27F 78                                   ld   	a,b
  36+ E280 CD 5B E0                             call 	asm_l2_row_bank_select		; now we have the correct bank, its a horizontal line so bank will not shift
  37+ E283 C1                                   pop  	bc
  38+ E284 47                                   ld	 	b,a	       					; fixed row by the call we can go straight into HL with row col
  39+ E285 D1                                   pop  	de							; get length back
  40+ E286 CD 64 E2                             call    l2_draw_horz_dma
  41+ E289 C9                                   ret
  42+ E28A
  43+ E28A              ; "l2_draw_horz_line"
  44+ E28A              ; "bc = left side row,col, d = length, e = color"
  45+ E28A              ; "optimisation if above min pix is will use dma call SCREEN_HOZ_MIN_PIX not implemented yet"
  46+ E28A 7A           l2_draw_horz_line:      ld		a,d
  47+ E28B FE 00                                cp 		0							; if its zero length then just return
  48+ E28D C8           .zerolengthexit:        ret		z
  49+ E28E FE 01        .isitlen1:              cp 		1
  50+ E290 CA B2 E2                             jp 		z,.l2_draw_horz_line_1
  51+ E293 FE 0A        .longenoughtfordma:     cp  10
  52+ E295 C3 7D E2                             jp  l2_draw_horz_dma_bank
  53+ E298 D5 C5        .plottableline:         push 	de,,bc  					; save length and colour an d row col
  54+ E29A 78                                   ld   	a,b
  55+ E29B CD 5B E0                             call 	asm_l2_row_bank_select		; now we have the correct bank, its a horizontal line so bank will not shift
  56+ E29E C1                                   pop  	bc
  57+ E29F 67                                   ld	 	h,a	       					; fixed row by the call we can go straight into HL with row col
  58+ E2A0 69                                   ld   	l,c
  59+ E2A1 D1                                   pop  	de							; get length back
  60+ E2A2 79           .cliptest:              ld	 	a,c							; get column + length
  61+ E2A3 42                                   ld  	b,d  						; speculate that we don't clip by pre-loading b with length
  62+ E2A4 82                                   add  	a,d
  63+ E2A5 30 06                                jr   	nc, .l2_draw_horz_plot_loop	; if carry is set c+d > 255
  64+ E2A7 3E FF        .clipat255:             ld   	a,$FF
  65+ E2A9 91                                   sub  	c							; a holds clipped length
  66+ E2AA 47                                   ld 		b, a 						; so now hl holds poke address  b = clipped length e = colour
  67+ E2AB 18 00                                jr		.l2_draw_horz_plot_loop
  68+ E2AD 73           .l2_draw_horz_plot_loop:ld (hl),e							; loop poking hl with e for b pixels
  69+ E2AE 23                                   inc hl
  70+ E2AF 10 FC                                djnz .l2_draw_horz_plot_loop
  71+ E2B1 C9                                   ret
  72+ E2B2 7B           .l2_draw_horz_line_1:   ld		a,e
  73+ E2B3 C3 29 E1                             jp		l2_plot_pixel				; hijack return
  74+ E2B6
  75+ E2B6              ; "l2_draw_horz_line_to"
  76+ E2B6              ; "bc = left side row,col, d right pixel, e = color"
  77+ E2B6 7A           l2_draw_horz_line_to:   ld 		a,d
  78+ E2B7 B9                                   cp 		c
  79+ E2B8 30 04                                jr		nc, .noswap
  80+ E2BA 28 07                                jr      z, .singlepixel
  81+ E2BC 51           .swap:                  ld		d,c
  82+ E2BD 4F                                   ld		c,a
  83+ E2BE 7A           .noswap:                ld		a,d
  84+ E2BF 91                                   sub		c
  85+ E2C0              ;                        dec		a							; so now its length not offset
  86+ E2C0 57                                   ld		d,a
  87+ E2C1 18 C7                                jr 		l2_draw_horz_line			; hijack routine and return statements
  88+ E2C3 7B           .singlepixel:           ld		a,e
  89+ E2C4 C3 29 E1                             jp		l2_plot_pixel				; hijack return
  90+ E2C7
# file closed: ./Layer2Graphics/asm_l2_plot_horizontal.asm
 281  E2C7                  INCLUDE "./Layer2Graphics/asm_l2_plot_vertical.asm"
# file opened: ./Layer2Graphics/asm_l2_plot_vertical.asm
   1+ E2C7              ; ">l2_draw_vert_segment"
   2+ E2C7              ; ">hl = bank adjusted pixel poke address d = length, e = color"
   3+ E2C7              ; ">will always clip once h = 64 even if length > 64 destroys a and hl, d = resudual length not plotted"
   4+ E2C7 7A           l2_draw_vert_segment:   ld		a,d
   5+ E2C8 FE 00        .emptylinecheck:	    cp 		0
   6+ E2CA C8                                   ret		z
   7+ E2CB FE 01        .justonepixel	        cp		1
   8+ E2CD 20 02                                jr		nz, .multiplepixelsLoop
   9+ E2CF 73                                   ld		(hl),e
  10+ E2D0 C9                                   ret
  11+ E2D1              .multiplepixelsLoop:
  12+ E2D1 7C           .endofbankcheck:        ld   	a,h
  13+ E2D2 FE 40                                cp   	64
  14+ E2D4 D0                                   ret		nc							; check before we poke data if we have hit a boundary
  15+ E2D5 73           .canplotapixel:         ld   	(hl),e						; set colour
  16+ E2D6 24                                   inc 	h							; we don't check here else we would need a dec d on ret could do for optimisation of loop though
  17+ E2D7 15                                   dec		d
  18+ E2D8 C8                                   ret		z
  19+ E2D9 18 F6                                jr		.multiplepixelsLoop
  20+ E2DB
  21+ E2DB              ; ">l2_draw_vert_line"
  22+ E2DB              ; ">bc = row col d = length, e = color"
  23+ E2DB 78           l2_draw_vert_line:      ld 		a,b
  24+ E2DC FE C0        .offscreencheck:        cp 		SCREEN_HEIGHT
  25+ E2DE D0                                   ret 	nc							; can't start off the screen
  26+ E2DF 7A           .emptylinecheck:        ld		a,d
  27+ E2E0 FE 00                                cp		0
  28+ E2E2 C8                                   ret		z
  29+ E2E3 FE 01                                cp		1
  30+ E2E5 20 04                                jr		nz,.multiplepixels
  31+ E2E7 CD 29 E1     .itsonepixel:           call	l2_plot_pixel
  32+ E2EA C9                                   ret
  33+ E2EB              .multiplepixels:						; so now we have at least 2 pixels to plot
  34+ E2EB 7A           .clipto192:             ld		a,d							; get length
  35+ E2EC 80                                   add		a,b							; a= row + length
  36+ E2ED 38 04                                jr		c,.needtoclip				; if it was > 255 then there is a definite need
  37+ E2EF FE C0                                cp		SCREEN_HEIGHT
  38+ E2F1 38 08                                jr		c, .noclipneeded
  39+ E2F3 78           .needtoclip             ld		a,b
  40+ E2F4 82                                   add		a,d
  41+ E2F5 D6 C0                                sub		SCREEN_HEIGHT
  42+ E2F7 67                                   ld		h,a							; use h as a temp holding for (row + length) - 192
  43+ E2F8 7A                                   ld		a,d
  44+ E2F9 94                                   sub		h
  45+ E2FA 57                                   ld		d,a							; d = length - ((row + length) - 192)
  46+ E2FB              ; so now BC = row col, d = length clipped, e = color
  47+ E2FB 78           .noclipneeded:          ld		a,b
  48+ E2FC C5 D5                                push	bc,,de
  49+ E2FE CD 5B E0                             call 	asm_l2_row_bank_select
  49+ E301               	 	; we now have poke address and a variable holding current bank number
  50+ E301 D1 C1                                pop		bc,,de
  51+ E303 67                                   ld		h,a							; b now tolds target pixel for first plot
  52+ E304 69                                   ld		l,c  						; and c holds pixel column for plotting
  53+ E305 CD C7 E2                             call 	l2_draw_vert_segment		; draw seg, d = pixels remaining
  54+ E308 7A                                   ld		a,d							; a and d = nbr pixels remaining
  55+ E309 FE 00                                cp		0
  56+ E30B 28 27                                jr		z, .doneplotting
  57+ E30D 3A 00 E0     .anotherbank:           ld		a, (varL2_BANK_SELECTED)
  58+ E310 3C                                   inc		a
  59+ E311 06 00                                ld		b,0
  60+ E313 C5 D5                                push	bc,,de
  61+ E315 CD 44 E0                             call 	asm_l2_bank_n_select
  62+ E318 D1 C1                                pop     bc,,de
  63+ E31A 60                                   ld		h,b							; b now tolds target pixel for first plot
  64+ E31B 69                                   ld		l,c  						; and c holds pixel column for plotting
  65+ E31C CD C7 E2                             call	l2_draw_vert_segment
  66+ E31F 7A                                   ld		a,d
  67+ E320 FE 00                                cp		0
  68+ E322 28 10                                jr		z,.doneplotting
  69+ E324 3A 00 E0     .yetanotherbank:        ld		a, (varL2_BANK_SELECTED)
  70+ E327 3C                                   inc		a
  71+ E328 06 00                                ld		b,0
  72+ E32A C5 D5                                push	bc,,de
  73+ E32C CD 44 E0                             call 	asm_l2_bank_n_select
  74+ E32F D1                                   pop		de
  75+ E330 E1                                   pop		hl							; hl = bc
  76+ E331 CD C7 E2                             call	l2_draw_vert_segment		; we have now hit 192 pixels so done
  77+ E334 C9           .doneplotting:	        ret
  78+ E335
  79+ E335              ; ">l2_draw_vert_line_to"
  80+ E335              ; ">bc = row col d = to position, e = color"
  81+ E335 78           l2_draw_vert_line_to:   ld		a,b
  82+ E336 BA                                   cp		d
  83+ E337 38 02                                jr		c, .noyswap
  84+ E339 42           .yswap:                 ld		b,d			; Swap round row numbers so we are always incrementing
  85+ E33A 57                                   ld		d,a			; now we have a top to bottom to we we can calc length from bc
  86+ E33B 7A           .noyswap:               ld		a,d 		; we still may have d in a but only if it was bottom to top
  87+ E33C 90                                   sub		b
  88+ E33D 3C                                   inc		a			; so now its length not offset
  89+ E33E 57                                   ld		d,a
  90+ E33F 18 9A                                jr		l2_draw_vert_line	; we can hijack its clipping, 0 check and return logic
  91+ E341                                      ; no return needed
  92+ E341
# file closed: ./Layer2Graphics/asm_l2_plot_vertical.asm
 282  E341                  INCLUDE "./Layer2Graphics/layer2_plot_diagonal.asm"
# file opened: ./Layer2Graphics/layer2_plot_diagonal.asm
   1+ E341
   2+ E341              l2_draw_box_to:
   3+ E341              ; ">l2_draw_box_to bc=rowcol, de=torowcol a=color"
   4+ E341              ; ">NOT IMPLEMENTED YET"
   5+ E341 C9           	ret
   6+ E342
   7+ E342              ;; Note l2stepx is done via self modifying code rather than an if for speed
   8+ E342              ;; l2stepx1 and l2stepx2 are the addresses to stick the inc or dec in
   9+ E342              l2decbstep	EQU $05
  10+ E342              l2incbstep	EQU	$04
  11+ E342              l2deccstep	EQU $0D
  12+ E342              l2inccstep	EQU	$0C
  13+ E342              		; l2 deltas are signed
  14+ E342 00 00        l2deltaY	DW	0
  15+ E344 00 00        l2deltaX	DW	0
  16+ E346 00           l2deltaYsq	db	0
  17+ E347 00           l2deltaXsq	db	0
  18+ E348 00           l2deltaYn	db	0
  19+ E349 00           l2deltaXn	db	0
  20+ E34A 00           l2deltaYsqn	db	0
  21+ E34B 00           l2deltaXsqn	db	0
  22+ E34C 00           l2linecolor	db	0
  23+ E34D 00 00        l2fraction	dw	0
  24+ E34F 00 00        l2e2		dw	0
  25+ E351 00           l2way		db	0
  26+ E352 00 00        l2targetPtr	dw	0
  27+ E354              ;; These arrays should be 192 but if we use 256 then getting array2 value is just inc h rather than indexing again.
  28+ E354 00 00 00...  l2targetArray1 ds	256
  29+ E454 00 00 00...  l2targetArray2 ds	256
  30+ E554              ;; Using Bresenham Algorithm draw a diagonal line top to bottom. First we must sort of course
  31+ E554              ;;plotLine(int x0, int y0, int x1, int y1)
  32+ E554              ;;    dx =  abs(x1-x0);
  33+ E554              ;;    sx = x0<x1 ? 1 : -1;
  34+ E554              ;;    dy = -abs(y1-y0);
  35+ E554              ;;    sy = y0<y1 ? 1 : -1;
  36+ E554              ;;    err = dx+dy;  /* error value e_xy */
  37+ E554              ;;    while (true)   /* loop */
  38+ E554              ;;        plot(x0, y0);
  39+ E554              ;;        if (x0==x1 && y0==y1) break;
  40+ E554              ;;        e2 = 2*err;
  41+ E554              ;;        if (e2 >= dy) /* e_xy+e_x > 0 */
  42+ E554              ;;            err += dy;
  43+ E554              ;;            x0 += sx;
  44+ E554              ;;        end if
  45+ E554              ;;        if (e2 <= dx) /* e_xy+e_y < 0 */
  46+ E554              ;;            err += dx;
  47+ E554              ;;            y0 += sy;
  48+ E554              ;;        end if
  49+ E554              ;;    end while
  50+ E554              ; ">l2_draw_diagonal_save, bc = y0,x0 de=y1,x1,a=array nbr ESOURCE LL30 or LION"
  51+ E554              ; ">hl will be either l2targetArray1 or 2"
  52+ E554              ; NOTE IF WE INTERLEAVE THESE TWO TABLES WE COUDL READ BOTH X POS as a 16 bit read
  53+ E554 FE 01        l2_draw_diagonal_save:  cp		1
  54+ E556 28 06                                jr		z,l2S_ItsArray1
  55+ E558 21 54 E4                             ld		hl,l2targetArray2
  56+ E55B C3 61 E5                             jp		l2S_setTarget
  57+ E55E 21 54 E3     l2S_ItsArray1:	        ld		hl,l2targetArray1
  58+ E561 22 52 E3     l2S_setTarget:	        ld		(l2targetPtr),hl
  59+ E564              ; ">l2_draw_diagonal, bc = y0,x0 de=y1,x1,a=color) Thsi version performs a pre sort based on y axis"
  60+ E564 32 4C E3                             ld		(l2linecolor),a					;save colour for later
  61+ E567 21 00 00                             ld		hl,0                            ;
  62+ E56A 22 44 E3                             ld		(l2deltaX),hl                   ;
  63+ E56D 22 42 E3                             ld		(l2deltaY),hl                   ; initlaise deltas as we will only be loading 8 bit in there but workign in 16 bit later
  64+ E570 78           l2S_preSort:            ld		a,b								;
  65+ E571                                      JumpIfALTNusng	d,l2S_noYSort			; we must have Y1 < Y2 (if eqyal then verical line picked up earlier
  65+ E571 BA          >                        cp      d
  65+ E572 DA 7A E5    >                        jp		c, l2S_noYSort
  66+ E575              l2S_SortBasedOnY:	    ldhlbc									;
  66+ E575 60          >                        ld		h,b
  66+ E576 69          >                        ld		l,c
  67+ E577 EB                                   ex		de,hl                           ;
  68+ E578                                      ldbchl									; swap over bc and de using hl as an intermediate
  68+ E578 44          >                        ld		b,h
  68+ E579 4D          >                        ld		c,l
  69+ E57A DD 62        l2S_noYSort:		    ld		ixh,d							; ixh now holds target Y coord post sorting
  70+ E57C DD 6B                                ld		ixl,e							; ixl now holds target X coord post sorting
  71+ E57E 79           l2S_setXLen:            ld		a,c                             ;
  72+ E57F                                      JumpIfALTNusng e,l2S_PosXLen			; if x1 < x2 then we have a positive increment
  72+ E57F BB          >                        cp      e
  72+ E580 DA 8C E5    >                        jp		c, l2S_PosXLen
  73+ E583 79           l2S_NegXLen:            ld		a,c                             ;
  74+ E584 93                                   sub     e                               ;
  75+ E585 32 44 E3                             ld		(l2deltaX),a					; As x1 > x2 we do deltaX = X1 - X2
  76+ E588 3E 0D                                ld		a,l2deccstep					; and set the value for inc dec self modifying to Dec
  77+ E58A 18 07                                jr		l2S_XINCDEC
  78+ E58C 7B           l2S_PosXLen:	        ld		a,e                             ;
  79+ E58D 91                                   sub		c                               ;
  80+ E58E 32 44 E3                             ld 		(l2deltaX),a                    ; As x1 < x2 we do deltaX = X2 - X1
  81+ E591 3E 0C                                ld		a,l2inccstep                    ; and set the value for inc dec self modifying to Inc
  82+ E593              l2S_XINCDEC:
  83+ E593 32 FF E5     	ld		(l2S_adjustCol),a				;
  84+ E596 32 2F E6     	ld		(l2S_adjustCol2),a				; update self modifying code for X update with inc or dec from above
  85+ E599              l2S_setYLen
  86+ E599 7A           	ld		a,d							 	; presorted on Y so it is now always positive
  87+ E59A 90           	sub		b
  88+ E59B 32 42 E3     	ld 		(l2deltaY),a					; DeltaY = Y2 - Y1
  89+ E59E              l2S_setErr:									;  LD H  := (D'-E')/2    round up if +ve or down if -ve
  90+ E59E              ldS_FracDYltDX:								;
  91+ E59E 2A 42 E3     	ld		hl,(l2deltaY)					; Fraction = dY - dX
  92+ E5A1 ED 5B 44 E3  	ld		de,(l2deltaX)
  93+ E5A5              	ClearCarryFlag
  93+ E5A5 B7          >                        or a
  94+ E5A6 ED 52        	sbc		hl,de							; sbc does not have an SBC IY so need to do this in HL
  95+ E5A8 EB           	ex		de,hl
  96+ E5A9 FD 62        	ld		iyh,d							; we will use IY reg for fractions
  97+ E5AB FD 6B        	ld		iyl,e
  98+ E5AD F2 D2 E5     	jp		p,l2S_fracIsPositive
  99+ E5B0              l2S_fracIsNegative:
 100+ E5B0              	NegIY
 100+ E5B0 AF          >                    xor a
 100+ E5B1 FD 95       >                    sub iyl
 100+ E5B3 FD 6F       >                    ld iyl,a
 100+ E5B5 9F          >                    sbc a,a
 100+ E5B6 FD 94       >                    sub iyh
 100+ E5B8 FD 67       >                    ld iyh,a
 101+ E5BA              	ShiftIYRight1
 101+ E5BA FD 7C       >			   ld 	a,iyh
 101+ E5BC CB 3F       >			   srl 	a
 101+ E5BE FD 67       >			   ld	iyh,a
 101+ E5C0 FD 7D       >			   ld 	a,iyl
 101+ E5C2 1F          >			   rra
 101+ E5C3 FD 6F       >			   ld	iyl,a
 102+ E5C5              	NegIY
 102+ E5C5 AF          >                    xor a
 102+ E5C6 FD 95       >                    sub iyl
 102+ E5C8 FD 6F       >                    ld iyl,a
 102+ E5CA 9F          >                    sbc a,a
 102+ E5CB FD 94       >                    sub iyh
 102+ E5CD FD 67       >                    ld iyh,a
 103+ E5CF C3 DD E5     	jp		l2S_SkipCalcInc					; so we have a negative frac
 104+ E5D2              l2S_fracIsPositive:
 105+ E5D2              	ShiftIYRight1
 105+ E5D2 FD 7C       >			   ld 	a,iyh
 105+ E5D4 CB 3F       >			   srl 	a
 105+ E5D6 FD 67       >			   ld	iyh,a
 105+ E5D8 FD 7D       >			   ld 	a,iyl
 105+ E5DA 1F          >			   rra
 105+ E5DB FD 6F       >			   ld	iyl,a
 106+ E5DD              l2S_SkipCalcInc:
 107+ E5DD              l2S_Loop:									; As we loop, bc = to plot current XY
 108+ E5DD 2A 52 E3     	ld		hl,(l2targetPtr)				; Insert into respective array
 109+ E5E0 78           	ld		a,b
 110+ E5E1 ED 31        	add		hl,a
 111+ E5E3 71           	ld		(hl),c
 112+ E5E4              l2S_CheckIfEnd:
 113+ E5E4 DD 7C        	ld		a,ixh
 114+ E5E6              	JumpIfAGTENusng	  b,l2S_CheckXPos		; if Y1 < Y2 then continue regardless, when it hits Y2 then we must check X1 and X2
 114+ E5E6 B8          >                        cp     b
 114+ E5E7 D2 ED E5    >                        jp		nc,l2S_CheckXPos
 115+ E5EA C3 F1 E5     	jp		l2S_Continue
 116+ E5ED              l2S_CheckXPos:
 117+ E5ED 79           	ld		a,c
 118+ E5EE              	ReturnIfAGTENusng ixl					; if X1 has reached or exceeded X2 then we are done
 118+ E5EE DD BD       >                        cp    ixl
 118+ E5F0 D0          >                        ret	 nc
 119+ E5F1              l2S_Continue:
 120+ E5F1              l2S_HNegative:
 121+ E5F1 FD 7C        	ld		a,iyh
 122+ E5F3 CB 7F        	bit		7,a								; if its negative then we need to deal with delta Y, there is no bit n,iyh instrunction
 123+ E5F5 28 0B        	jr		z,l2S_ErrNotNegative			;
 124+ E5F7              l2S_ErrNegative:								; if its a negative error update X
 125+ E5F7 3A 42 E3     	ld		a,(l2deltaY)
 126+ E5FA 16 00        	ld		d,0
 127+ E5FC 5F           	ld		e,a
 128+ E5FD FD 19        	add		iy,de							; add deltaY(unsinged) to l2fraction
 129+ E5FF              l2S_adjustCol:
 130+ E5FF 00           	nop										; this is our inc/dec of X
 131+ E600 18 DB        	jr		l2S_Loop							; repeat loop
 132+ E602              l2S_ErrNotNegative:
 133+ E602 FD 7C        	ld		a,iyh
 134+ E604 FD B5        	or		iyl
 135+ E606              	JumpIfAIsZero l2S_ErrZero					; if there is no error then goto zeroerror
 135+ E606 A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
 135+ E607 CA 20 E6    >                        jp	z, l2S_ErrZero
 136+ E60A              l2S_ErrPositive:								; if its a positive error then we update Y
 137+ E60A              	lddeiy
 137+ E60A FD 54       >                        ld		d,iyh
 137+ E60C FD 5D       >                        ld		e,iyl
 138+ E60E EB           	ex		de,hl
 139+ E60F 16 00        	ld		d,0
 140+ E611 3A 44 E3     	ld		a,(l2deltaX)
 141+ E614 5F           	ld		e,a
 142+ E615              	ClearCarryFlag
 142+ E615 B7          >                        or a
 143+ E616 ED 52        	sbc		hl,de
 144+ E618 EB           	ex		de,hl
 145+ E619              	ldiyde
 145+ E619 FD 62       >                        ld		iyh,d
 145+ E61B FD 6B       >                        ld		iyl,e
 146+ E61D              l2S_adjustRow:									; move Y down by one
 147+ E61D 04           	inc		b
 148+ E61E 18 BD        	jr		l2S_Loop
 149+ E620              l2S_ErrZero:
 150+ E620 2A 44 E3     	ld		hl,(l2deltaX)
 151+ E623 EB           	ex		de,hl
 152+ E624 2A 42 E3     	ld		hl,(l2deltaY)
 153+ E627              	ClearCarryFlag
 153+ E627 B7          >                        or a
 154+ E628 ED 52        	sbc		hl,de
 155+ E62A EB           	ex		de,hl
 156+ E62B              	ldiyde
 156+ E62B FD 62       >                        ld		iyh,d
 156+ E62D FD 6B       >                        ld		iyl,e
 157+ E62F              l2S_adjustCol2:
 158+ E62F 00           	nop										; update X and Y
 159+ E630 04           	inc		b
 160+ E631 18 AA        	jr		l2S_Loop
 161+ E633
 162+ E633              ; ">l2_draw_diagonal, bc = y0,x0 de=y1,x1,a=color) Thsi version performs a pre sort based on y axis"
 163+ E633 32 4C E3     l2_draw_diagonal:       ld		(l2linecolor),a					;save colour for later
 164+ E636 21 00 00                             ld		hl,0                            ;
 165+ E639 22 44 E3                             ld		(l2deltaX),hl                   ;
 166+ E63C 22 42 E3                             ld		(l2deltaY),hl                   ; initlaise deltas as we will only be loading 8 bit in there but workign in 16 bit later
 167+ E63F 78           l2D_preSort:            ld		a,b								;
 168+ E640                                      JumpIfALTNusng	d,l2D_noYSort			; we must have Y1 < Y2 (if equal then verical line picked up earlier
 168+ E640 BA          >                        cp      d
 168+ E641 DA 49 E6    >                        jp		c, l2D_noYSort
 169+ E644              l2D_SortBasedOnY:	    ldhlbc									;
 169+ E644 60          >                        ld		h,b
 169+ E645 69          >                        ld		l,c
 170+ E646 EB                                   ex		de,hl                           ;
 171+ E647                                      ldbchl									; swap over bc and de using hl as an intermediate
 171+ E647 44          >                        ld		b,h
 171+ E648 4D          >                        ld		c,l
 172+ E649 DD 62        l2D_noYSort:		    ld		ixh,d							; ixh now holds target Y coord post sorting
 173+ E64B DD 6B                                ld		ixl,e							; ixl now holds target X coord post sorting
 174+ E64D 79           l2D_setXLen:            ld		a,c                             ;
 175+ E64E                                      JumpIfALTNusng e,l2D_PosXLen			; if x1 < x2 then we have a positive increment
 175+ E64E BB          >                        cp      e
 175+ E64F DA 5B E6    >                        jp		c, l2D_PosXLen
 176+ E652 79           l2D_NegXLen:            ld		a,c                             ;
 177+ E653 93                                   sub     e                               ;
 178+ E654 32 44 E3                             ld		(l2deltaX),a					; As x1 > x2 we do deltaX = X1 - X2
 179+ E657 3E 0D                                ld		a,l2deccstep					; and set the value for inc dec self modifying to Dec
 180+ E659 18 07                                jr		l2D_XINCDEC
 181+ E65B 7B           l2D_PosXLen:	        ld		a,e                             ;
 182+ E65C 91                                   sub		c                               ;
 183+ E65D 32 44 E3                             ld 		(l2deltaX),a                    ; As x1 < x2 we do deltaX = X2 - X1
 184+ E660 3E 0C                                ld		a,l2inccstep                    ; and set the value for inc dec self modifying to Inc
 185+ E662 32 D1 E6     l2D_XINCDEC:	        ld		(l2D_adjustCol),a				;
 186+ E665 32 01 E7                             ld		(l2D_adjustCol2),a				; update self modifying code for X update with inc or dec from above
 187+ E668 7A           l2D_setYLen				ld		a,d							 	; presorted on Y so it is now always positive
 188+ E669 90                                   sub		b
 189+ E66A 32 42 E3                             ld 		(l2deltaY),a					; DeltaY = Y2 - Y1
 190+ E66D              l2D_setErr:									;  LD H  := (D'-E')/2    round up if +ve or down if -ve
 191+ E66D 2A 42 E3     ldD_FracDYltDX:			ld		hl,(l2deltaY)					; Fraction = dY - dX
 192+ E670 ED 5B 44 E3                          ld		de,(l2deltaX)
 193+ E674                                      ClearCarryFlag
 193+ E674 B7          >                        or a
 194+ E675 ED 52                                sbc		hl,de							; sbc does not have an SBC IY so need to do this in HL
 195+ E677 EB                                   ex		de,hl
 196+ E678 FD 62                                ld		iyh,d							; we will use IY reg for fractions
 197+ E67A FD 6B                                ld		iyl,e
 198+ E67C F2 A1 E6                             jp		p,l2D_fracIsPositive
 199+ E67F              l2D_fracIsNegative:     NegIY
 199+ E67F AF          >                    xor a
 199+ E680 FD 95       >                    sub iyl
 199+ E682 FD 6F       >                    ld iyl,a
 199+ E684 9F          >                    sbc a,a
 199+ E685 FD 94       >                    sub iyh
 199+ E687 FD 67       >                    ld iyh,a
 200+ E689                                      ShiftIYRight1
 200+ E689 FD 7C       >			   ld 	a,iyh
 200+ E68B CB 3F       >			   srl 	a
 200+ E68D FD 67       >			   ld	iyh,a
 200+ E68F FD 7D       >			   ld 	a,iyl
 200+ E691 1F          >			   rra
 200+ E692 FD 6F       >			   ld	iyl,a
 201+ E694                                      NegIY
 201+ E694 AF          >                    xor a
 201+ E695 FD 95       >                    sub iyl
 201+ E697 FD 6F       >                    ld iyl,a
 201+ E699 9F          >                    sbc a,a
 201+ E69A FD 94       >                    sub iyh
 201+ E69C FD 67       >                    ld iyh,a
 202+ E69E C3 AC E6                             jp		l2D_SkipCalcInc					; so we have a negative frac
 203+ E6A1              l2D_fracIsPositive:     ShiftIYRight1
 203+ E6A1 FD 7C       >			   ld 	a,iyh
 203+ E6A3 CB 3F       >			   srl 	a
 203+ E6A5 FD 67       >			   ld	iyh,a
 203+ E6A7 FD 7D       >			   ld 	a,iyl
 203+ E6A9 1F          >			   rra
 203+ E6AA FD 6F       >			   ld	iyl,a
 204+ E6AC              l2D_SkipCalcInc:
 205+ E6AC C5 D5        l2D_Loop:				push	bc,,de                 			; l2DeltaY and l2DeltaX are set
 206+ E6AE 3A 4C E3                             ld		a,(l2linecolor)     			;
 207+ E6B1 CD 29 E1                             call	l2_plot_pixel       			; Plot Pixel
 208+ E6B4 D1 C1                                pop     bc,,de
 209+ E6B6 DD 7C        l2D_CheckIfEnd:	        ld		a,ixh
 210+ E6B8                                      JumpIfAGTENusng	  b,l2D_CheckXPos		; if Y1 < Y2 then continue regardless, when it hits Y2 then we must check X1 and X2
 210+ E6B8 B8          >                        cp     b
 210+ E6B9 D2 BF E6    >                        jp		nc,l2D_CheckXPos
 211+ E6BC C3 C3 E6                             jp		l2D_Continue
 212+ E6BF 79           l2D_CheckXPos:          ld		a,c
 213+ E6C0                                      ReturnIfAEqNusng ixl					; if X1 has reached or exceeded X2 then we are done
 213+ E6C0 DD BD       >                        cp      ixl
 213+ E6C2 C8          >                        ret     z
 214+ E6C3              l2D_Continue:
 215+ E6C3 FD 7C        l2D_HNegative:			ld		a,iyh
 216+ E6C5 CB 7F                                bit		7,a								; if its negative then we need to deal with delta Y, there is no bit n,iyh instrunction
 217+ E6C7 28 0B                                jr		z,l2D_ErrNotNegative			;
 218+ E6C9 3A 42 E3     l2D_ErrNegative:		ld		a,(l2deltaY)
 219+ E6CC 16 00                                ld		d,0
 220+ E6CE 5F                                   ld		e,a
 221+ E6CF FD 19                                add		iy,de							; add deltaY(unsinged) to l2fraction
 222+ E6D1 00           l2D_adjustCol:          nop										; this is our inc/dec of X
 223+ E6D2 18 D8                                jr		l2D_Loop							; repeat loop
 224+ E6D4 FD 7C        l2D_ErrNotNegative:     ld		a,iyh
 225+ E6D6 FD B5                                or		iyl
 226+ E6D8                                      JumpIfAIsZero l2D_ErrZero					; if there is no error then goto zeroerror
 226+ E6D8 A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
 226+ E6D9 CA F2 E6    >                        jp	z, l2D_ErrZero
 227+ E6DC              l2D_ErrPositive:		lddeiy
 227+ E6DC FD 54       >                        ld		d,iyh
 227+ E6DE FD 5D       >                        ld		e,iyl
 228+ E6E0 EB                                   ex		de,hl
 229+ E6E1 16 00                                ld		d,0
 230+ E6E3 3A 44 E3                             ld		a,(l2deltaX)
 231+ E6E6 5F                                   ld		e,a
 232+ E6E7                                      ClearCarryFlag
 232+ E6E7 B7          >                        or a
 233+ E6E8 ED 52                                sbc		hl,de
 234+ E6EA EB                                   ex		de,hl
 235+ E6EB                                      ldiyde
 235+ E6EB FD 62       >                        ld		iyh,d
 235+ E6ED FD 6B       >                        ld		iyl,e
 236+ E6EF 04           l2D_adjustRow:			inc		b
 237+ E6F0 18 BA                                jr		l2D_Loop
 238+ E6F2 2A 44 E3     l2D_ErrZero:            ld		hl,(l2deltaX)
 239+ E6F5 EB                                   ex		de,hl
 240+ E6F6 2A 42 E3                             ld		hl,(l2deltaY)
 241+ E6F9                                      ClearCarryFlag
 241+ E6F9 B7          >                        or a
 242+ E6FA ED 52                                sbc		hl,de
 243+ E6FC EB                                   ex		de,hl
 244+ E6FD                                      ldiyde
 244+ E6FD FD 62       >                        ld		iyh,d
 244+ E6FF FD 6B       >                        ld		iyl,e
 245+ E701 00           l2D_adjustCol2:         nop										; update X and Y
 246+ E702 04                                   inc		b
 247+ E703 18 A7                                jr		l2D_Loop
 248+ E705              ;----------------------------------------------------------------------------------------------------------------------------------
 249+ E705
 250+ E705
 251+ E705
 252+ E705
 253+ E705              ;Loin:				; BBC version of line draw
 254+ E705              ;; ">l2_draw_diagonal, bc = y0,x0 de=y1,x1,a=color)"
 255+ E705              ;	ld		(l2linecolor),a					; save colour as a reg gets used alot, coudl move this into interrupt flag and disable interrups
 256+ E705              ;	ld		ixh,0							; ixh = s
 257+ E705              ;	ld		iyh,0							; iyh = swap
 258+ E705              ;	ld		l,0								; l will hold delta sign flags
 259+ E705              ;LoinCalcDeltaX:
 260+ E705              ;	ld		a,e
 261+ E705              ;	sub		c								; a = deltaX
 262+ E705              ;	JumpIfPositive LoinPosDx
 263+ E705              ;LoinNegDx:
 264+ E705              ;	neg										; carry flag will indicate deltaX was negative
 265+ E705              ;	ld		l,$80							; set bit 7 of l for negative
 266+ E705              ;LoinPosDx:
 267+ E705              ;	ld		ixl,a							; ixl = varP = deltaX
 268+ E705              ;LoinCalcDeltaY:
 269+ E705              ;	ld		a,d
 270+ E705              ;	sub		b								; a= deltaY
 271+ E705              ;	JumpIfPositive LoinPosDy
 272+ E705              ;LoinNegDy:
 273+ E705              ;	neg
 274+ E705              ;	set		6,l								; set bit 6 of l for negative deltaY
 275+ E705              ;LoinPosDy:
 276+ E705              ;	ld		iyl,a							; iyl = varQ = deltaY
 277+ E705              ;	JumpIfAGTENusng ixl, LoinSTPy			; if deltaY >= DeltaX then step along Y
 278+ E705              ;LoinSTPx:									; step along X
 279+ E705              ;	JumpOnBitClear l,7						; if l flags were clear then X2 < X2
 280+ E705              ;LoinSTPxSwapCoords:
 281+ E705              ;	dec		iyh								; swap flag now becomes FF
 282+ E705              ;	ld		a,l								; save l flags
 283+ E705              ;	ex		de,hl							; save de to hl
 284+ E705              ;	lddebc									; Point2 = point1
 285+ E705              ;	ldbchl									; Point1 = point2 that was saved
 286+ E705              ;	ld		l,a								; get back l flags
 287+ E705              ;LoinSTPxCorrectOrder:
 288+ E705              ;	l2_point_pixel_y_safe					; call plot pixel preseving bc hl
 289+ E705              ;	ld		a,iyl							; get delta Y back
 290+ E705              ;	ld		iy1,$FE							; roll counter
 291+ E705              ;LionSTPxRollQ:
 292+ E705              ;	sla		a								; highest bit of delta-Y
 293+ E705              ;	jp		c,LoinSTPxSteep
 294+ E705              ;	cp		ixl								; compare with DeltaX
 295+ E705              ;	jp		cs,LoinSTPxShallow
 296+ E705              ;LoinSTPxSteep:								;; LI4
 297+ E705              ;	sbc		a,ixl							; deltaYwork -= (deltaX+1)
 298+ E705              ;	scf										; force carry flag set
 299+ E705              ;LoinSTPxShallow:							;; LI5
 300+ E705              ;	rl		iyl								; rotate iyl which started as FE
 301+ E705              ;	jp		c,LionSTPxRollQ					; so we are doing a 6 bit loop
 302+ E705              ;	inc		ihl								; DeltaX += 1
 303+ E705              ;LoinSTPxYDirection:							; change this to self modifying code
 304+ E705              ;	ld		a,d
 305+ E705              ;	JumpIfAGTEn	b,LionDOWN:
 306+ E705              ;	ld		a,iyh							; swap flag
 307+ E705              ;	JumpIfANotZero	X1Inc  					; if swap flag was not set then no need to update R
 308+ E705              ;LoinSTPxX1Dec:
 309+ E705              ;	dec		c								; move left 1 pixel as we sawped
 310+ E705              ;LoinSTPxXCounter:							;; LIL2
 311+ E705              ;	sub		b
 312+ E705              ;	if
 313+ E705              ;
 314+ E705              ;85 82                   STA &82	   \ R	\ mask byte
 315+ E705              ;A5 81                   LDA &81	   \ Q	\ delta-Y
 316+ E705              ;A2 FE                   LDX #&FE	\ roll counter
 317+ E705              ;86 81                   STX &81		\ Q
 318+ E705              ;.LIL1	\ roll Q
 319+ E705              ;0A                      ASL A		\ highest bit of delta-Y
 320+ E705              ;B0 04                   BCS LI4		\ steep
 321+ E705              ;C5 1B                   CMP &1B	   \ P	\ delta-X
 322+ E705              ;90 03                   BCC LI5		\ shallow
 323+ E705              ;.LI4	\ steep
 324+ E705              ;E5 1B                   SBC &1B		\ P
 325+ E705              ;38                      SEC
 326+ E705              ;.LI5	\ shallow
 327+ E705              ;26 81                   ROL &81	   \ Q	\ #&FE
 328+ E705              ;B0 F2                   BCS LIL1 	\ loop Q, end with some low bits in Q
 329+ E705              ;A6 1B                   LDX &1B		\ P
 330+ E705              ;E8                      INX 		\ Xreg is width
 331+ E705              ;A5 37                   LDA &37		\ Y2
 332+ E705              ;E5 35                   SBC &35		\ Y1
 333+ E705              ;B0 2C                   BCS DOWN	\ draw line to the right and down
 334+ E705              ;A5 90                   LDA &90		\ SWAP
 335+ E705              ;D0 07                   BNE LI6		\ else Xreg was correct after all, no need to update R
 336+ E705              ;CA                      DEX
 337+ E705              ;.LIL2	\ counter X width
 338+ E705              ;A5 82                   LDA &82	   \ R	\ mask byte
 339+ E705              ;51 07                   EOR (&07),Y	\ (SC),Y
 340+ E705              ;91 07                   STA (&07),Y	\ (SC),Y
 341+ E705              ;.LI6	\ Xreg correct
 342+ E705              ;46 82                   LSR &82	   \ R	\ mask byte
 343+ E705              ;90 08                   BCC LI7   	\ else moving to next column to right. Bring carry in back
 344+ E705              ;66 82                   ROR &82		\ R
 345+ E705              ;A5 07                   LDA &07		\ SC
 346+ E705              ;69 08                   ADC #8		\ next column
 347+ E705              ;85 07                   STA &07		\ SC
 348+ E705              ;.LI7	\ S += Q. this is like an overflow monitor to update Y
 349+ E705              ;A5 83                   LDA &83		\ S
 350+ E705              ;65 81                   ADC &81	   \ Q	\ some low bits
 351+ E705              ;85 83                   STA &83		\ S
 352+ E705              ;90 07                   BCC LIC2	\ skip Y adjustment
 353+ E705              ;88                      DEY
 354+ E705              ;10 04                   BPL LIC2	\ skip Y adjustment
 355+ E705              ;C6 08                   DEC &08		\ SC+1
 356+ E705              ;A0 07                   LDY #7
 357+ E705              ;.LIC2	\ skip Y adjustment
 358+ E705              ;CA                      DEX
 359+ E705              ;D0 DC                   BNE LIL2	\ loop X width
 360+ E705              ;A4 85                   LDY &85	 \ YSAV \ restore Yreg
 361+ E705              ;60                      RTS
 362+ E705              ;
 363+ E705              ;.DOWN	\ Line is going to the right and down
 364+ E705              ;A5 90                   LDA &90		\ SWAP
 365+ E705              ;F0 07                   BEQ LI9		\ no swap
 366+ E705              ;CA                      DEX
 367+ E705              ;.LIL3	\ counter X width
 368+ E705              ;A5 82                   LDA &82	    \ R \ mask byte
 369+ E705              ;51 07                   EOR (&07),Y	\ (SC),Y
 370+ E705              ;91 07                   STA (&07),Y	\ (SC),Y
 371+ E705              ;.LI9	\ no swap
 372+ E705              ;46 82                   LSR &82		\ R
 373+ E705              ;90 08                   BCC LI10	\ still in correct column, hop
 374+ E705              ;66 82                   ROR &82		\ R
 375+ E705              ;A5 07                   LDA &07		\ SC
 376+ E705              ;69 08                   ADC #8		\ next column
 377+ E705              ;85 07                   STA &07		\ SC
 378+ E705              ;.LI10	\ this is like an overflow monitor to update Y
 379+ E705              ;A5 83                   LDA &83		\ S
 380+ E705              ;65 81                   ADC &81		\ Q
 381+ E705              ;85 83                   STA &83		\ S
 382+ E705              ;90 09                   BCC LIC3	\ skip Y adjustment
 383+ E705              ;C8                      INY
 384+ E705              ;C0 08                   CPY #8
 385+ E705              ;D0 04                   BNE LIC3	\ have not reached bottom byte of char, hop
 386+ E705              ;E6 08                   INC &08		\ SC+1
 387+ E705              ;A0 00                   LDY #0
 388+ E705              ;.LIC3	\ skipped Y adjustment
 389+ E705              ;CA                      DEX
 390+ E705              ;D0 DA                   BNE LIL3	\ loop X width
 391+ E705              ;A4 85                   LDY &85	 \ YSAV \ restore Yreg
 392+ E705              ;60                      RTS
 393+ E705              ;
 394+ E705              ;.STPY	\ -> &1797 \ Step along y for line, goes down and to right
 395+ E705              ;A4 35                   LDY &35		\ Y1
 396+ E705              ;98                      TYA
 397+ E705              ;A6 34                   LDX &34		\ X1
 398+ E705              ;C4 37                   CPY &37		\ Y2
 399+ E705              ;B0 10                   BCS LI15	\ skip swap if Y1 >= Y2
 400+ E705              ;C6 90                   DEC &90		\ SWAP
 401+ E705              ;A5 36                   LDA &36		\ X2
 402+ E705              ;85 34                   STA &34		\ X1
 403+ E705              ;86 36                   STX &36		\ X2
 404+ E705              ;AA                      TAX
 405+ E705              ;A5 37                   LDA &37		\ Y2
 406+ E705              ;85 35                   STA &35		\ Y1
 407+ E705              ;84 37                   STY &37		\ Y2
 408+ E705              ;A8                      TAY
 409+ E705              ;.LI15	\ Y1 Y2 order is now correct
 410+ E705              ;4A                      LSR A
 411+ E705              ;4A                      LSR A
 412+ E705              ;4A                      LSR A
 413+ E705              ;09 60                   ORA #&60
 414+ E705              ;85 08                   STA &08	 \ SC+1	\ screen hi
 415+ E705              ;8A                      TXA 		\ X1
 416+ E705              ;29 F8                   AND #&F8
 417+ E705              ;85 07                   STA &07	  \ SC	\ screen lo
 418+ E705              ;8A                      TXA
 419+ E705              ;29 07                   AND #7		\ mask index
 420+ E705              ;AA                      TAX
 421+ E705              ;BD AF 16                LDA &16AF,X \ TWOS,X \ Mode4 single pixel
 422+ E705              ;85 82                   STA &82	    \ R	\ mask
 423+ E705              ;A5 35                   LDA &35		\ Y1
 424+ E705              ;29 07                   AND #7
 425+ E705              ;A8                      TAY
 426+ E705              ;A5 1B                   LDA &1B	    \ P	\ delta-X
 427+ E705              ;A2 01                   LDX #1		\ roll counter
 428+ E705              ;86 1B                   STX &1B	    	\ P
 429+ E705              ;.LIL4	\ roll P
 430+ E705              ;0A                      ASL A
 431+ E705              ;B0 04                   BCS LI13	\ do subtraction
 432+ E705              ;C5 81                   CMP &81	    \ Q	\ delta-Y
 433+ E705              ;90 03                   BCC LI14	\ less than Q
 434+ E705              ;.LI13	\ do subtraction
 435+ E705              ;E5 81                   SBC &81		\ Q
 436+ E705              ;38                      SEC
 437+ E705              ;.LI14	\ less than Q
 438+ E705              ;26 1B                   ROL &1B		\ P
 439+ E705              ;90 F2                   BCC LIL4	\ loop P, end with some low bits in P
 440+ E705              ;A6 81                   LDX &81		\ Q
 441+ E705              ;E8                      INX 		\ adjust height
 442+ E705              ;A5 36                   LDA &36		\ X2
 443+ E705              ;E5 34                   SBC &34		\ X1
 444+ E705              ;90 2D                   BCC LFT		\ if C cleared then line moving to the left - hop down
 445+ E705              ;18                      CLC
 446+ E705              ;A5 90                   LDA &90		\ SWAP
 447+ E705              ;F0 07                   BEQ LI17 	\ skip first point
 448+ E705              ;CA                      DEX
 449+ E705              ;.LIL5	\ skipped first point, counter X
 450+ E705              ;A5 82                   LDA &82	    \ R \ mask byte
 451+ E705              ;51 07                   EOR (&07),Y	\ (SC),Y
 452+ E705              ;91 07                   STA (&07),Y	\ (SC),Y
 453+ E705              ;.LI17	\ skipped first point
 454+ E705              ;88                      DEY
 455+ E705              ;10 04                   BPL LI16	\ skip hi adjust
 456+ E705              ;C6 08                   DEC &08		\ SC+1
 457+ E705              ;A0 07                   LDY #7		\ new char
 458+ E705              ;	.LI16	\ skipped hi adjust
 459+ E705              ;A5 83                   LDA &83		\ S
 460+ E705              ;65 1B                   ADC &1B		\ P
 461+ E705              ;85 83                   STA &83		\ S
 462+ E705              ;90 0C                   BCC LIC5	\ skip, still in same column
 463+ E705              ;46 82                   LSR &82	  \ R	\ mask
 464+ E705              ;90 08                   BCC LIC5  	\ no mask bit hop
 465+ E705              ;66 82                   ROR &82   \ R	\ else moved over to next column, reset mask
 466+ E705              ;A5 07                   LDA &07	  \ SC  \ screen lo
 467+ E705              ;69 08                   ADC #8		\ next char below
 468+ E705              ;85 07                   STA &07		\ SC
 469+ E705              ;.LIC5	\ same column
 470+ E705              ;CA                      DEX
 471+ E705              ;D0 DC                   BNE LIL5	\ loop X height
 472+ E705              ;A4 85                   LDY &85	 \ YSAV	\ restore Yreg
 473+ E705              ;60                      RTS
 474+ E705              ;
 475+ E705              ;.LFT	\ going left
 476+ E705              ;A5 90                   LDA &90		\ SWAP
 477+ E705              ;F0 07                   BEQ LI18	\ skip first point
 478+ E705              ;CA                      DEX 		\ reduce height
 479+ E705              ;.LIL6	\ counter X height
 480+ E705              ;A5 82                   LDA &82	   \ R	\ mask byte
 481+ E705              ;51 07                   EOR (&07),Y	\ (SC),Y
 482+ E705              ;91 07                   STA (&07),Y	\ (SC),Y
 483+ E705              ;.LI18
 484+ E705              ;88                      DEY
 485+ E705              ;10 04                   BPL LI19	\ skip hi adjust
 486+ E705              ;C6 08                   DEC &08		\ SC+1
 487+ E705              ;A0 07                   LDY #7		\ rest char row
 488+ E705              ;.LI19	\ skipped hi adjust
 489+ E705              ;A5 83                   LDA &83		\ S
 490+ E705              ;65 1B                   ADC &1B	    \ P \ some low bits
 491+ E705              ;85 83                   STA &83		\ S
 492+ E705              ;90 0D                   BCC LIC6	\ no overflow
 493+ E705              ;06 82                   ASL &82	    \ R \ else move byte mask to the left
 494+ E705              ;90 09                   BCC LIC6	\ no overflow
 495+ E705              ;26 82                   ROL &82		\ R
 496+ E705              ;A5 07                   LDA &07		\ SC
 497+ E705              ;E9 07                   SBC #7		\ down 1 char
 498+ E705              ;85 07                   STA &07		\ SC
 499+ E705              ;18                      CLC
 500+ E705              ;.LIC6	\ no overflow
 501+ E705              ;CA                      DEX 		\ height
 502+ E705              ;D0 DB                   BNE LIL6	\ loop X
 503+ E705              ;A4 85                   LDY &85	 \ YSAV	\ restore Yreg
 504+ E705              ;.HL6
 505+ E705              ;60                      RTS 		\ end Line drawing
 506+ E705
 507+ E705
 508+ E705              ;;l2_draw_diagonalopt:
 509+ E705              	; ">TODO l2_draw_diagonalopt fast horz vert optmisation"
 510+ E705              ;;	push	af
 511+ E705              ;;	ld		a,b
 512+ E705              ;;	cp		d
 513+ E705              ;;	jr		z,.RegularDiagnonal
 514+ E705              ;;.CheckHorz:
 515+ E705              ;;	ld		a,c
 516+ E705              ;;	cp		e
 517+ E705              ;;	jr		z,.horizontalLine
 518+ E705              ;;.RegularDiagnonal:
 519+ E705              ;;	pop		af
 520+ E705              ;;	call diag
 521+ E705
 522+ E705
 523+ E705              ;;l2_signed_mul2a:
 524+ E705              ;;; ">l2_signed_mul2a - Signed a = a * 2 using shift)"
 525+ E705              ;;	TEST	$80
 526+ E705              ;;	jr		nz, .negativecalc
 527+ E705              ;;.positivecalc:
 528+ E705              ;;	ccf
 529+ E705              ;;	rla
 530+ E705              ;;	ret
 531+ E705              ;;.negativecalc:
 532+ E705              ;;	neg
 533+ E705              ;;	ccf
 534+ E705              ;;	rla
 535+ E705              ;;	neg
 536+ E705              ;;	ret
 537+ E705              ;;
 538+ E705              ;;l2_signed_mul2atohl:
 539+ E705              ;;; ">l2_signed_mul2ahl - Signed hl = a * 2 using shift)"
 540+ E705              ;;	TEST	$80
 541+ E705              ;;	jr		nz, .negativecalc
 542+ E705              ;;.positivecalc:
 543+ E705              ;;	ld		hl,0
 544+ E705              ;;	ld		l,a
 545+ E705              ;;	add		hl,a
 546+ E705              ;;	ret
 547+ E705              ;;.negativecalc:
 548+ E705              ;;	neg
 549+ E705              ;;	ld		hl,0
 550+ E705              ;;	ld		l,a
 551+ E705              ;;	neghl
 552+ E705              ;;	ret
 553+ E705              ;;
 554+ E705              ;;l2_e2fractionby2:
 555+ E705              ;;	ld 		hl,(l2fraction)
 556+ E705              ;;	push	de
 557+ E705              ;;	ld		d,h
 558+ E705              ;;	ld		e,l
 559+ E705              ;;	add		hl,de
 560+ E705              ;;	pop		de
 561+ E705              ;;	ld		(l2e2),hl
 562+ E705              ;;	ret
 563+ E705
 564+ E705
 565+ E705
 566+ E705
 567+ E705
 568+ E705              ;;//	ld		(l2linecolor),a   			; could do an ex but it will be needed multiple times between many uses of a reg
 569+ E705              ;;//.catchLoop:
 570+ E705              ;;//	jp .catchLoop
 571+ E705              ;;//.continue:
 572+ E705              ;;//    ld      A,D
 573+ E705              ;;//    sub     H
 574+ E705              ;;//    jr      NC,.DXpositive    ;delta_x > 0
 575+ E705              ;;//.DXNegative:
 576+ E705              ;;//    neg
 577+ E705              ;;//.DXPositive:
 578+ E705              ;;//    ld      B,A              ;B <- |delta_x|
 579+ E705              ;;//    ld      A,E
 580+ E705              ;;//    sub     L
 581+ E705              ;;//    jr      NC,.DYpositive    ;delta_y > 0
 582+ E705              ;;//.DYNegative:
 583+ E705              ;;//    neg
 584+ E705              ;;//.DYPositive:
 585+ E705              ;;//    sub     B               ;|delta_y|
 586+ E705              ;;//	push	af
 587+ E705              ;;//	jr		c,.DeltaX
 588+ E705              ;;//.DeltaY
 589+ E705              ;;//	ld      A,H             			;if |delta_x| < |delta_y| then
 590+ E705              ;;//    ld      H,L             			;then values x and y are swapped
 591+ E705              ;;//    ld      L,A             			;so the loop will always be performed on the
 592+ E705              ;;//    ld      A,D             			;x value. A flag must be set to
 593+ E705              ;;//    ld      D,E             			;remind that data must be drawn (y,x)
 594+ E705              ;;//    ld      E,A             			;instead of (x,y)
 595+ E705              ;;//.DeltaX:
 596+ E705              ;;//	ld		a,d
 597+ E705              ;;//	sub		h
 598+ E705              ;;//	jr		nc,.TestDY					; x1 < x2
 599+ E705              ;;//.TestDX:
 600+ E705              ;;//	ex		de,hl
 601+ E705              ;;//.TestDY:
 602+ E705              ;;//	ld		a,e
 603+ E705              ;;//	sub		l
 604+ E705              ;;//    ld      A,$01
 605+ E705              ;;//    jr      NC,.StoreA
 606+ E705              ;;//    neg                     ;y1 > y2 : in case2 the 'y' variable
 607+ E705              ;;//.StoreA:
 608+ E705              ;;//        ld      (l2way),A
 609+ E705              ;;//.InitLine:
 610+ E705              ;;//        ld      B,H
 611+ E705              ;;//        ld      C,L
 612+ E705              ;;//        ld      A,E
 613+ E705              ;;//        sub     L
 614+ E705              ;;//        jr      NC,.EndInit
 615+ E705              ;;//        ld      A,L
 616+ E705              ;;//        ld      L,E
 617+ E705              ;;//        ld      E,A
 618+ E705              ;;//.EndInit:
 619+ E705              ;;//        ld      A,E
 620+ E705              ;;//        sub     L
 621+ E705              ;;//        rla
 622+ E705              ;;//        ld      L,A             ;value to add in case1 (d < 0)
 623+ E705              ;;//        add     A,H
 624+ E705              ;;//        sub     D
 625+ E705              ;;//        ld      E,A             ;'d' variable is initialised
 626+ E705              ;;//        add     A,H
 627+ E705              ;;//        sub     D
 628+ E705              ;;//        ld      H,A             ;value to add in case2 (d >= 0)
 629+ E705              ;;//.Loop:
 630+ E705              ;;//        ld      A,B
 631+ E705              ;;//        sub     D
 632+ E705              ;;//        jr      NC,.EndLine       ;the line is completely drawn.
 633+ E705              ;;//        pop     AF
 634+ E705              ;;//        bit     7,A
 635+ E705              ;;//        push    AF
 636+ E705              ;;//        push    AF
 637+ E705              ;;//        push    BC
 638+ E705              ;;//        jr      Z,.DrawPoint
 639+ E705              ;;//        ld      A,B
 640+ E705              ;;//        ld      B,C
 641+ E705              ;;//        ld      C,A
 642+ E705              ;;//.DrawPoint:
 643+ E705              ;;//		push	hl
 644+ E705              ;;//		pushbcdeaf
 645+ E705              ;;//		ld		b,e
 646+ E705              ;;//		ld		c,d
 647+ E705              ;;//	ld 		a,(l2linecolor)
 648+ E705              ;;//	call	l2_plot_pixel
 649+ E705              ;;//		popafdebc
 650+ E705              ;;//		pop		hl
 651+ E705              ;;//        pop     BC
 652+ E705              ;;//        pop     AF
 653+ E705              ;;//.TestD:
 654+ E705              ;;//        bit     7,E
 655+ E705              ;;//        jr      NZ,.Case1
 656+ E705              ;;//.Case2:                          ;d >= 0
 657+ E705              ;;//        ld      A,E
 658+ E705              ;;//        add     A,H
 659+ E705              ;;//        ld      E,A
 660+ E705              ;;//        ld      A,(l2way)
 661+ E705              ;;//        add     A,C
 662+ E705              ;;//        ld      C,A
 663+ E705              ;;//        jr      .EndLoop
 664+ E705              ;;//.Case1:                          ;d < 0
 665+ E705              ;;//        ld      A,E
 666+ E705              ;;//        add     A,L
 667+ E705              ;;//        ld      E,A
 668+ E705              ;;//.EndLoop:
 669+ E705              ;;//        inc     B
 670+ E705              ;;//        jr      .Loop
 671+ E705              ;;//.EndLine:
 672+ E705              ;;//        pop     AF              ;MUST NOT BE REMOVED
 673+ E705              ;;//        pop     HL              ;can be removed
 674+ E705              ;;//        pop     DE              ;can be removed
 675+ E705              ;;//        ret
 676+ E705
 677+ E705              ;;	ld		(.l2yadjust),a
 678+ E705              ;;	call	calcdeltax:
 679+ E705              ;;	ld		(.l2xadjust),a
 680+ E705              ;;.calcfraction:							; err(or fraction) = dx+dy;
 681+ E705              ;;	push	hl
 682+ E705              ;;	push	de
 683+ E705              ;;	ld		hl,(l2deltaX)
 684+ E705              ;;	ld		de,(l2deltaY)
 685+ E705              ;;	add		hl,de
 686+ E705              ;;	ld		(l2fraction),hl
 687+ E705              ;;	pop		de
 688+ E705              ;;	pop		hl
 689+ E705              ;;.mainloop:
 690+ E705              ;;	push	bc
 691+ E705              ;;	push	de
 692+ E705              ;;	ld 		a,(l2linecolor)
 693+ E705              ;;	call	l2_plot_pixel
 694+ E705              ;;	pop		de
 695+ E705              ;;	pop		bc
 696+ E705              ;;.arewefinishedtest
 697+ E705              ;;	ld		a,b
 698+ E705              ;;	cp		d
 699+ E705              ;;	jr		nz,.notthereyet
 700+ E705              ;;	ld		a,c
 701+ E705              ;;	cp		e
 702+ E705              ;;	ret		z
 703+ E705              ;;.notthereyet:
 704+ E705              ;;	push	de
 705+ E705              ;;	call	l2_e2fractionby2			; e2 = 2*err;
 706+ E705              ;;	pop		de
 707+ E705              ;;.e2dytest:								; if (e2 >= dy) /* e_xy+e_x > 0 */  then S and P/V are the same
 708+ E705              ;;	push	de							; so if m & pe  or p & po calc (m = sign set p = 0)
 709+ E705              ;;	ld		de,(l2deltaY)				;    if m & po  or p & pe skip  (pe = pv set po = pv 0)
 710+ E705              ;;	or		a							;
 711+ E705              ;;	sbc		hl,de						;
 712+ E705              ;;	pop		de
 713+ E705              ;;	jr		z,  .dodycalc				; if equal then calc
 714+ E705              ;;	jp		p,	.dodycalc				; sign clear to H>D even with negtives
 715+ E705              ;;	jr		.skipdycalc         		; sign = 0     so  skip as pe
 716+ E705              ;;.dodycalc:
 717+ E705              ;;	ld		hl,(l2fraction)
 718+ E705              ;;	push	de
 719+ E705              ;;	ld		de,(l2deltaY)
 720+ E705              ;;	add		hl,de
 721+ E705              ;;	ld		(l2fraction),de
 722+ E705              ;;	pop		de
 723+ E705              ;;.l2yadjust:
 724+ E705              ;;	nop
 725+ E705              ;;.skipdycalc:
 726+ E705              ;;.e2dxtest:								;  if (e2 <= dx) /* e_xy+e_y < 0 */ then S and P/V are different.
 727+ E705              ;;	ld		hl,(l2e2)
 728+ E705              ;;	push	de							;
 729+ E705              ;;	ld		de,(l2deltaX)				;
 730+ E705              ;;	or		a							; clear carry flag
 731+ E705              ;;	sbc		hl,de						; hl = hl - de is if de > hl will get pv and signed different?
 732+ E705              ;;	pop		de
 733+ E705              ;;	jr		z,.dodxcalc					; e2 == dx so do calc
 734+ E705              ;;	jp		m,.dodxcalc					; was sign bit set
 735+ E705              ;;	jr		.skipdxcalc         	    ; diff so skip ; pvclear = po        pvset = pe
 736+ E705              ;;.dodxcalc:
 737+ E705              ;;	ld		hl,(l2fraction)
 738+ E705              ;;	push	de
 739+ E705              ;;	ld		de,(l2deltaX)
 740+ E705              ;;	add		hl,de
 741+ E705              ;;	ld		(l2fraction),de
 742+ E705              ;;	pop		de
 743+ E705              ;;.l2xadjust:
 744+ E705              ;;	nop
 745+ E705              ;;.skipdxcalc:
 746+ E705              ;;	jr 		.mainloop
 747+ E705
 748+ E705
 749+ E705              ;;/l2_draw_diagonalold:
 750+ E705              ;;/MESSAGE ">l2_draw_diagonal, bc = y0,x0 de=y1,x1,a=color)"
 751+ E705              ;;/	ld		(l2linecolor),a   			; could do an ex but it will be needed multiple times between many uses of a reg
 752+ E705              ;;/.sortycoords:
 753+ E705              ;;/	ld		a,b							; Sort to Y0 is always > y1 so we don't have to deal with step y and only step x
 754+ E705              ;;/	cp		d
 755+ E705              ;;/	jr		nc, .nocoordswap
 756+ E705              ;;/.swapcoords:
 757+ E705              ;;/	ex		de,hl						; save de to hl ! effective code line 98 after macros
 758+ E705              ;;/	lddebc
 759+ E705              ;;/	ldbchl
 760+ E705              ;;/.nocoordswap:
 761+ E705              ;;/	ld		a,d							; l2_dy = -ABS(l2_vy1 - l2_vy0)
 762+ E705              ;;/	sub		b							; we have already sorted  so y1 > y0
 763+ E705              ;;/	ld		(l2deltaY),a
 764+ E705              ;;/	neg									; DEBUG
 765+ E705              ;;/	ld		(l2deltaYn),a				; DEBUG
 766+ E705              ;;/	neg									; DEBUG
 767+ E705              ;;/.deltaxequABSx0Minusx1:						; we need to set l2dx to abs x1-x0 and set
 768+ E705              ;;/    ld		a,c
 769+ E705              ;;/	cp		e
 770+ E705              ;;/	jr		c, .x1GTx0
 771+ E705              ;;/.x1LTx0
 772+ E705              ;;/	ld		a,c
 773+ E705              ;;/	sub		e
 774+ E705              ;;/	ld		(l2deltaX),a				; just 8 bit for now should it be 16?
 775+ E705              ;;/	neg									; DEBUG
 776+ E705              ;;/	ld		(l2deltaXn),a				; DEBUG
 777+ E705              ;;/	neg									; DEBUG
 778+ E705              ;;/	ld		a,l2incbstep
 779+ E705              ;;/	jr		.setlayershift0
 780+ E705              ;;/.x1GTx0:
 781+ E705              ;;/	ld		a,e
 782+ E705              ;;/	sub		c
 783+ E705              ;;/	ld		(l2deltaX),a					; just 8 bit for now should it be 16?
 784+ E705              ;;/	neg									; DEBUG
 785+ E705              ;;/	ld		(l2deltaXn),a				; DEBUG
 786+ E705              ;;/	neg									; DEBUG
 787+ E705              ;;/	ld		a,l2decbstep
 788+ E705              ;;/.setlayershift0:
 789+ E705              ;;/	ld		a,0
 790+ E705              ;;/	pushbcde
 791+ E705              ;;/	call	asm_l2_bank_n_select		; l2_layer_shift = 0 and bank 0 selected
 792+ E705              ;;/	popdebc
 793+ E705              ;;/; so now we have set inc or dec instruction, l2dy, l2dx and on bank 0,
 794+ E705              ;;/.dymuliplyby2:
 795+ E705              ;;/	ld		a, (l2deltaY)				; dy *= 2
 796+ E705              ;;/	call	l2_signed_mul2a
 797+ E705              ;;/	ld		(l2deltaYsq),a
 798+ E705              ;;/	neg									; DEBUG
 799+ E705              ;;/	ld		(l2deltaYsqn),a				; DEBUG
 800+ E705              ;;/	neg									; DEBUG
 801+ E705              ;;/.dxmuliplyby2:
 802+ E705              ;;/	ld		a, (l2deltaX)				; dx *= 2
 803+ E705              ;;/	call	l2_signed_mul2a
 804+ E705              ;;/	ld		(l2deltaXsq),a
 805+ E705              ;;/	neg									; DEBUG
 806+ E705              ;;/	ld		(l2deltaXsqn),a				; DEBUG
 807+ E705              ;;/	neg									; DEBUG
 808+ E705              ;;/.plotfirstpixel:
 809+ E705              ;;/	pushbcde
 810+ E705              ;;/	ld a,(l2linecolor)
 811+ E705              ;;/	call	l2_plot_pixel
 812+ E705              ;;/	popdebc
 813+ E705              ;;/.mainloop:								; if (l2_dx > l2_dy) signed
 814+ E705              ;;/	ld		a,(l2deltaX)				;If A < N, then S and P/V are different.
 815+ E705              ;;/	ld		hl,l2deltaY					;A >= N, then S and P/V are the same
 816+ E705              ;;/	cp		(hl)
 817+ E705              ;;/	jp		m,	.signset
 818+ E705              ;;/.signclear:
 819+ E705              ;;/	jp		pe,	.dxLTEdybranch
 820+ E705              ;;/	jr		.dxGTdybranch
 821+ E705              ;;/.signset:
 822+ E705              ;;/	jp		po,	.dxLTEdybranch
 823+ E705              ;;/.dxGTdybranch:
 824+ E705              ;;/	ld		a,(l2deltaYsq)
 825+ E705              ;;/	ld		hl,l2deltaX
 826+ E705              ;;/	sub		(hl)
 827+ E705              ;;/	ld		(l2fraction),a				; faction = dy - 1/2 dx
 828+ E705              ;;/.BranchAwhile							; while (l2_vx0 != l2_vx1)
 829+ E705              ;;/	ld		a,c
 830+ E705              ;;/	cp		e
 831+ E705              ;;/	ret		z							; if x0 = x1 then done
 832+ E705              ;;/.BranchAtestfraction:					; if (l2_fraction >= 0)
 833+ E705              ;;/	ld		a,(l2fraction)
 834+ E705              ;;/	TEST	$80
 835+ E705              ;;/	jr		nz,.BranchAskipYstep
 836+ E705              ;;/	inc		b							; 		++l2_vy0;
 837+ E705              ;;/	ld		hl,l2deltaXsq
 838+ E705              ;;/	sub		(hl)						; 		l2_fraction -= l2_dx;
 839+ E705              ;;/	ld		(l2fraction),a
 840+ E705              ;;/.BranchAskipYstep:
 841+ E705              ;;/.l2stepx1:
 842+ E705              ;;/	inc		b							; this is self modifying code point 1 l2_vx0 += l2_stepx
 843+ E705              ;;/	ld		a,(l2fraction)				; l2_fraction += l2_dy can optimise later as a already has this?
 844+ E705              ;;/	ld		hl,l2deltaYsq
 845+ E705              ;;/	add		a,(hl)
 846+ E705              ;;/	ld		(l2fraction),a
 847+ E705              ;;/.BranchAplotBCColA:						; l2_plot_pixel(l2_vx0,l2_vy0,color);
 848+ E705              ;;/	pushbcde
 849+ E705              ;;/	ld a,(l2linecolor)
 850+ E705              ;;/	call	l2_plot_pixel
 851+ E705              ;;/	popdebc
 852+ E705              ;;/.BranchAloop:
 853+ E705              ;;/	jr		.BranchAwhile
 854+ E705              ;;/.dxLTEdybranch:
 855+ E705              ;;/	ld		a,(l2deltaXsq)				; l2_fraction = l2_dx - (l2_dy >> 1);
 856+ E705              ;;/	ld		hl, l2deltaY
 857+ E705              ;;/	sub		(hl)
 858+ E705              ;;/	ld		(l2fraction),a				; faction = dy - 1/2 d
 859+ E705              ;;/.BranchBwhile:							; while (l2_vy0 != l2_vy1)
 860+ E705              ;;/	ld		a,b
 861+ E705              ;;/	cp		d
 862+ E705              ;;/	ret		z							; if x0 = x1 then done
 863+ E705              ;;/.BranchBtestfraction:					; if (l2_fraction >= 0)
 864+ E705              ;;/	ld		a,(l2fraction)
 865+ E705              ;;/	TEST	$80
 866+ E705              ;;/	jr		nz,.BranchBskipYstep
 867+ E705              ;;/.l2stepx2
 868+ E705              ;;/	inc		b							; l2_vx0 += l2_stepx; this is self modifying code point 2
 869+ E705              ;;/	ld		a,(l2fraction)				; l2_fraction -= l2_dy
 870+ E705              ;;/	ld		hl,l2deltaYsq
 871+ E705              ;;/	sub		(hl)
 872+ E705              ;;/	ld		(l2fraction),a
 873+ E705              ;;/.BranchBskipYstep:
 874+ E705              ;;/	ld		hl, l2deltaYsq
 875+ E705              ;;/	add		a,(hl)
 876+ E705              ;;/	ld		(l2fraction),a
 877+ E705              ;;/	inc		b							; ++l2_vy0;
 878+ E705              ;;/.BranchBplotBCColA:
 879+ E705              ;;/	pushbcde
 880+ E705              ;;/	ld a,(l2linecolor)
 881+ E705              ;;/	call	l2_plot_pixel
 882+ E705              ;;/	popdebc
 883+ E705              ;;/.BranchBloop:
 884+ E705              ;;/	jr		.BranchBwhile
 885+ E705
# file closed: ./Layer2Graphics/layer2_plot_diagonal.asm
 283  E705                  INCLUDE "./Layer2Graphics/asm_l2_plot_triangle.asm"
# file opened: ./Layer2Graphics/asm_l2_plot_triangle.asm
   1+ E705
   2+ E705
   3+ E705
   4+ E705 00 00        l2trianglebc	        DW 0
   5+ E707 00 00        l2trianglede	        DW 0
   6+ E709 00 00        l2trianglehl	        DW 0
   7+ E70B
   8+ E70B              ; "l2_draw_triangle, BC = y1x1, DE=y2x2, HL=y3x3 a = Color"
   9+ E70B C5 D5 E5 F5  l2_draw_triangle:       push	bc,,de,,hl,,af
  10+ E70F CD 33 E6                             call	l2_draw_diagonal		; BC to DE
  11+ E712 F1                                   pop		af
  12+ E713 D1                                   pop		de						; swap DE and HL
  13+ E714 E1                                   pop		hl						; so BC to DE is really to HL
  14+ E715 C1                                   pop		bc
  15+ E716 D5 E5                                push    de,,hl                    ; which is pushing original hl then original de
  16+ E718 F5                                   push	af
  17+ E719 CD 33 E6                             call	l2_draw_diagonal		; BC to HL (leaving DE and HL swapped)
  18+ E71C F1                                   pop		af
  19+ E71D C1                                   pop		bc						; Now bc = original de
  20+ E71E D1                                   pop		de						; de = original hl
  21+ E71F CD 33 E6                             call	l2_draw_diagonal		; BC to HL (leaving DE and HL swapped)
  22+ E722 C9                                   ret
  23+ E723
  24+ E723
  25+ E723
  26+ E723
  27+ E723
# file closed: ./Layer2Graphics/asm_l2_plot_triangle.asm
 284  E723                  INCLUDE "./Layer2Graphics/asm_l2_fill_triangle.asm"
# file opened: ./Layer2Graphics/asm_l2_fill_triangle.asm
   1+ E723              ; ">l2_fillBottomFlatTriangle BC y0x0 DE x1x2, H YCommon, L Colour"
   2+ E723              ; "note >l2_draw_diagonal_save, bc = y0,x0 de=y1,x1,a=array nbr ESOURCE LL30 or LION"
   3+ E723              ; "note line to   bc = left side row,col, d right pixel, e = color"
   4+ E723 DD 01        l2_fillBottomFlatTriangle:break
   5+ E725 7D                                   ld		a,l
   6+ E726 32 4C E3                             ld		(l2linecolor),a
   7+ E729 79                                   ld		a,c
   8+ E72A BB                                   cp		e
   9+ E72B 30 08                                jr		nc, .x2gtex1
  10+ E72D DD 26 01     .x1ltx2:                ld		ixh,1                           ; list 1 holds x0 down to x1
  11+ E730 DD 2E 02                             ld		ixl,2                           ; list 2 hols  x0 down to x2
  12+ E733 18 06                                jr		.storepoints
  13+ E735 DD 26 02     .x2gtex1:               ld		ixh,2
  14+ E738 DD 2E 01                             ld		ixl,1
  15+ E73B C5 D5 E5     .storepoints:           push	bc,,de,,hl
  16+ E73E DD 7C                                ld		a,ixh
  17+ E740 5A                                   ld		e,d                             ; we alreay have bc so its now bc -> hd
  18+ E741 54                                   ld		d,h
  19+ E742 CD 54 E5                             call	l2_draw_diagonal_save			;l2_store_diagonal(x0,y0,x1,ycommon,l2_LineMinX);
  20+ E745 E1 D1 C1                             pop		bc,,de,,hl
  21+ E748 C5 E5                                push	bc,,hl
  22+ E74A 54                                   ld		d,h                             ; now its bc -> he
  23+ E74B DD 7D                                ld		a,ixl
  24+ E74D CD 54 E5                             call	l2_draw_diagonal_save			;l2_store_diagonal(x0,y0,x2,ycommon,l2_LineMaxX);
  25+ E750 E1 C1                                pop		bc,,hl
  26+ E752 50           .SaveForLoop:           ld		d,b
  27+ E753 5C                                   ld		e,h								; save loop counters
  28+ E754 D5                                   push	de								; de = y0ycommon
  29+ E755 21 54 E3     .GetFirstHorizontalRow:	ld		hl,l2targetArray1               ; get first row for loop
  30+ E758 78                                   ld		a,b
  31+ E759 ED 31                                add		hl,a							; hl = l2targetArray1 row b
  32+ E75B 7E                                   ld		a,(hl)							;
  33+ E75C 4F                                   ld		c,a								; c = col1 i.e. l2targetarray1[b]
  34+ E75D 21 54 E4                             ld      hl,l2targetArray2
  35+ E760 78                                   ld      a,b
  36+ E761 ED 31                                add     hl,a
  37+ E763              ;                        inc		h								; hl = l2targetArray2 row b if we interleave
  38+ E763 7E                                   ld		a,(hl)
  39+ E764 57                                   ld		d,a								; d = col2 i.e. l2targetarray2[b]
  40+ E765 3A 4C E3     .SetColour:             ld		a,(l2linecolor)
  41+ E768 5F                                   ld		e,a								; de = to colour
  42+ E769 C5           .SavePoints:            push	bc								; bc = rowcol
  43+ E76A 25                                   dec		h
  44+ E76B E5                                   push	hl								; hl = l2targetArray1[b]
  45+ E76C CD B6 E2     .DoLine:	            call	l2_draw_horz_line_to
  46+ E76F E1                                   pop		hl
  47+ E770 C1                                   pop		bc
  48+ E771 04                                   inc		b								; down a rowc
  49+ E772 D1                                   pop		de								; de = from to (and b also = current)
  50+ E773 14                                   inc		d
  51+ E774 7B                                   ld		a,e								; while e >= d
  52+ E775 BA                                   cp		d
  53+ E776 30 DA                                jr 		nc,.SaveForLoop					; Is this the right point??
  54+ E778 C9                                   ret
  55+ E779
# file closed: ./Layer2Graphics/asm_l2_fill_triangle.asm
 285  E779                  INCLUDE "./Layer2Graphics/layer2_plot_circle.asm"
# file opened: ./Layer2Graphics/layer2_plot_circle.asm
   1+ E779
   2+ E779 00 00        l2_circle_pos		DW 0
   3+ E77B 00           l2_circle_colour	DB 0
   4+ E77C 00           l2_circle_radius	DB 0
   5+ E77D 00           l2_circle_x			DB 0
   6+ E77E 00           l2_circle_y			DB 0
   7+ E77F 00           l2_circle_d			DB 0
   8+ E780
   9+ E780              ; ">l2_draw_circle BC = center row col, d = radius, e = colour"
  10+ E780 7B           l2_draw_circle:     ld		a,e
  11+ E781 32 27 E8                         ld		(.PlotPixel+1),a
  12+ E784 7A                               ld		a,d								; get radius
  13+ E785 A7                               and		a
  14+ E786 C8                               ret		z
  15+ E787 FE 01                            cp		1
  16+ E789 CA 32 E8                         jp		z,CircleSinglepixel
  17+ E78C ED 43 B6 E7                      ld		(.Plot1+1),bc					; save origin into DE reg in code
  18+ E790 DD 67                            ld		ixh,a							; ixh = raidus
  19+ E792 DD 2E 00                         ld		ixl,0
  20+ E795 26 00        .calcd:	            ld		h,0
  21+ E797 6F                               ld		l,a
  22+ E798 29                               add		hl,hl							; hl = r * 2
  23+ E799 EB                               ex		de,hl							; de = r * 2
  24+ E79A 21 03 00                         ld		hl,3
  25+ E79D A7                               and		a
  26+ E79E ED 52                            sbc		hl,de							; hl = 3 - (r * 2)
  27+ E7A0 44                               ld		b,h
  28+ E7A1 4D                               ld		c,l								; bc = 3 - (r * 2)
  29+ E7A2 21 01 00     .calcdelta:         ld		hl,1
  30+ E7A5 16 00                            ld		d,0
  31+ E7A7 DD 5D                            ld		e,ixl
  32+ E7A9 A7                               and		a
  33+ E7AA ED 52                            sbc		hl,de
  34+ E7AC 11 01 00     .Setde1:            ld		de,1
  35+ E7AF DD 7C        .CircleLoop:        ld		a,ixh
  36+ E7B1 DD BD                            cp		ixl
  37+ E7B3 D8                               ret		c
  38+ E7B4 D9           .ProcessLoop:	    exx
  39+ E7B5 11 00 00     .Plot1:             ld		de,0
  40+ E7B8 7B                               ld		a,e
  41+ E7B9 DD 85                            add		a,ixl
  42+ E7BB 4F                               ld		c,a
  43+ E7BC 7A                               ld		a,d
  44+ E7BD DD 84                            add		a,ixh
  45+ E7BF 47                               ld		b,a
  46+ E7C0 CD 26 E8                         call	.PlotPixel			;CX+X,CY+Y
  47+ E7C3 7B           .Plot2:             ld 		a,e
  48+ E7C4 DD 95                            sub 	ixl
  49+ E7C6 4F                               ld 		c,a
  50+ E7C7 7A                               ld 		a,d
  51+ E7C8 DD 84                            add 	a,ixh
  52+ E7CA 47                               ld		b,a
  53+ E7CB CD 26 E8                         call	.PlotPixel			;CX-X,CY+Y
  54+ E7CE 7B           .Plot3:             ld 		a,e
  55+ E7CF DD 85                            add		a,ixl
  56+ E7D1 4F                               ld 		c,a
  57+ E7D2 7A                               ld 		a,d
  58+ E7D3 DD 94                            sub 	ixh
  59+ E7D5 47                               ld 		b,a
  60+ E7D6 CD 26 E8                         call	.PlotPixel			;CX+X,CY-Y
  61+ E7D9 7B           .Plot4:             ld 		a,e
  62+ E7DA DD 95                            sub 	ixl
  63+ E7DC 4F                               ld 		c,a
  64+ E7DD 7A                               ld 		a,d
  65+ E7DE DD 94                            sub 	ixh
  66+ E7E0 47                               ld 		b,a
  67+ E7E1 CD 26 E8                         call	.PlotPixel			;CY+X,CX-Y
  68+ E7E4 7A           .Plot5:	            ld 		a,d
  69+ E7E5 DD 85                            add 	a,ixl
  70+ E7E7 47                               ld 		b,a
  71+ E7E8 7B                               ld 		a,e
  72+ E7E9 DD 84                            add 	a,ixh
  73+ E7EB 4F                               ld 		c,a
  74+ E7EC CD 26 E8                         call	.PlotPixel			;CY+X,CX+Y
  75+ E7EF 7A           .Plot6:	            ld 		a,d
  76+ E7F0 DD 95                            sub 	ixl
  77+ E7F2 47                               ld 		b,a
  78+ E7F3 7B                               ld 		a,e
  79+ E7F4 DD 84                            add 	a,ixh
  80+ E7F6 4F                               ld 		c,a
  81+ E7F7 CD 26 E8                         call	.PlotPixel			;CY-X,CX+Y
  82+ E7FA 7A           .Plot7:	            ld 		a,d
  83+ E7FB DD 85                            add 	a,ixl
  84+ E7FD 47                               ld 		b,a
  85+ E7FE 7B                               ld 		a,e
  86+ E7FF DD 94                            sub 	ixh
  87+ E801 4F                               ld 		c,a
  88+ E802 CD 26 E8                         call	.PlotPixel			;CY+X,CX-Y
  89+ E805 7A           .Plot8:	            ld 		a,d
  90+ E806 DD 95                            sub 	ixl
  91+ E808 47                               ld		b,a
  92+ E809 7B                               ld 		a,e
  93+ E80A DD 94                            sub 	ixh
  94+ E80C 4F                               ld 		c,a
  95+ E80D CD 26 E8                         call	.PlotPixel			;CX+X,CY-Y
  96+ E810 D9                               exx
  97+ E811 CB 7C        .IncrementCircle:	bit     7,h				; Check for Hl<=0
  98+ E813 28 03                            jr z,   .draw_circle_1
  99+ E815 19                               add hl,de			; Delta=Delta+D1
 100+ E816 18 05                            jr      .draw_circle_2		;
 101+ E818 09           .draw_circle_1:		add     hl,bc			; Delta=Delta+D2
 102+ E819 03                               inc     bc
 103+ E81A 03                               inc     bc				; D2=D2+2
 104+ E81B DD 25                            dec     ixh				; Y=Y-1
 105+ E81D 03           .draw_circle_2:		inc bc				; D2=D2+2
 106+ E81E 03                               inc bc
 107+ E81F 13                               inc de				; D1=D1+2
 108+ E820 13                               inc de
 109+ E821 DD 2C                            inc ixl				; X=X+1
 110+ E823 C3 AF E7                         jp      .CircleLoop
 111+ E826 3E 00        .PlotPixel:         ld		a,0                  ; This was originally indirect, where as it neeed to be value
 112+ E828 D5 C5 E5                         push	de,,bc,,hl
 113+ E82B CD 43 E1                         call 	l2_plot_pixel_y_test
 114+ E82E E1 C1 D1                         pop		de,,bc,,hl
 115+ E831 C9                               ret
 116+ E832 7B           CircleSinglepixel:  ld		a,e
 117+ E833 CD 43 E1                         call	l2_plot_pixel_y_test
 118+ E836 C9                               ret
 119+ E837
# file closed: ./Layer2Graphics/layer2_plot_circle.asm
 286  E837                  INCLUDE "./Layer2Graphics/layer2_plot_circle_fill.asm"
# file opened: ./Layer2Graphics/layer2_plot_circle_fill.asm
   1+ E837
   2+ E837 00           l2_circle_dblx		DB 0
   3+ E838 00           l2_circle_dbly		DB 0
   4+ E839
   5+ E839              ; ">l2_draw_circle_fill BC = center row col, d = radius, e = colour"
   6+ E839              ; Note this code currently does not process BC
   7+ E839 7B           l2_draw_circle_fill:    ld		a,e
   8+ E83A 32 D0 E8                             ld		(.LineColour+1),a
   9+ E83D 7A                                   ld		a,d								; get radius
  10+ E83E A7                                   and		a
  11+ E83F C8                                   ret		z
  12+ E840 FE 01                                cp		1
  13+ E842 CA 32 E8                             jp		z,CircleSinglepixel
  14+ E845 ED 43 6F E8                          ld		(.Line1+1),bc					; save origin into DE reg in code
  15+ E849 DD 67                                ld		ixh,a							; ixh = raidus (x)
  16+ E84B DD 2E 00                             ld		ixl,0							; ihy = y
  17+ E84E 26 00        .calcd:	                ld		h,0
  18+ E850 6F                                   ld		l,a
  19+ E851 29                                   add		hl,hl							; hl = r * 2
  20+ E852 EB                                   ex		de,hl							; de = r * 2
  21+ E853 21 03 00                             ld		hl,3
  22+ E856 A7                                   and		a
  23+ E857 ED 52                                sbc		hl,de							; hl = 3 - (r * 2)
  24+ E859 44                                   ld		b,h
  25+ E85A 4D                                   ld		c,l								; bc = 3 - (r * 2)
  26+ E85B 21 01 00     .calcdelta              ld		hl,1
  27+ E85E 16 00                                ld		d,0
  28+ E860 DD 5D                                ld		e,ixl
  29+ E862 A7                                   and		a
  30+ E863 ED 52                                sbc		hl,de
  31+ E865 11 01 00     .Setde1	                ld		de,1
  32+ E868 DD 7C        .CircleLoop:            ld		a,ixh
  33+ E86A DD BD                                cp		ixl
  34+ E86C D8                                   ret		c
  35+ E86D D9           .ProcessLoop:	        exx
  36+ E86E 11 00 00     .Line1:                 ld		de,0
  37+ E871 7B                                   ld 		a,e
  38+ E872 DD 95                                sub 	ixl
  39+ E874 4F                                   ld 		c,a
  40+ E875 7A                                   ld 		a,d
  41+ E876 DD 84                                add 	a,ixh
  42+ E878 47                                   ld		b,a
  43+ E879                                      ;; TODO ADD DOUBLE X CALC
  44+ E879 D5                                   push	de
  45+ E87A DD 55                                ld		d,ixl
  46+ E87C CB 22                                sla		d
  47+ E87E CD CB E8                             call	.PlotLine			;CX-X,CY+Y
  48+ E881 D1                                   pop		de
  49+ E882 7B           .Line2:                 ld 		a,e
  50+ E883 DD 95                                sub		ixl
  51+ E885 4F                                   ld 		c,a
  52+ E886 7A                                   ld 		a,d
  53+ E887 DD 94                                sub 	ixh
  54+ E889 47                                   ld 		b,a
  55+ E88A                                      ;; TODO ADD DOUBLE X CALC
  56+ E88A D5                                   push	de
  57+ E88B DD 55                                ld		d,ixl
  58+ E88D CB 22                                sla		d
  59+ E88F CD CB E8                             call	.PlotLine			;CX-X,CY-Y
  60+ E892 D1                                   pop		de
  61+ E893 7B           .Line3:	                ld 		a,e
  62+ E894 DD 94                                sub		ixh
  63+ E896 4F                                   ld 		c,a
  64+ E897 7A                                   ld 		a,d
  65+ E898 DD 85                                add 	a,ixl
  66+ E89A 47                                   ld 		b,a
  67+ E89B                                      ;; TODO ADD DOUBLE Y CALC
  68+ E89B D5                                   push	de
  69+ E89C DD 54                                ld		d,ixh
  70+ E89E CB 22                                sla		d
  71+ E8A0 CD CB E8                             call	.PlotLine			;CX-Y,CY+x
  72+ E8A3 D1                                   pop		de
  73+ E8A4 7B           .Line4:	                ld 		a,e
  74+ E8A5 DD 94                                sub		ixh
  75+ E8A7 4F                                   ld 		c,a
  76+ E8A8 7A                                   ld 		a,d
  77+ E8A9 DD 95                                sub 	ixl
  78+ E8AB 47                                   ld 		b,a
  79+ E8AC                                      ;; TODO ADD DOUBLE Y CALC
  80+ E8AC D5                                   push	de
  81+ E8AD DD 54                                ld		d,ixh
  82+ E8AF CB 22                                sla		d
  83+ E8B1 CD CB E8                             call	.PlotLine			;CX-Y,CY+x
  84+ E8B4 D1                                   pop		de
  85+ E8B5 D9                                   exx
  86+ E8B6 CB 7C        .IncrementCircle:	    bit 7,h				; Check for Hl<=0
  87+ E8B8 28 03                                jr z,.draw_circle_1
  88+ E8BA 19                                   add hl,de			; Delta=Delta+D1
  89+ E8BB 18 05                                jr .draw_circle_2		;
  90+ E8BD 09           .draw_circle_1:		    add hl,bc			; Delta=Delta+D2
  91+ E8BE 03                                   inc bc
  92+ E8BF 03                                   inc bc				; D2=D2+2
  93+ E8C0 DD 25                                dec ixh				; Y=Y-1
  94+ E8C2 03           .draw_circle_2:		    inc bc				; D2=D2+2
  95+ E8C3 03                                   inc bc
  96+ E8C4 13                                   inc de				; D1=D1+2
  97+ E8C5 13                                   inc de
  98+ E8C6 DD 2C                                inc ixl				; X=X+1
  99+ E8C8 C3 68 E8                             jp .CircleLoop
 100+ E8CB D5 C5 E5 F5  .PlotLine:              push	de,,bc,,hl,,af
 101+ E8CF 3E 00        .LineColour:	        ld		a,0         ; circle colur
 102+ E8D1 5F                                   ld      e,a
 103+ E8D2 CD 8A E2                             call 	l2_draw_horz_line
 104+ E8D5 F1 E1 C1 D1                          pop     de,,bc,,hl,,af
 105+ E8D9 C9                                   ret
 106+ E8DA
# file closed: ./Layer2Graphics/layer2_plot_circle_fill.asm
 287  E8DA                  INCLUDE "./Layer2Graphics/l2_draw_any_line.asm"
# file opened: ./Layer2Graphics/l2_draw_any_line.asm
   1+ E8DA              ; ">l2_draw_any_line, bc = y0,x0 de=y1,x1,a=color: determines if its horizontal, vertical or diagonal then hands off the work"
   2+ E8DA 08           l2_draw_any_line:       ex		af,af'              ; save colour into a'
   3+ E8DB 79                                   ld		a,c                 ; if x and e are the same its horizontal
   4+ E8DC BB                                   cp		e
   5+ E8DD 28 08                                jr		z,.HorizontalLineCheck
   6+ E8DF 78                                   ld		a,b                 ; if b and d are the same its vertica;
   7+ E8E0 BA                                   cp		d
   8+ E8E1 28 0E                                jr		z,.VerticalLine
   9+ E8E3              ; use jp and get a free ret instruction optimisation
  10+ E8E3 08           .DiagonalLine:		    ex		af,af'			     ; get colour back into a
  11+ E8E4 C3 33 E6                             jp		l2_draw_diagonal
  12+ E8E7
  13+ E8E7 78           .HorizontalLineCheck:   ld      a,b
  14+ E8E8 BA                                   cp      d
  15+ E8E9 28 0B                                jr      z, .SinglePixel
  16+ E8EB 08           .HorizontalLine:        ex		af,af'              ; get colour back into a
  17+ E8EC 53                                   ld		d,e				    ; set d as target right pixel
  18+ E8ED 5F                                   ld		e,a				    ; e holds colour on this call
  19+ E8EE C3 B6 E2                             jp		l2_draw_horz_line_to
  20+ E8F1 08           .VerticalLine:          ex		af,af'
  21+ E8F2 5F                                   ld		e,a				    ; e holds colour on this call
  22+ E8F3 C3 35 E3                             jp		l2_draw_vert_line_to
  23+ E8F6 08           .SinglePixel:           ex		af,af'              ; get colour back into a
  24+ E8F7 C3 29 E1                             jp      l2_plot_pixel
  25+ E8FA              ;......................................................
  26+ E8FA
# file closed: ./Layer2Graphics/l2_draw_any_line.asm
 288  E8FA                  INCLUDE "./Layer2Graphics/l2_draw_line_v2.asm"
# file opened: ./Layer2Graphics/l2_draw_line_v2.asm
   1+ E8FA              ; ******************************************************************************
   2+ E8FA              ;
   3+ E8FA              ;	Draw a pixel line from (x0,y0) defined in (COORDS) - the current plot
   4+ E8FA              ;	coordinate, to the relative distance points (x0+x,y0+y).
   5+ E8FA              ;
   6+ E8FA              ;	Design & programming by Gunther Strube,	Copyright (C) InterLogic 1995
   7+ E8FA              ;
   8+ E8FA              ;	The (COORDS+0)	pointer contains the current y coordinate, (COORDS+1) the
   9+ E8FA              ;	current x coordinate. The main program should reset the (COORDS) variables
  10+ E8FA              ;	before using line drawing.
  11+ E8FA              ;
  12+ E8FA              ;	The routine checks the range of specified coordinates which is the
  13+ E8FA              ;	boundaries of the graphics area (256x64	pixels).
  14+ E8FA              ;	If a boundary error occurs the routine exits automatically.	This may be
  15+ E8FA              ;	useful if you are trying to draw a line longer than allowed. Only the
  16+ E8FA              ;	visible part will be drawn.
  17+ E8FA              ;
  18+ E8FA              ;	The hardware graphics memory is organized as (0,0) in the top left corner.
  19+ E8FA              ;
  20+ E8FA              ;	The plot routine is	defined by an address pointer	in IX.
  21+ E8FA              ;
  22+ E8FA              ;	IN:	HL =	move	relative x horisontal points (maximum +/- 255).
  23+ E8FA              ;		DE =	move	relative y vertical	points (maximum +/-	255).
  24+ E8FA              ;		IX =	pointer to plot routine that uses HL = (x,y)	of plot coordinate.
  25+ E8FA              ;
  26+ E8FA              ;	OUT:	None.
  27+ E8FA              ;
  28+ E8FA              ;	Registers	used	by routine:
  29+ E8FA              ;		   N	:	B, loop counter
  30+ E8FA              ;		   i	:	line	balance variable
  31+ E8FA              ;		   x	:	H/L,	horisontal, vertical distance	variables
  32+ E8FA              ;		   y	:	H/L,	horisontal, vertical distance	variables
  33+ E8FA              ;	  (x0,y0)	:	(h,l)
  34+ E8FA              ;	  direc_x	:	d, horisontal step increment
  35+ E8FA              ;	  direc_y	:	e, vertical step increment
  36+ E8FA              ;		 ddx	:	b, horisontal step increment
  37+ E8FA              ;		 ddy	:	c, vertical step increment
  38+ E8FA              ;
  39+ E8FA              ;		DE, A work registers.
  40+ E8FA              ;
  41+ E8FA              ; The algorithm in pseudo-code:
  42+ E8FA              ;
  43+ E8FA              ;	direc_x =	SGN x: direc_y	= SGN y
  44+ E8FA              ;	x = ABS x: y =	ABS y
  45+ E8FA              ;
  46+ E8FA              ;	if x	>= y
  47+ E8FA              ;		if x+y=0 then return
  48+ E8FA              ;		H = x
  49+ E8FA              ;		L = y
  50+ E8FA              ;		ddx = direc_x
  51+ E8FA              ;		ddy = 0
  52+ E8FA              ;	else
  53+ E8FA              ;		H = y
  54+ E8FA              ;		L = x
  55+ E8FA              ;		ddx = 0
  56+ E8FA              ;		ddy = direc_y
  57+ E8FA              ;	endif
  58+ E8FA              ;
  59+ E8FA              ;	B = H
  60+ E8FA              ;	i = INT(B/2)
  61+ E8FA              ;	FOR N=B TO 1 STEP -1
  62+ E8FA              ;		i = i + L
  63+ E8FA              ;		if i	< H
  64+ E8FA              ;			ix =	ddx
  65+ E8FA              ;			iy =	ddy
  66+ E8FA              ;		else
  67+ E8FA              ;			i = i - H
  68+ E8FA              ;			ix =	direc_x
  69+ E8FA              ;			iy =	direc_y
  70+ E8FA              ;		endif
  71+ E8FA              ;		x0 =	x0 +	ix
  72+ E8FA              ;		y0 =	y0 +	iy
  73+ E8FA              ;		plot	(x0,y0)
  74+ E8FA              ;	NEXT	N
  75+ E8FA              ;
  76+ E8FA              ;
  77+ E8FA              ;	Registers	changed after return:
  78+ E8FA              ;		..BCDEHL/IXIY/af......	same
  79+ E8FA              ;		AF....../..../..bcdehl	different
  80+ E8FA              ;
  81+ E8FA DF           line_gfx_colour db $DF
  82+ E8FB 00 00        line_gfx_coords	dw 0
  83+ E8FD              LineHLtoDE:
  84+ E8FD 7C           TestMaxY:               ld	a,h ; were h = y or l = y?
  85+ E8FE FE C0                                cp	192
  86+ E900 30 26                                jr	nc, exit_line		; y0	coordinate out	of range
  87+ E902 7A                                   ld	a,d
  88+ E903 FE C0                                cp	192
  89+ E905 30 21                                jr	nc, exit_line		; y1	coordinate out	of range
  90+ E907 22 FB E8                             ld	(line_gfx_coords),hl		; the starting	point is now default
  91+ E90A E5                                   push	hl
  92+ E90B D5                                   push	de
  93+ E90C 6C                                   ld	l,h				; L = x0
  94+ E90D 62                                   ld	h,d				; H = x1
  95+ E90E 7C           distanceX:		        ld	a,h
  96+ E90F 95                                   sub	l
  97+ E910 6F                                   ld	l,a
  98+ E911 26 00                                ld	h,0
  99+ E913 30 02                                jr	nc, distanceXDone
 100+ E915 26 FF                                ld	h,-1
 101+ E917 D1           distanceXDone:          pop	de
 102+ E918 E3                                   ex	(sp),hl			; L = y0
 103+ E919 63                                   ld	h,e				; H = y1
 104+ E91A 7C           distanceY:		        ld	a,h
 105+ E91B 95                                   sub	l
 106+ E91C 6F                                   ld	l,a
 107+ E91D 26 00                                ld	h,0
 108+ E91F 30 02                                jr	nc, distanceYDone
 109+ E921 26 FF                                ld	h,-1
 110+ E923 D1           distanceYDone:          pop	de
 111+ E924 EB                                   ex	de,hl			; h.dist.	= HL, v.dist. = DE
 112+ E925 CD 29 E9                             call	DrawLineRelative			; draw line...
 113+ E928 C9           exit_line:              ret
 114+ E929
 115+ E929              ; ***************************************************************************
 116+ E929              ;
 117+ E929              ;	IN:	HL =	move	relative x horisontal points (maximum +/- 255).
 118+ E929              ;		DE =	move	relative y vertical	points (maximum +/-	255).
 119+ E929              ;
 120+ E929              ; OUT: h - l distance in	HL
 121+ E929              ;
 122+ E929
 123+ E929 D5           DrawLineRelative:       push	de
 124+ E92A E5                                   push	hl
 125+ E92B D9                                   exx
 126+ E92C E1                                   pop	hl					; get relative	horisontal movement
 127+ E92D CD 98 E9                             call	sgn
 128+ E930 57                                   ld	d,a					; direc_x	= SGN(x) installed d = +/-1 for horizontal update
 129+ E931 CD A5 E9                             call	absValue
 130+ E934 45                                   ld	b,l					; x = ABS(x)
 131+ E935 E1           DrawLineGetVertRelative:pop	hl					; get relative	vertical movement
 132+ E936 CD 98 E9                             call	sgn
 133+ E939 5F                                   ld	e,a					; direc_y	= SGN(y) installed  = +/-1 for vertical update
 134+ E93A CD A5 E9                             call	absValue
 135+ E93D 4D                                   ld	c,l					; y = ABS(y) so now bc = dxdy
 136+ E93E              ; so by here BC = dx dy HL in increment/decrement x y
 137+ E93E C5                                   push	bc
 138+ E93F D9                                   exx
 139+ E940 E1                                   pop	hl					; H = absolute	x dist., L = absolute y distance
 140+ E941 7C                                   ld	a,h
 141+ E942 BD                                   cp	l
 142+ E943 38 0A                                jr	c, x_smaller_y		; if	x >=	y
 143+ E945 B4           areXandYZero:           or	h					;	if x+y = 0
 144+ E946 28 4F                                jr	z, exit_draw		;		return
 145+ E948 D9           y_lessorequal_x:        exx						;	else
 146+ E949 42                                   ld	b,d					;		ddx = direc_x
 147+ E94A 0E 00                                ld	c,0					;		ddy = 0
 148+ E94C D9                                   exx
 149+ E94D 18 08                                jr	init_drawloop		; else
 150+ E94F 7C           x_smaller_y:	        ld	a,h
 151+ E950 65                                   ld	h,l					;	H = y
 152+ E951 6F                                   ld	l,a					;	L = x
 153+ E952 D9                                   exx
 154+ E953 06 00                                ld	b,0					;	ddx = 0
 155+ E955 4B                                   ld	c,e					;	ddy = direc_y
 156+ E956 D9                                   exx
 157+ E957 44           init_drawloop:	        ld	b,h
 158+ E958 4C                                   ld	c,h					; B = H
 159+ E959 CB 39                                srl	c					; i = INT(B/2)
 160+ E95B              										; FOR N=B	TO 1	STEP	-1
 161+ E95B 79           drawloop:		        ld	a,c
 162+ E95C 85                                   add	a,l
 163+ E95D 38 09                                jr	c, i_greater		;	i + L > 255  (i > H)
 164+ E95F BC                                   cp	h
 165+ E960 30 06                                jr	nc, i_greater		;	if i	< H
 166+ E962 4F                                   ld	c,a					;		i = i + L
 167+ E963 D9                                   exx
 168+ E964 C5                                   push	bc				;		ix =	ddx:	iy =	ddy
 169+ E965 D9                                   exx
 170+ E966 18 05                                jr	check_plot			;	else
 171+ E968 94           i_greater:		        sub	h					;		i = i - H
 172+ E969 4F                                   ld	c,a
 173+ E96A D9                                   exx
 174+ E96B D5                                   push	de				;		ix =	direc_x: iy = direc_y
 175+ E96C D9                                   exx						;	endif
 176+ E96D E3           check_plot:		        ex	(sp),hl				;	preserve H,L distances on stack
 177+ E96E EB                                   ex	de,hl				;	D,E = ix,	iy
 178+ E96F 2A FB E8                             ld	hl,(line_gfx_coords)
 179+ E972 7D                                   ld	a,l
 180+ E973 83                                   add	a,e					;
 181+ E974 6F                                   ld	l,a					;	y0 =	y0 +	iy (y0 is	checked by plot)
 182+ E975 7A                                   ld	a,d
 183+ E976 3C                                   inc	a
 184+ E977 84                                   add	a,h
 185+ E978 38 04                                jr	c, check_range		;	check out	of range
 186+ E97A 28 1A                                jr	z, range_error		;	Fz=1	& Fc=0 denotes	x0 <	0
 187+ E97C 18 02                                jr	plot_point
 188+ E97E 20 16        check_range:            jr	nz, range_error	;	Fz=0	& Fc=1 denotes	x0 >	255
 189+ E980
 190+ E980 3D           plot_point:             dec	a
 191+ E981 C5                                   push	bc
 192+ E982 F5                                   push	af
 193+ E983 47                                   ld	    b,a					;	x0 =	x0 +	ix
 194+ E984 4D                                   ld		c,l
 195+ E985 3A FA E8                             ld		a,(line_gfx_colour)
 196+ E988 ED 43 FB E8                          ld      (line_gfx_coords),bc
 197+ E98C CD 29 E1                             call	l2_plot_pixel
 197+ E98F
 198+ E98F F1                                   pop		af
 199+ E990 C1                                   pop		bc
 200+ E991 E1           plot_RET:		        pop	hl					;	restore H,L distances...
 201+ E992 10 C7                                djnz	drawloop		; NEXT N
 202+ E994 18 01                                jr	exit_draw
 203+ E996
 204+ E996 E1           range_error:	        pop	hl					; remove H,L distances...
 205+ E997 C9           exit_draw:		        ret
 206+ E998
 207+ E998
 208+ E998              ; ******************************************************************************
 209+ E998              ;
 210+ E998              ;	SGN (Signum value) of 16	bit signed integer.
 211+ E998              ;
 212+ E998              ;	IN:		HL =	integer
 213+ E998              ;	OUT:		A = result: 0,1,-1 (if zero, positive, negative)
 214+ E998              ;
 215+ E998              ;	Registers	changed after return:
 216+ E998              ;	..BCDEHL/IXIY	same
 217+ E998              ;	AF....../....	different
 218+ E998              ;
 219+ E998 7C           sgn:				    ld	a,h
 220+ E999 B5                                   or	l
 221+ E99A C8                                   ret	z				; integer	is zero, return 0...
 222+ E99B CB 7C                                bit	7,h
 223+ E99D 20 03                                jr	nz, negative_int
 224+ E99F 3E 01                                ld	a,1
 225+ E9A1 C9                                   ret
 226+ E9A2 3E FF        negative_int:		    ld	a,-1
 227+ E9A4 C9                                   ret
 228+ E9A5
 229+ E9A5
 230+ E9A5              ; ******************************************************************************
 231+ E9A5              ;
 232+ E9A5              ;	ABS (Absolute value) of 16 bit signed integer.
 233+ E9A5              ;
 234+ E9A5              ;	IN:		HL =	integer
 235+ E9A5              ;	OUT:		HL =	converted	integer
 236+ E9A5              ;
 237+ E9A5              ;	Registers	changed after return:
 238+ E9A5              ;	A.BCDE../IXIY	same
 239+ E9A5              ;	.F....HL/....	different
 240+ E9A5              ;
 241+ E9A5 CB 7C        absValue:			    bit	7,h
 242+ E9A7 C8                                   ret	z				; integer	is positive...
 243+ E9A8 D5                                   push	de
 244+ E9A9 EB                                   ex	de,hl
 245+ E9AA 21 00 00                             ld	hl,0
 246+ E9AD BF                                   cp	a				; Fc	= 0,	may not be used...
 247+ E9AE ED 52                                sbc	hl,de			; convert	negative integer
 248+ E9B0 D1                                   pop	de
 249+ E9B1 C9                                   ret
 250+ E9B2
# file closed: ./Layer2Graphics/l2_draw_line_v2.asm
 289  E9B2
 290  E9B2              ; Bank 83  ------------------------------------------------------------------------------------------------------------------------
 291  E9B2                  SLOT    SunBankAddr
 292  E9B2                  PAGE    BankSunData
 293  E9B2              	ORG	    SunBankAddr,BankSunData
 294  C000                  INCLUDE "./Universe/Sun/sun_data.asm"
# file opened: ./Universe/Sun/sun_data.asm
   1+ C000              ; In  flight ship data tables
   2+ C000              ; In  flight ship data tables
   3+ C000              ; In  flight ship data tables
   4+ C000              ; There can be upto &12 objects in flight.
   5+ C000              ; To avoid hassle of memory heap managment, the free list
   6+ C000              ; will correspond to a memory bank offset so data will be held in
   7+ C000              ; 1 bank per universe object. Its a waste of a lot of memory but really
   8+ C000              ; 1 bank per universe object. Its a waste of a lot of memory but really
   9+ C000              ; simple that way. Each bank will be 8K and swapped on 8K slot 7 $E000 to $FFFF
  10+ C000              ; This means each gets its own line list, inwork etc
  11+ C000
  12+ C000              ; "Runtime Ship Data paged into in Bank 7"
  13+ C000 53 75 6E 20  StartOfSun:        DB "Sun and Planet X"
  13+ C004 61 6E 64 20
  13+ C008 50 6C 61 6E
  13+ C00C 65 74 20 58
  14+ C010              ; NOTE we can cheat and pre allocate segs just using a DS for now
  15+ C010              CheckRowHLOnScreen:     MACRO   failtarget
  16+ C010 ~                                    ld      a,h                             ; is h byte set, i.e > 256 or < 0
  17+ C010 ~                                    and     a                               ; .
  18+ C010 ~                                    jr      nz,failtarget                   ; h <> 0 so fails (covers <0 and > 255
  19+ C010 ~                                    ld      a,l                             ; l bit 7 0?
  20+ C010 ~                                    and     Bit7Only                        ; covers l > 127 (screen draw area is 0 to 192 / 3 * 2 (128)
  21+ C010 ~                                    jr      nz,failtarget                   ;
  22+ C010                                      ENDM
  23+ C010
  24+ C010              ; IY = SBnKLineArray + rowValue*2
  25+ C010              IYEquRowN:              MACRO   rowValue                        ; set up iy as target address
  26+ C010 ~                                    ld      a,rowValue
  27+ C010 ~                                    ld      hl,SBnKLineArray
  28+ C010 ~                                    add     hl,a
  29+ C010 ~                                    add     hl,a
  30+ C010 ~                                    push    hl
  31+ C010 ~                                    pop     iy
  32+ C010                                      ENDM
  33+ C010              ;   \ -> & 565D \ See ship data files chosen and loaded after flight code starts running.
  34+ C010              ; Universe map substibute for INWK
  35+ C010              ;-Camera Position of Ship----------------------------------------------------------------------------------------------------------
  36+ C010              SBnKDataBlock:
  37+ C010                                      INCLUDE "./Universe/Sun/SunPosVars.asm"
# file opened: ././Universe/Sun/SunPosVars.asm
   1++C010              ;-Camera Position of Ship----------------------------------------------------------------------------------------------------------
   2++C010 00           SBnKxlo                     DB  0                       ; INWK+0
   3++C011 00           SBnKxhi                     DB  0                       ; there are hi medium low as some times these are 24 bit
   4++C012 00           SBnKxsgn                    DB  0                       ; INWK+2
   5++C013 00           SBnKylo                     DB  0                       ; INWK+3 \ ylo
   6++C014 00           SBnKyhi                     DB  0                       ; INWK+4 \ yHi
   7++C015 00           SBnKysgn                    DB  0                       ; INWK +5
   8++C016 00           SBnKzlo                     DB  0                       ; INWK +6
   9++C017 00           SBnKzhi                     DB  0                       ; INWK +7
  10++C018 00           SBnKzsgn                    DB  0                       ; INWK +8
  11++C019
# file closed: ././Universe/Sun/SunPosVars.asm
  38+ C019                                      INCLUDE "./Universe/Sun/SunRotationMatrixVars.asm"
# file opened: ././Universe/Sun/SunRotationMatrixVars.asm
   1++C019              ;-Rotation Matrix of Ship----------------------------------------------------------------------------------------------------------
   2++C019              ; Rotation data is stored as lohi, but only 15 bits with 16th bit being  a sign bit. Note this is NOT 2'c compliment
   3++C019 00 00        SBnKrotmatSidevX            DW  0                       ; INWK +21
   4++C01B              SBnKrotmatSidev             equ SBnKrotmatSidevX
   5++C01B 00 00        SBnKrotmatSidevY            DW  0                       ; INWK +23
   6++C01D 00 00        SBnKrotmatSidevZ            DW  0                       ; INWK +25
   7++C01F 00 00        SBnKrotmatRoofvX            DW  0                       ; INWK +15
   8++C021              SBnKrotmatRoofv             equ SBnKrotmatRoofvX
   9++C021 00 00        SBnKrotmatRoofvY            DW  0                       ; INWK +17
  10++C023 00 00        SBnKrotmatRoofvZ            DW  0                       ; INWK +19
  11++C025 00 00        SBnKrotmatNosevX            DW  0                       ; INWK +9
  12++C027              SBnKrotmatNosev             EQU SBnKrotmatNosevX
  13++C027 00 00        SBnKrotmatNosevY            DW  0                       ; INWK +11
  14++C029 00 00        SBnKrotmatNosevZ            DW  0                       ; INWK +13
  15++C02B
# file closed: ././Universe/Sun/SunRotationMatrixVars.asm
  39+ C02B                                      INCLUDE "./Universe/Sun/SunAIRuntimeData.asm"
# file opened: ././Universe/Sun/SunAIRuntimeData.asm
   1++C02B              ; -- Ship AI data
   2++C02B 00           SBnKRotXCounter             DB  0                       ; INWK +29
   3++C02C 00           SBnKRotZCounter             DB  0                       ; INWK +30
   4++C02D 00           SBnkCam0yLo                 DB  0                       ; INWK +33 ????
   5++C02E 00           SBnkCam0yHi                 DB  0                       ; INWK +34?????
   6++C02F
# file closed: ././Universe/Sun/SunAIRuntimeData.asm
  40+ C02F
  41+ C02F
  42+ C02F                                      INCLUDE "./Universe/Sun/SunXX16Vars.asm"
# file opened: ././Universe/Sun/SunXX16Vars.asm
   1++C02F              ;-- XX16 --------------------------------------------------------------------------------------------------------------------------
   2++C02F 00 00        SBnkTransmatSidevX          DW  0               ; XX16+0
   3++C031              SBnkTransmatSidev           EQU SBnkTransmatSidevX
   4++C031 00 00        SBnkTransmatSidevY          DW 0                ; XX16+2
   5++C033 00 00        SBnkTransmatSidevZ          DW 0                ; XX16+2
   6++C035 00 00        SBnkTransmatRoofvX          DW 0
   7++C037              SBnkTransmatRoofv           EQU SBnkTransmatRoofvX
   8++C037 00 00        SBnkTransmatRoofvY          DW 0                ; XX16+2
   9++C039 00 00        SBnkTransmatRoofvZ          DW 0                ; XX16+2
  10++C03B 00 00        SBnkTransmatNosevX          DW 0
  11++C03D              SBnkTransmatNosev           EQU SBnkTransmatNosevX
  12++C03D 00 00        SBnkTransmatNosevY          DW 0                ; XX16+2
  13++C03F 00 00        SBnkTransmatNosevZ          DW 0                ; XX16+2
  14++C041 00 00        SBnkTransmatTransX          DW 0
  15++C043 00 00        SBnkTransmatTransY          DW 0
  16++C045 00 00        SBnkTransmatTransZ          DW 0
  17++C047              SunXX16                      equ SBnkTransmatSidev
  18++C047              ;-- XX16Inv --------------------------------------------------------------------------------------------------------------------------
  19++C047 00 00        SBnkTransInvRow0x0          DW 0
  20++C049 00 00        SBnkTransInvRow0x1          DW 0
  21++C04B 00 00        SBnkTransInvRow0x2          DW 0
  22++C04D 00 00        SBnkTransInvRow0x3          DW 0
  23++C04F 00 00        SBnkTransInvRow1y0          DW 0
  24++C051 00 00        SBnkTransInvRow1y1          DW 0
  25++C053 00 00        SBnkTransInvRow1y2          DW 0
  26++C055 00 00        SBnkTransInvRow1y3          DW 0
  27++C057 00 00        SBnkTransInvRow2z0          DW 0
  28++C059 00 00        SBnkTransInvRow2z1          DW 0
  29++C05B 00 00        SBnkTransInvRow2z2          DW 0
  30++C05D 00 00        SBnkTransInvRow2z3          DW 0
  31++C05F
  32++C05F              SunXX16Inv             equ SBnkTransInvRow0x0
  33++C05F
# file closed: ././Universe/Sun/SunXX16Vars.asm
  43+ C05F                                      INCLUDE "./Universe/Sun/SunXX25Vars.asm"
# file opened: ././Universe/Sun/SunXX25Vars.asm
   1++C05F              ;-- XX25 --------------------------------------------------------------------------------------------------------------------------
   2++C05F 00           SBnKProjxLo                 DB  0
   3++C060 00           SBnKProjxHi                 DB  0
   4++C061 00           SBnKProjxSgn                DB  0
   5++C062              SBnKProjx                   EQU SBnKProjxLo
   6++C062 00           SBnKProjyLo                 DB  0
   7++C063 00           SBnKProjyHi                 DB  0
   8++C064 00           SBnKProjySgn                DB  0
   9++C065              SBnKProjy                   EQU SBnKProjyLo
  10++C065 00           SBnKProjzLo                 DB  0
  11++C066 00           SBnKProjzHi                 DB  0
  12++C067 00           SBnKProjzSgn                DB  0
  13++C068              SBnKProjz                   EQU SBnKProjzLo
  14++C068              SXX25                       EQU SBnKProjxLo
  15++C068
# file closed: ././Universe/Sun/SunXX25Vars.asm
  44+ C068                                      INCLUDE "./Universe/Sun/SunXX18Vars.asm"
# file opened: ././Universe/Sun/SunXX18Vars.asm
   1++C068              ;-- XX18 --------------------------------------------------------------------------------------------------------------------------
   2++C068 00           SBnKDrawCam0xLo             DB  0               ; XX18+0
   3++C069 00           SBnKDrawCam0xHi             DB  0               ; XX18+1
   4++C06A 00           SBnKDrawCam0xSgn            DB  0               ; XX18+2
   5++C06B              SBnKDrawCam0x               equ SBnKDrawCam0xLo
   6++C06B 00           SBnKDrawCam0yLo             DB  0               ; XX18+3
   7++C06C 00           SBnKDrawCam0yHi             DB  0               ; XX18+4
   8++C06D 00           SBnKDrawCam0ySgn            DB  0               ; XX18+5
   9++C06E              SBnKDrawCam0y               equ SBnKDrawCam0yLo
  10++C06E 00           SBnKDrawCam0zLo             DB  0               ; XX18+6
  11++C06F 00           SBnKDrawCam0zHi             DB  0               ; XX18+7
  12++C070 00           SBnKDrawCam0zSgn            DB  0               ; XX18+8
  13++C071              SBnKDrawCam0z               equ SBnKDrawCam0zLo
  14++C071              SXX18                       equ SBnKDrawCam0xLo
  15++C071
# file closed: ././Universe/Sun/SunXX18Vars.asm
  45+ C071
  46+ C071              ; Used to make 16 bit reads a little cleaner in source code
  47+ C071 00 00 00     SBnKzPoint                  DS  3
  48+ C074              SBnKzPointLo                equ SBnKzPoint
  49+ C074              SBnKzPointHi                equ SBnKzPoint+1
  50+ C074              SBnKzPointSign              equ SBnKzPoint+2
  51+ C074                                      INCLUDE "./Universe/Sun/SunXX15Vars.asm"
# file opened: ././Universe/Sun/SunXX15Vars.asm
   1++C074              ;-- XX15 --------------------------------------------------------------------------------------------------------------------------
   2++C074 00           SBnKXScaled                 DB  0               ; XX15+0Xscaled
   3++C075 00           SBnKXScaledSign             DB  0               ; XX15+1xsign
   4++C076 00           SBnKYScaled                 DB  0               ; XX15+2yscaled
   5++C077 00           SBnKYScaledSign             DB  0               ; XX15+3ysign
   6++C078 00           SBnKZScaled                 DB  0               ; XX15+4zscaled
   7++C079 00           SBnKZScaledSign             DB  0               ; XX15+5zsign
   8++C07A
   9++C07A              SXX15                       equ SBnKXScaled
  10++C07A              SXX15VecX                   equ SXX15
  11++C07A              SXX15VecY                   equ SXX15+1
  12++C07A              SXX15VecZ                   equ SXX15+2
  13++C07A              SBnKXPoint                  equ SXX15
  14++C07A              SBnKXPointLo                equ SXX15+0
  15++C07A              SBnKXPointHi                equ SXX15+1
  16++C07A              SBnKXPointSign              equ SXX15+2
  17++C07A              SBnKYPoint                  equ SXX15+3
  18++C07A              SBnKYPointLo                equ SXX15+3
  19++C07A              SBnKYPointHi                equ SXX15+4
  20++C07A              SBnKYPointSign              equ SXX15+5
  21++C07A
# file closed: ././Universe/Sun/SunXX15Vars.asm
  52+ C07A                                      INCLUDE "./Universe/Sun/SunXX12Vars.asm"
# file opened: ././Universe/Sun/SunXX12Vars.asm
   1++C07A              ;-- transmat0 --------------------------------------------------------------------------------------------------------------------------
   2++C07A              ; Note XX12 comes after as some logic in normal processing uses XX15 and XX12 combines
   3++C07A 00           SBnKXX12xLo                 DB  0               ; XX12+0
   4++C07B 00           SBnKXX12xSign               DB  0               ; XX12+1
   5++C07C 00           SBnKXX12yLo                 DB  0               ; XX12+2
   6++C07D 00           SBnKXX12ySign               DB  0               ; XX12+3
   7++C07E 00           SBnKXX12zLo                 DB  0               ; XX12+4
   8++C07F 00           SBnKXX12zSign               DB  0               ; XX12+5
   9++C080 00 00 00...  SXX12Save                   DS  6
  10++C086 00 00 00...  SXX12Save2                  DS  6
  11++C08C              SXX12                       equ SBnKXX12xLo
  12++C08C              varSXX12                    equ SBnKXX12xLo
  13++C08C              ; Repurposed XX12 when plotting lines
  14++C08C              SBnkY2                      equ SXX12+0
  15++C08C              SbnKy2Lo                    equ SXX12+0
  16++C08C              SBnkY2Hi                    equ SXX12+1
  17++C08C              SBnkDeltaXLo                equ SXX12+2
  18++C08C              SBnkDeltaXHi                equ SXX12+3
  19++C08C              SBnkDeltaYLo                equ SXX12+4
  20++C08C              SBnkDeltaYHi                equ SXX12+5
  21++C08C              SbnkGradient                equ SXX12+2
  22++C08C              SBnkTemp1                   equ SXX12+2
  23++C08C              SBnkTemp1Lo                 equ SXX12+2
  24++C08C              SBnkTemp1Hi                 equ SXX12+3
  25++C08C              SBnkTemp2                   equ SXX12+3
  26++C08C              SBnkTemp2Lo                 equ SXX12+3
  27++C08C              SBnkTemp2Hi                 equ SXX12+4
  28++C08C
# file closed: ././Universe/Sun/SunXX12Vars.asm
  53+ C08C
  54+ C08C
  55+ C08C              ; Post clipping the results are now 8 bit
  56+ C08C 00           SBnKVisibility              DB  0               ; replaces general purpose xx4 in rendering
  57+ C08D 00           SBnKProjectedY              DB  0
  58+ C08E 00           SBnKProjectedX              DB  0
  59+ C08F              SBnKProjected               equ SBnKProjectedY  ; resultant projected position
  60+ C08F 00 00 00...  SunXX15Save                 DS  8
  61+ C097 00 00 00...  SunXX15Save2                DS  8
  62+ C09F              ; Heap (or array) information for lines and normals
  63+ C09F              ; Coords are stored XY,XY,XY,XY
  64+ C09F              ; Normals
  65+ C09F              ; This needs re-oprganising now.
  66+ C09F              ; Runtime Calculation Store
  67+ C09F
  68+ C09F              SunLineArraySize            equ 128 * 2
  69+ C09F              ; Storage arrays for data
  70+ C09F
  71+ C09F 00 00 00...  SBnKLineArray               DS SunLineArraySize ; XX19 Holds the clipped line details
  72+ C19F              SBnKLinesHeapMax            EQU $ - SBnKLineArray
  73+ C19F
  74+ C19F 00 00        LineArrayPtr                DW  0
  75+ C1A1
  76+ C1A1              SBnK_Data_len               EQU $ - SBnKDataBlock
  77+ C1A1
  78+ C1A1              ; --------------------------------------------------------------
  79+ C1A1 21 10 C0     ResetSBnKData:          ld      hl,SBnKDataBlock
  80+ C1A4 11 91 01                             ld      de,SBnK_Data_len
  81+ C1A7 AF                                   xor     a
  82+ C1A8 CD 65 80                             call    memfill_dma
  83+ C1AB C9                                   ret
  84+ C1AC              ; --------------------------------------------------------------
  85+ C1AC 21 10 C0     ResetSBnKPosition:      ld      hl,SBnKxlo
  86+ C1AF 06 09                                ld      b, 3*3
  87+ C1B1 AF                                   xor     a
  88+ C1B2 77           .zeroLoop:              ld      (hl),a
  89+ C1B3 23                                   inc     hl
  90+ C1B4 10 FC                                djnz    .zeroLoop
  91+ C1B6 C9                                   ret
  92+ C1B7              ; This uses UBNKNodeArray as the list
  93+ C1B7              ; the array is 256 * 2 bytes
  94+ C1B7              ; counter is current row y pos
  95+ C1B7              ; byte 1 is start x pos
  96+ C1B7              ; byte 2 is end x pos
  97+ C1B7              ; if they are both 0 then skip
  98+ C1B7              ; its always horizontal, yellow
  99+ C1B7
 100+ C1B7              ; PLANET
 101+ C1B7
 102+ C1B7
 103+ C1B7              .SunNoDraw:             SetCarryFlag                    ; ship is behind so do not draw, so we don't care abour draw as dot
 103+ C1B7 37          >                        scf
 104+ C1B8 C9                                   ret
 105+ C1B9
 106+ C1B9
 107+ C1B9
 108+ C1B9              SunBankDraw:            MACRO
 109+ C1B9 ~            .drawLoop               ld      a,(hl)
 110+ C1B9 ~                                    ld      c,a                     ; c = left column
 111+ C1B9 ~                                    inc     hl
 112+ C1B9 ~                                    ld      d,(hl)                  ; d = right col
 113+ C1B9 ~                                    inc     hl                      ; now ready for next linel
 114+ C1B9 ~                                    push    hl,,bc
 115+ C1B9 ~                                    cp      d                       ; if both points are the same then no line (we will ignore single pixel as it can't happen at this stage other than tips of circles)
 116+ C1B9 ~                                    IfResultZeroGoto .NoLineDraw
 117+ C1B9 ~                                    ld      a,d                     ; get right col back
 118+ C1B9 ~                                    sub     c                       ; subtract left so a = length
 119+ C1B9 ~                                    inc     a                       ; so its at least 1 , TODO add cp jr c logic in dma routine so that it does non dma if line < x
 120+ C1B9 ~                                    call    z, .FixWidth
 121+ C1B9 ~                                    ld      d,a                     ; de = length (e - d)
 122+ C1B9 ~                                    ld      e,216                   ; yellow
 123+ C1B9 ~                                    call    l2_draw_horz_dma        ; draw without bank switch
 124+ C1B9 ~            .NoLineDraw:            pop     hl,,bc
 125+ C1B9 ~                                    inc     b
 126+ C1B9 ~                                    dec     iyh
 127+ C1B9 ~                                    IfResultNotZeroGoto  .drawLoop
 128+ C1B9                                      ENDM
 129+ C1B9
 130+ C1B9
 131+ C1B9
 132+ C1B9              SunDraw:                MMUSelectLayer2
 132+ C1B9 ED 91 57 39 >					 nextreg L2memMMU,		    BankLAYER2
 133+ C1BD 3A 56 C5     .OptimiseStartPos:      ld      a,(MinYOffset)
 134+ C1C0                                      JumpIfAIsZero .OffsetIsZero     ; if offset is 0 then just initate as normal
 134+ C1C0 A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
 134+ C1C1 CA D1 C1    >                        jp	z, .OffsetIsZero
 135+ C1C4                                      JumpIfALTNusng 64, .OffsetLT64  ; if offset >=64 then we adjust and mve to bank 0
 135+ C1C4 FE 40       >                        cp      64
 135+ C1C6 DA DE C1    >                        jp		c, .OffsetLT64
 136+ C1C9 D6 40        .OffsetGTE64:           sub     64
 137+ C1CB 32 56 C5                             ld      (MinYOffset),a          ; adjust offset for bank 2
 138+ C1CE C3 16 C2                             jp      .StartBank2
 139+ C1D1 06 00        .OffsetIsZero:          ld      b,0                     ; row
 140+ C1D3 FD 26 40                             ld      iyh,64                  ; counter
 141+ C1D6 21 9F C0                             ld      hl,SBnKLineArray        ; set hl to start of array
 142+ C1D9 C3 F0 C1                             jp      .StartBank1
 143+ C1DC              ;-- Snuck routine in here so that the macro will be happier
 144+ C1DC 3D           .FixWidth:              dec     a                       ; if carry resulted in a value of zero then correct
 145+ C1DD C9                                   ret
 146+ C1DE 21 9F C0     .OffsetLT64:            ld      hl,SBnKLineArray        ; adjust hl for line array offset
 147+ C1E1 ED 31                                add     hl,a                    ; .
 148+ C1E3 ED 31                                add     hl,a                    ; .
 149+ C1E5 47                                   ld      b,a                     ; set b row to the actual offset
 150+ C1E6 4F                                   ld      c,a                     ; iyh = 64 - Y offset
 151+ C1E7 3E 40                                ld      a,64                    ; .
 152+ C1E9 91                                   sub     c                       ; .
 153+ C1EA FD 67                                ld      iyh,a
 154+ C1EC AF                                   xor     a                       ; Ready bank 2 with no offset
 155+ C1ED 32 56 C5                             ld      (MinYOffset),a          ; .
 156+ C1F0 D9           .StartBank1:            exx
 157+ C1F1 3E 00                                ld      a,LAYER2_SHIFTED_SCREEN_TOP
 158+ C1F3 CD 37 E0                             call    asm_l2_bank_select      ; get in the first bank, we will only then bank select when needed
 159+ C1F6 D9                                   exx
 160+ C1F7                                      SunBankDraw
 160+ C1F7 7E          >.drawLoop               ld      a,(hl)
 160+ C1F8 4F          >                        ld      c,a                     ; c = left column
 160+ C1F9 23          >                        inc     hl
 160+ C1FA 56          >                        ld      d,(hl)                  ; d = right col
 160+ C1FB 23          >                        inc     hl                      ; now ready for next linel
 160+ C1FC E5 C5       >                        push    hl,,bc
 160+ C1FE BA          >                        cp      d                       ; if both points are the same then no line (we will ignore single pixel as it can't happen at this stage other than tips of circles)
 160+ C1FF             >                        IfResultZeroGoto .NoLineDraw
 160+ C1FF CA 0E C2    >                        jp	z,.NoLineDraw
 160+ C202 7A          >                        ld      a,d                     ; get right col back
 160+ C203 91          >                        sub     c                       ; subtract left so a = length
 160+ C204 3C          >                        inc     a                       ; so its at least 1 , TODO add cp jr c logic in dma routine so that it does non dma if line < x
 160+ C205 CC DC C1    >                        call    z, .FixWidth
 160+ C208 57          >                        ld      d,a                     ; de = length (e - d)
 160+ C209 1E D8       >                        ld      e,216                   ; yellow
 160+ C20B CD 64 E2    >                        call    l2_draw_horz_dma        ; draw without bank switch
 160+ C20E C1 E1       >.NoLineDraw:            pop     hl,,bc
 160+ C210 04          >                        inc     b
 160+ C211 FD 25       >                        dec     iyh
 160+ C213             >                        IfResultNotZeroGoto  .drawLoop
 160+ C213 C2 F7 C1    >                        jp	nz,.drawLoop
 161+ C216 3A 56 C5     .StartBank2:            ld      a,(MinYOffset)
 162+ C219                                      JumpIfAIsZero .OffsetBank2IsZero; if offset is 0 then we just continue, offset can never be >127 else there would be no draw
 162+ C219 A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
 162+ C21A CA 2E C2    >                        jp	z, .OffsetBank2IsZero
 163+ C21D 21 1F C1     .NotZeroOffset:         ld      hl,SBnKLineArray + (64 * 2); adjust to correct offset
 164+ C220 ED 31                                add     hl,a
 165+ C222 ED 31                                add     hl,a
 166+ C224 4F                                   ld      c,a                     ; iyh = 64 - offset
 167+ C225 3E 40                                ld      a,64                    ; .
 168+ C227 91                                   sub     c                       ; .
 169+ C228 FD 67                                ld      iyh,a                   ; .
 170+ C22A 41                                   ld      b,c                     ; b = offset row
 171+ C22B C3 36 C2                             jp      .drawLineBank2
 172+ C22E 21 1F C1     .OffsetBank2IsZero:     ld      hl,SBnKLineArray + (64 * 2); start with offset adjusted
 173+ C231 06 00                                ld      b,0
 174+ C233 FD 26 40                             ld      iyh,64
 175+ C236 D9           .drawLineBank2:         exx
 176+ C237 3E 40                                ld      a,LAYER2_SHIFTED_SCREEN_MIDDLE
 177+ C239 CD 37 E0                             call    asm_l2_bank_select      ; now do the lower bank
 178+ C23C D9                                   exx
 179+ C23D              ; Could make this a sub routine but unwrapping saves a call
 180+ C23D                                      SunBankDraw
 180+ C23D 7E          >.drawLoop               ld      a,(hl)
 180+ C23E 4F          >                        ld      c,a                     ; c = left column
 180+ C23F 23          >                        inc     hl
 180+ C240 56          >                        ld      d,(hl)                  ; d = right col
 180+ C241 23          >                        inc     hl                      ; now ready for next linel
 180+ C242 E5 C5       >                        push    hl,,bc
 180+ C244 BA          >                        cp      d                       ; if both points are the same then no line (we will ignore single pixel as it can't happen at this stage other than tips of circles)
 180+ C245             >                        IfResultZeroGoto .NoLineDraw
 180+ C245 CA 54 C2    >                        jp	z,.NoLineDraw
 180+ C248 7A          >                        ld      a,d                     ; get right col back
 180+ C249 91          >                        sub     c                       ; subtract left so a = length
 180+ C24A 3C          >                        inc     a                       ; so its at least 1 , TODO add cp jr c logic in dma routine so that it does non dma if line < x
 180+ C24B CC DC C1    >                        call    z, .FixWidth
 180+ C24E 57          >                        ld      d,a                     ; de = length (e - d)
 180+ C24F 1E D8       >                        ld      e,216                   ; yellow
 180+ C251 CD 64 E2    >                        call    l2_draw_horz_dma        ; draw without bank switch
 180+ C254 C1 E1       >.NoLineDraw:            pop     hl,,bc
 180+ C256 04          >                        inc     b
 180+ C257 FD 25       >                        dec     iyh
 180+ C259             >                        IfResultNotZeroGoto  .drawLoop
 180+ C259 C2 3D C2    >                        jp	nz,.drawLoop
 181+ C25C C9                                   ret
 182+ C25D
 183+ C25D              ; --------------------------------------------------------------
 184+ C25D              ; This sets current universe object to a star / sun, they use sign + 23 bit positions
 185+ C25D CD A1 C1     CreateSun:              call    ResetSBnKData
 186+ C260 3A 5F 85                             ld      a,(WorkingSeeds+3)
 187+ C263 E6 07                                and     %00000111
 188+ C265 F6 81                                or      %10000001
 189+ C267 32 18 C0                             ld      (SBnKzsgn),a
 190+ C26A 3A 61 85                             ld      a,(WorkingSeeds+5)
 191+ C26D E6 03                                and     %00000011
 192+ C26F 32 12 C0                             ld      (SBnKxsgn),a
 193+ C272 32 15 C0                             ld      (SBnKysgn),a
 194+ C275                                   ; DEBUG   ld      hl, $0000
 195+ C275                                   ; DEBUG   ld      (SBnKzhi),hl
 196+ C275                                   ; DEBUG   ld      a, $E3
 197+ C275                                   ; DEBUG   ld      (SBnKzlo),a
 198+ C275 C9                                   ret
 199+ C276              ; --------------------------------------------------------------
 200+ C276              ; This sets current universe object to a planet,they use sign + 23 bit positions
 201+ C276              ;;TODOCreatePlanet:           call    ResetSBnKData
 202+ C276              ;;TODO                        ld      a,(DisplayTekLevel)
 203+ C276              ;;TODO                        and     $00000010               ; Set A = 128 or 130 depending on bit 1 of the system's tech level
 204+ C276              ;;TODO                        or      $10000000
 205+ C276              ;;TODO                        ld      (SBnKShipType),a
 206+ C276              ;;TODO                        xor     a
 207+ C276              ;;TODO                        ld      (SBnKaiatkecm),a
 208+ C276              ;;TODO                        MaxUnivPitchAndRoll
 209+ C276              ;;TODO                        ld      a,(WorkingSeeds+1)      ; a= bits 1 and 0 of working seed1 + 3 + carry
 210+ C276              ;;TODO                        and     %00000011               ; .
 211+ C276              ;;TODO                        adc     3                       ; .
 212+ C276              ;;TODO                        ld      (SBnKzsgn),a            ; set z sign to 3 + C + 0..3 bits
 213+ C276              ;;TODO                        rr      a
 214+ C276              ;;TODO                        ld      (PlanetXsgn),a
 215+ C276              ;;TODO                        ld      (PlanetYsgn),a
 216+ C276              ;;TODO                        ret
 217+ C276
 218+ C276
 219+ C276                                 ;     include "./Maths/ADDHLDESignBC.asm"
 220+ C276
 221+ C276 7C           SunADDHLDESignedv3:     ld      a,h
 222+ C277 E6 80                                and     SignOnly8Bit
 223+ C279 47                                   ld      b,a                         ;save sign bit in b
 224+ C27A AA                                   xor     d                           ;if h sign and d sign were different then bit 7 of a will be 1 which means
 225+ C27B                                      JumpIfNegative .SunADDHLDEOppSGN    ;Signs are opposite there fore we can subtract to get difference
 225+ C27B FA 96 C2    >                        jp		m, .SunADDHLDEOppSGN
 226+ C27E 78           .SunADDHLDESameSigns:   ld      a,b
 227+ C27F B2                                   or      d
 228+ C280                                      JumpIfNegative .SunADDHLDESameNeg   ; optimisation so we can just do simple add if both positive
 228+ C280 FA 88 C2    >                        jp		m, .SunADDHLDESameNeg
 229+ C283                                      JumpIfNegative .SunADDHLDESameNeg   ; optimisation so we can just do simple add if both positive
 229+ C283 FA 88 C2    >                        jp		m, .SunADDHLDESameNeg
 230+ C286 19                                   add     hl,de
 231+ C287 C9                                   ret
 232+ C288 7C           .SunADDHLDESameNeg:     ld      a,h                         ; so if we enter here then signs are the same so we clear the 16th bit
 233+ C289 E6 7F                                and     SignMask8Bit                ; we could check the value of b for optimisation
 234+ C28B 67                                   ld      h,a
 235+ C28C 7A                                   ld      a,d
 236+ C28D E6 7F                                and     SignMask8Bit
 237+ C28F 57                                   ld      d,a
 238+ C290 19                                   add     hl,de
 239+ C291 3E 80                                ld      a,SignOnly8Bit
 240+ C293 B4                                   or      h                           ; now set bit for negative value, we won't bother with overflow for now TODO
 241+ C294 67                                   ld      h,a
 242+ C295 C9                                   ret
 243+ C296 7C           .SunADDHLDEOppSGN:      ld      a,h                         ; so if we enter here then signs are the same so we clear the 16th bit                     ; here HL and DE are opposite
 244+ C297 E6 7F                                and     SignMask8Bit                ; we could check the value of b for optimisation
 245+ C299 67                                   ld      h,a
 246+ C29A 7A                                   ld      a,d
 247+ C29B E6 7F                                and     SignMask8Bit
 248+ C29D 57                                   ld      d,a
 249+ C29E B7                                   or      a
 250+ C29F ED 52                                sbc     hl,de
 251+ C2A1 38 04                                jr      c,.SunADDHLDEOppInvert
 252+ C2A3 78           .SunADDHLDEOppSGNNoCarry:   ld      a,b                         ; we got here so hl > de therefore we can just take hl's previous sign bit
 253+ C2A4 B4                                   or      h
 254+ C2A5 67                                   ld      h,a                         ; set the previou sign value
 255+ C2A6 C9                                   ret
 256+ C2A7              .SunADDHLDEOppInvert:       NegHL                                                   ; we need to flip the sign and 2'c the Hl result
 256+ C2A7 AF          >                    xor a
 256+ C2A8 95          >                    sub l
 256+ C2A9 6F          >                    ld l,a
 256+ C2AA 9F          >                    sbc a,a
 256+ C2AB 94          >                    sub h
 256+ C2AC 67          >                    ld h,a
 257+ C2AD 78                                   ld      a,b
 258+ C2AE EE 80                                xor     SignOnly8Bit                ; flip sign bit
 259+ C2B0 B4                                   or      h
 260+ C2B1 67                                   ld      h,a                         ; recover sign
 261+ C2B2 C9                                   ret
 262+ C2B3
 263+ C2B3              ; we could cheat, flip the sign of DE and just add but its not very optimised
 264+ C2B3 7C           .SunSUBHLDESignedv3:        ld      a,h
 265+ C2B4 E6 80                                and     SignOnly8Bit
 266+ C2B6 47                                   ld      b,a                         ;save sign bit in b
 267+ C2B7 AA                                   xor     d                           ;if h sign and d sign were different then bit 7 of a will be 1 which means
 268+ C2B8                                      JumpIfNegative .SunSUBHLDEOppSGN        ;Signs are opposite therefore we can add
 268+ C2B8 FA E6 C2    >                        jp		m, .SunSUBHLDEOppSGN
 269+ C2BB 78           .SunSUBHLDESameSigns:       ld      a,b
 270+ C2BC B2                                   or      d
 271+ C2BD                                      JumpIfNegative .SunSUBHLDESameNeg       ; optimisation so we can just do simple add if both positive
 271+ C2BD FA C7 C2    >                        jp		m, .SunSUBHLDESameNeg
 272+ C2C0 B7                                   or      a
 273+ C2C1 ED 52                                sbc     hl,de
 274+ C2C3                                      JumpIfNegative .SunSUBHLDESameOvrFlw
 274+ C2C3 FA DA C2    >                        jp		m, .SunSUBHLDESameOvrFlw
 275+ C2C6 C9                                   ret
 276+ C2C7 7C           .SunSUBHLDESameNeg:         ld      a,h                         ; so if we enter here then signs are the same so we clear the 16th bit
 277+ C2C8 E6 7F                                and     SignMask8Bit                ; we could check the value of b for optimisation
 278+ C2CA 67                                   ld      h,a
 279+ C2CB 7A                                   ld      a,d
 280+ C2CC E6 7F                                and     SignMask8Bit
 281+ C2CE 57                                   ld      d,a
 282+ C2CF B7                                   or      a
 283+ C2D0 ED 52                                sbc     hl,de
 284+ C2D2                                      JumpIfNegative .SunSUBHLDESameOvrFlw
 284+ C2D2 FA DA C2    >                        jp		m, .SunSUBHLDESameOvrFlw
 285+ C2D5 7C                                   ld      a,h                         ; now set bit for negative value, we won't bother with overflow for now TODO
 286+ C2D6 F6 80                                or      SignOnly8Bit
 287+ C2D8 67                                   ld      h,a
 288+ C2D9 C9                                   ret
 289+ C2DA              .SunSUBHLDESameOvrFlw:      NegHL                                                        ; we need to flip the sign and 2'c the Hl result
 289+ C2DA AF          >                    xor a
 289+ C2DB 95          >                    sub l
 289+ C2DC 6F          >                    ld l,a
 289+ C2DD 9F          >                    sbc a,a
 289+ C2DE 94          >                    sub h
 289+ C2DF 67          >                    ld h,a
 290+ C2E0 78                                   ld      a,b
 291+ C2E1 EE 80                                xor     SignOnly8Bit                ; flip sign bit
 292+ C2E3 B4                                   or      h
 293+ C2E4 67                                   ld      h,a                         ; recover sign
 294+ C2E5 C9                                   ret
 295+ C2E6 B7           .SunSUBHLDEOppSGN:          or      a                                               ; here HL and DE are opposite so we can add the values
 296+ C2E7 7C                                   ld      a,h                         ; so if we enter here then signs are the same so we clear the 16th bit
 297+ C2E8 E6 7F                                and     SignMask8Bit                ; we could check the value of b for optimisation
 298+ C2EA 67                                   ld      h,a
 299+ C2EB 7A                                   ld      a,d
 300+ C2EC E6 7F                                and     SignMask8Bit
 301+ C2EE 57                                   ld      d,a
 302+ C2EF 19                                   add     hl,de
 303+ C2F0 78                                   ld      a,b                         ; we got here so hl > de therefore we can just take hl's previous sign bit
 304+ C2F1 B4                                   or      h
 305+ C2F2 67                                   ld      h,a                         ; set the previou sign value
 306+ C2F3 C9                                   ret
 307+ C2F4
 308+ C2F4
 309+ C2F4              .SunSBCHLDESigned:      JumpOnBitSet h,7,.SunSBCHLDEhlNeg
 309+ C2F4 CB 7C       >                        bit 	7,h
 309+ C2F6 C2 07 C3    >                        jp      nz,.SunSBCHLDEhlNeg
 310+ C2F9              .SunSBCHLDEhlPos:       JumpOnBitSet h,7,.SunSBCHLDEhlNeg
 310+ C2F9 CB 7C       >                        bit 	7,h
 310+ C2FB C2 07 C3    >                        jp      nz,.SunSBCHLDEhlNeg
 311+ C2FE ED 52        .SunSBCHLDEhlPosDePos:  sbc     hl,de                           ; ignore overflow for now will sort later TODO
 312+ C300 C9                                   ret
 313+ C301 CB BA        .SunSBCHLDEhlPosDeNeg:  res     7,d
 314+ C303 19                                   add     hl,de                           ; ignore overflow for now will sort later TODO
 315+ C304 CB FA                                set     7,d
 316+ C306 C9                                   ret
 317+ C307 CB BC        .SunSBCHLDEhlNeg:       res     7,h
 318+ C309                                      JumpOnBitSet d,7,.SunSBCHLDEhlNegdeNeg
 318+ C309 CB 7A       >                        bit 	7,d
 318+ C30B C2 13 C3    >                        jp      nz,.SunSBCHLDEhlNegdeNeg
 319+ C30E ED 52        .SunSBCHLDEhlNegdePos:  sbc     hl,de                       ; ignore overflow for now will sort later TODO
 320+ C310 CB FC                                set     7,h
 321+ C312 C9                                   ret
 322+ C313 CB BA        .SunSBCHLDEhlNegdeNeg:      res     7,d
 323+ C315 19                                   add     hl,de                   ; ignore overflow for now will sort later TODO
 324+ C316 CB FA                                set     7,d
 325+ C318 CB FC                                set     7,h
 326+ C31A C9                                   ret
 327+ C31B
 328+ C31B
 329+ C31B                                      include "./Universe/Sun/TransposeSunXX12BySunToSunXX15.asm"
# file opened: ././Universe/Sun/TransposeSunXX12BySunToSunXX15.asm
   1++C31B              TransposeSXX12BySunToSXX15:
   2++C31B 2A 7A C0                             ld		hl,(SBnKXX12xLo)					; get X into HL
   3++C31E 7C                                   ld		a,h			                        ; get XX12 Sign
   4++C31F E6 80                                and		$80									; check sign bit on high byte
   5++C321 47                                   ld		b,a									; and put it in of 12xlo in b
   6++C322                                      ;110921 debugld      h,0
   7++C322 7C                                   ld      a,h
   8++C323 E6 7F                                and     $7F
   9++C325 67                                   ld      h,a
  10++C326                                      ;110921 debugld      h,0
  11++C326 ED 5B 10 C0                          ld		de,(SBnKxlo)						;
  12++C32A 3A 12 C0                             ld		a,(SBnKxsgn)						; get Ship Pos (low,high,sign)
  13++C32D E6 80                                and		$80									; make sure we only have bit 7
  14++C32F 4F                                   ld		c,a									; and put sign of unkxsgn c
  15++C330 CD 9E 99                             call 	ADDHLDESignBC; XX12ProcessCalcHLPlusDESignBC		; this will result in HL = result and A = sign
  16++C333 B4                                   or		h									; combine sign in A with H to give 15 bit signed (*NOT* 2's c)
  17++C334 67                                   ld		h,a
  18++C335 22 74 C0                             ld		(SBnKXScaled),hl					; now write it out to XX15 X pos
  19++C338              ; ..................................
  20++C338 2A 7C C0                             ld		hl,(SBnKXX12yLo)					; Repeat above for Y coordinate
  21++C33B 7C                                   ld		a,h
  22++C33C E6 80                                and		$80
  23++C33E 47                                   ld		b,a
  24++C33F                                      ;110921 debugld      h,0
  25++C33F 7C                                   ld      a,h
  26++C340 E6 7F                                and     $7F
  27++C342 67                                   ld      h,a
  28++C343                                      ;110921 debugld      h,0
  29++C343 ED 5B 13 C0                          ld		de,(SBnKylo)
  30++C347 3A 15 C0                             ld		a,(SBnKysgn)
  31++C34A E6 80                                and		$80									; make sure we only have bit 7
  32++C34C 4F                                   ld		c,a
  33++C34D CD 9E 99                             call 	ADDHLDESignBC; XX12ProcessCalcHLPlusDESignBC
  34++C350 B4                                   or		h									; combine sign in A with H
  35++C351 67                                   ld		h,a
  36++C352 22 76 C0                             ld		(SBnKYScaled),hl
  37++C355              ; ..................................
  38++C355 2A 7E C0                             ld		hl,(SBnKXX12zLo)					; and now repeat for Z cooord
  39++C358 7C                                   ld		a,h
  40++C359 E6 80                                and		$80
  41++C35B 47                                   ld		b,a
  42++C35C                                      ;110921 debugld      h,0
  43++C35C 7C                                   ld      a,h
  44++C35D E6 7F                                and     $7F
  45++C35F 67                                   ld      h,a
  46++C360                                      ;110921 debugld      h,0
  47++C360 ED 5B 16 C0                          ld		de,(SBnKzlo)
  48++C364 3A 18 C0                             ld		a,(SBnKzsgn)
  49++C367 E6 80                                and		$80									; make sure we only have bit 7
  50++C369 4F                                   ld		c,a
  51++C36A CD 9E 99                             call 	ADDHLDESignBC; XX12ProcessCalcHLPlusDESignBC
  52++C36D B4                                   or		h									; combine sign in A with H
  53++C36E 67                                   ld		h,a
  54++C36F CB 7C                                bit		7,h                                 ; if sign if positive then we don't need to do the clamp so we ony jump
  55++C371 20 16                                jr		nz,.ClampZto4                        ; result was negative so we need to clamp to 4
  56++C373 E6 7F                                and     $7F                                 ; a = value unsigned
  57++C375 20 06                                jr      nz,.NoClampZto4                      ; if high byte was 0 then we could need to clamp still by this stage its +v but and will set z flag if high byte is zero
  58++C377 7D                                   ld      a,l                                 ; get low byte now
  59++C378                                      JumpIfALTNusng 4,.ClampZto4					; if its < 4 then fix at 4
  59++C378 FE 04       >                        cp      4
  59++C37A DA 89 C3    >                        jp		c, .ClampZto4
  60++C37D 22 78 C0     .NoClampZto4:           ld		(SBnKZScaled),hl					; hl = signed calculation and > 4
  61++C380 7D                                   ld		a,l									; in addition write out the z cooord to UT for now for backwards compat (DEBUG TODO remove later)
  62++C381 32 82 84                             ld      (varT),a
  63++C384 7C                                   ld		a,h
  64++C385 32 65 84                             ld      (varU),a
  65++C388 C9                                   ret
  66++C389              ; This is where we limit 4 to a minimum of 4
  67++C389 21 04 00     .ClampZto4:             ld		hl,4
  68++C38C 22 78 C0                             ld		(SBnKZScaled),hl; BODGE FOR NOW
  69++C38F 7D                                   ld		a,l
  70++C390 32 82 84                             ld      (varT),a                            ;                                                                           ;;;
  71++C393 7C                                   ld		a,h
  72++C394 32 65 84                             ld      (varU),a 						; compatibility for now
  73++C397 C9                                   ret
  74++C398
# file closed: ././Universe/Sun/TransposeSunXX12BySunToSunXX15.asm
 330+ C398
 331+ C398
 332+ C398 ED 4B 78 C0  ScaleSunTo8Bit:			ld			bc,(SBnKZScaled)
 333+ C39C 2A 74 C0                             ld			hl,(SBnKXScaled)
 334+ C39F ED 5B 76 C0                          ld			de,(SBnKYScaled)
 335+ C3A3 78           .SetABSbc:              ld			a,b
 336+ C3A4 DD 67                                ld			ixh,a
 337+ C3A6 E6 7F                                and			SignMask8Bit
 338+ C3A8 47                                   ld			b,a									; bc = ABS bc
 339+ C3A9 7C           .SetABShl:              ld			a,h
 340+ C3AA DD 6F                                ld			ixl,a
 341+ C3AC E6 7F                                and			SignMask8Bit
 342+ C3AE 67                                   ld			h,a									; hl = ABS hl
 343+ C3AF 7A           .SetABSde:              ld			a,d
 344+ C3B0 FD 67                                ld			iyh,a
 345+ C3B2 E6 7F                                and			SignMask8Bit
 346+ C3B4 57                                   ld			d,a									; de = ABS de
 347+ C3B5 78           .ScaleNodeTo8BitLoop:   ld          a,b		                            ; U	\ z hi
 348+ C3B6 B4                                   or			h                                   ; XX15+1	\ x hi
 349+ C3B7 B2                                   or			d                                   ; XX15+4	\ y hi
 350+ C3B8 28 0F                                jr          z,.ScaleNodeDone                   ; if X, Y, Z = 0  exit loop down once hi U rolled to 0
 351+ C3BA                                      ShiftHLRight1
 351+ C3BA CB 3C       >			   srl h
 351+ C3BC CB 1D       >			   rr  l
 352+ C3BE                                      ShiftDERight1
 352+ C3BE CB 3A       >			   srl d
 352+ C3C0 CB 1B       >			   rr  e
 353+ C3C2                                      ShiftBCRight1
 353+ C3C2 CB 38       >			   srl b
 353+ C3C4 CB 19       >			   rr  c
 354+ C3C6 C3 B5 C3                             jp          .ScaleNodeTo8BitLoop
 355+ C3C9              ; now we have scaled values we have to deal with sign
 356+ C3C9 DD 7C        .ScaleNodeDone:          ld			a,ixh								; get sign bit and or with b
 357+ C3CB E6 80                                and			SignOnly8Bit
 358+ C3CD B0                                   or			b
 359+ C3CE 47                                   ld			b,a
 360+ C3CF DD 7D        .SignforHL:              ld			a,ixl								; get sign bit and or with b
 361+ C3D1 E6 80                                and			SignOnly8Bit
 362+ C3D3 B4                                   or			h
 363+ C3D4 67                                   ld			h,a
 364+ C3D5 FD 7C        .SignforDE:              ld			a,iyh								; get sign bit and or with b
 365+ C3D7 E6 80                                and			SignOnly8Bit
 366+ C3D9 B2                                   or			d
 367+ C3DA 57                                   ld			d,a
 368+ C3DB ED 43 78 C0  .SignsDoneSaveResult:	ld			(SBnKZScaled),bc
 369+ C3DF 22 74 C0                             ld			(SBnKXScaled),hl
 370+ C3E2 ED 53 76 C0                          ld			(SBnKYScaled),de
 371+ C3E6 78                                   ld			a,b
 372+ C3E7 32 65 84                             ld			(varU),a
 373+ C3EA 79                                   ld			a,c
 374+ C3EB 32 82 84                             ld			(varT),a
 375+ C3EE C9                                   ret
 376+ C3EF
 377+ C3EF              ;--------------------------------------------------------------------------------------------------------
 378+ C3EF              ;;;;X = normal scale
 379+ C3EF              ;;;;ZtempHi = zhi
 380+ C3EF              ;;;;......................................................
 381+ C3EF              ;;;; if ztemp hi <> 0                                   ::Scale Object Distance
 382+ C3EF              ;;;;  Loop                                              ::LL90
 383+ C3EF              ;;;;     inc X
 384+ C3EF              ;;;;     divide X, Y & ZtempHiLo by 2
 385+ C3EF              ;;;;  Until ZtempHi = 0
 386+ C3EF              ;;;;......................................................
 387+ C3EF              ;-LL21---------------------------------------------------------------------------------------------------
 388+ C3EF              ;                        include "./Universe/NormaliseTransMat.asm"
 389+ C3EF              ;-LL91---------------------------------------------------------------------------------------------------
 390+ C3EF
 391+ C3EF              ; Now we have
 392+ C3EF              ;   * XX18(2 1 0) = (x_sign x_hi x_lo)
 393+ C3EF              ;   * XX18(5 4 3) = (y_sign y_hi y_lo)
 394+ C3EF              ;   * XX18(8 7 6) = (z_sign z_hi z_lo)
 395+ C3EF              ;
 396+ C3EF              ;--------------------------------------------------------------------------------------------------------
 397+ C3EF              ;--------------------------------------------------------------------------------------------------------
 398+ C3EF              ;   XX12(1 0) = [x y z] . sidev  = (dot_sidev_sign dot_sidev_lo)  = dot_sidev
 399+ C3EF              ;   XX12(3 2) = [x y z] . roofv  = (dot_roofv_sign dot_roofv_lo)  = dot_roofv
 400+ C3EF              ;   XX12(5 4) = [x y z] . nosev  = (dot_nosev_sign dot_nosev_lo)  = dot_nosev
 401+ C3EF              ; Returns
 402+ C3EF              ;
 403+ C3EF              ;   XX12(1 0)            The dot product of [x y z] vector with the sidev (or _x)
 404+ C3EF              ;                        vector, with the sign in XX12+1 and magnitude in XX12
 405+ C3EF              ;
 406+ C3EF              ;   XX12(3 2)            The dot product of [x y z] vector with the roofv (or _y)
 407+ C3EF              ;                        vector, with the sign in XX12+3 and magnitude in XX12+2
 408+ C3EF              ;
 409+ C3EF              ;   XX12(5 4)            The dot product of [x y z] vector with the nosev (or _z)
 410+ C3EF              ;                        vector, with the sign in XX12+5 and magnitude in XX12+4
 411+ C3EF
 412+ C3EF
 413+ C3EF               ; TESTEDOK
 414+ C3EF              SXX12DotOneRow:
 415+ C3EF              SXX12CalcX:              N0equN1byN2div256 varT, (hl), (SBnKXScaled)       ; T = (hl) * regSunXX15fx /256
 415+ C3EF 3A 74 C0    >                        ld      a,(SBnKXScaled)                        ;
 415+ C3F2 5F          >                        ld      e,a                         ; use e as var Q = value of XX15 [n] lo
 415+ C3F3 7E          >                        ld      a,(hl)                        ; A = XX16 element
 415+ C3F4 57          >                        ld      d,a
 415+ C3F5 ED 30       >                        mul
 415+ C3F7 7A          >                        ld      a,d                         ; we get only the high byte which is like doing a /256 if we think of a as low
 415+ C3F8 32 82 84    >                        ld      (varT),a                      ; Q         ; result variable = XX16[n] * XX15[n]/256
 416+ C3FB 23                                   inc     hl                                  ; move to sign byte
 417+ C3FC              SXX12CalcXSign:          AequN1xorN2 SBnKXScaledSign,(hl)             ;
 417+ C3FC 3A 75 C0    >                        ld      a,(SBnKXScaledSign)
 417+ C3FF AE          >                        xor     (hl)
 418+ C400 32 68 84                             ld      (varS),a                            ; Set S to the sign of x_sign * sidev_x
 419+ C403 23                                   inc     hl
 420+ C404              SXX12CalcY:              N0equN1byN2div256 varQ, (hl),(SBnKYScaled)       ; Q = XX16 * SunXX15 /256 using varQ to hold regSunXX15fx
 420+ C404 3A 76 C0    >                        ld      a,(SBnKYScaled)                        ;
 420+ C407 5F          >                        ld      e,a                         ; use e as var Q = value of XX15 [n] lo
 420+ C408 7E          >                        ld      a,(hl)                        ; A = XX16 element
 420+ C409 57          >                        ld      d,a
 420+ C40A ED 30       >                        mul
 420+ C40C 7A          >                        ld      a,d                         ; we get only the high byte which is like doing a /256 if we think of a as low
 420+ C40D 32 66 84    >                        ld      (varQ),a                      ; Q         ; result variable = XX16[n] * XX15[n]/256
 421+ C410                                      ldCopyByte varT,varR                        ; R = T =  |sidev_x| * x_lo / 256
 421+ C410 3A 82 84    >                        ld       a,(varT)
 421+ C413 32 67 84    >                        ld       (varR),a
 422+ C416 23                                   inc     hl
 423+ C417                                      AequN1xorN2 SBnKYScaledSign,(hl)             ; Set A to the sign of y_sign * sidev_y
 423+ C417 3A 77 C0    >                        ld      a,(SBnKYScaledSign)
 423+ C41A AE          >                        xor     (hl)
 424+ C41B              ; (S)A = |sidev_x| * x_lo / 256  = |sidev_x| * x_lo + |sidev_y| * y_lo
 425+ C41B E5           SSTequSRplusAQ           push    hl
 426+ C41C CD BC 9A                             call    baddll38                            ; JSR &4812 \ LL38   \ BADD(S)A=R+Q(SA) \ 1byte add (subtract)
 427+ C41F E1                                   pop     hl
 428+ C420 32 82 84                             ld      (varT),a                            ; T = |sidev_x| * x_lo + |sidev_y| * y_lo
 429+ C423 23                                   inc     hl
 430+ C424              SXX12CalcZ:              N0equN1byN2div256 varQ,(hl),(SBnKZScaled)       ; Q = |sidev_z| * z_lo / 256
 430+ C424 3A 78 C0    >                        ld      a,(SBnKZScaled)                        ;
 430+ C427 5F          >                        ld      e,a                         ; use e as var Q = value of XX15 [n] lo
 430+ C428 7E          >                        ld      a,(hl)                        ; A = XX16 element
 430+ C429 57          >                        ld      d,a
 430+ C42A ED 30       >                        mul
 430+ C42C 7A          >                        ld      a,d                         ; we get only the high byte which is like doing a /256 if we think of a as low
 430+ C42D 32 66 84    >                        ld      (varQ),a                      ; Q         ; result variable = XX16[n] * XX15[n]/256
 431+ C430                                      ldCopyByte varT,varR                        ; R = |sidev_x| * x_lo + |sidev_y| * y_lo
 431+ C430 3A 82 84    >                        ld       a,(varT)
 431+ C433 32 67 84    >                        ld       (varR),a
 432+ C436 23                                   inc     hl
 433+ C437                                      AequN1xorN2 SBnKZScaledSign,(hl)             ; A = sign of z_sign * sidev_z
 433+ C437 3A 79 C0    >                        ld      a,(SBnKZScaledSign)
 433+ C43A AE          >                        xor     (hl)
 434+ C43B              ; (S)A= |sidev_x| * x_lo + |sidev_y| * y_lo + |sidev_z| * z_lo
 435+ C43B CD BC 9A                             call    baddll38                            ; JSR &4812 \ LL38   \ BADD(S)A=R+Q(SA)   \ 1byte add (subtract)
 436+ C43E              ; Now we exit with A = result S = Sign
 437+ C43E C9                                   ret
 438+ C43F
 439+ C43F
 440+ C43F
 441+ C43F              ;--------------------------------------------------------------------------------------------------------
 442+ C43F                                      include "./Universe/Sun/CopySunXX12ScaledToSunXX18.asm"
# file opened: ././Universe/Sun/CopySunXX12ScaledToSunXX18.asm
   1++C43F              CopySXX12ScaledToSXX18:
   2++C43F              CopyResultToSDrawCam:
   3++C43F                      ldCopyByte SXX12         ,SXX18             ; XX12+0 => XX18+0  Set XX18(2 0) = dot_sidev
   3++C43F 3A 7A C0    >                        ld       a,(SXX12)
   3++C442 32 68 C0    >                        ld       (SXX18),a
   4++C445                      ldCopyByte SXX12+1       ,SXX18+2           ; XX12+1 => XX18+2
   4++C445 3A 7B C0    >                        ld       a,(SXX12+1)
   4++C448 32 6A C0    >                        ld       (SXX18+2),a
   5++C44B                      ldCopyByte SXX12+2       ,SXX18+3           ; XX12+2 => XX18+3  Set XX12+1 => XX18+2
   5++C44B 3A 7C C0    >                        ld       a,(SXX12+2)
   5++C44E 32 6B C0    >                        ld       (SXX18+3),a
   6++C451                      ldCopyByte SXX12+3       ,SXX18+5           ; XX12+3 => XX18+5
   6++C451 3A 7D C0    >                        ld       a,(SXX12+3)
   6++C454 32 6D C0    >                        ld       (SXX18+5),a
   7++C457                      ldCopyByte SXX12+4       ,SXX18+6           ; XX12+4 => XX18+6  Set XX18(8 6) = dot_nosev
   7++C457 3A 7E C0    >                        ld       a,(SXX12+4)
   7++C45A 32 6E C0    >                        ld       (SXX18+6),a
   8++C45D                      ldCopyByte SXX12+5       ,SXX18+8           ; XX12+5 => XX18+8
   8++C45D 3A 7F C0    >                        ld       a,(SXX12+5)
   8++C460 32 70 C0    >                        ld       (SXX18+8),a
   9++C463 C9                   ret
  10++C464
# file closed: ././Universe/Sun/CopySunXX12ScaledToSunXX18.asm
 443+ C464              ;                        include "./Variables/CopySunXX12toSunXX15.asm"
 444+ C464              ;                       include "./Variables/CopySunXX18toSunXX15.asm"
 445+ C464              ;                       include "./Variables/CopySunXX18ScaledToSunXX15.asm"
 446+ C464              ;                       include "./Variables/CopySunXX12ToScaled.asm"
 447+ C464              ;--------------------------------------------------------------------------------------------------------
 448+ C464              ;                        include "./Maths/Utilities/DotProductXX12SunXX15.asm"
 449+ C464              ;--------------------------------------------------------------------------------------------------------
 450+ C464
 451+ C464 DD 25        ScaleDownSXX15byIXH:    dec     ixh
 452+ C466 F8                                   ret     m
 453+ C467 21 74 C0                             ld      hl,SBnKXScaled
 454+ C46A CB 3E                                srl     (hl)                        ; SunXX15  \ xnormal lo/2 \ LL93+3 \ counter X
 455+ C46C 23                                   inc     hl                          ; looking at SunXX15 x sign now
 456+ C46D 23                                   inc     hl                          ; looking at SunXX15 y Lo now
 457+ C46E CB 3E                                srl     (hl)                        ; SunXX15+2    \ ynormal lo/2
 458+ C470 23                                   inc     hl                          ; looking at SunXX15 y sign now
 459+ C471 23                                   inc     hl                          ; looking at SunXX15 z Lo now
 460+ C472 CB 3E                                srl     (hl)
 461+ C474 C3 64 C4                             jp      ScaleDownSXX15byIXH
 462+ C477 C9                                   ret
 463+ C478
 464+ C478 21 68 C0     DivideSXX18By2:         ld      hl,SBnKDrawCam0xLo
 465+ C47B CB 3E                                srl     (hl)                        ; XX18  \ xnormal lo/2 \ LL93+3 \ counter X
 466+ C47D 23                                   inc     hl                          ; looking at XX18 x sign now
 467+ C47E 23                                   inc     hl                          ; looking at XX18 y Lo now
 468+ C47F CB 3E                                srl     (hl)                        ; XX18+2    \ ynormal lo/2
 469+ C481 23                                   inc     hl                          ; looking at XX18 y sign now
 470+ C482 23                                   inc     hl                          ; looking at XX18 z Lo now
 471+ C483 CB 3E                                srl     (hl)
 472+ C485 C9                                   ret
 473+ C486
 474+ C486              ; ......................................................                                                         ;;;
 475+ C486
 476+ C486
 477+ C486
 478+ C486
 479+ C486              ; Pitch and roll are 2 phases
 480+ C486              ; 1 - we apply our pitch and roll to the ship position
 481+ C486              ;       x -> x + alpha * (y - alpha * x)
 482+ C486              ;       y -> y - alpha * x - beta * z
 483+ C486              ;       z -> z + beta * (y - alpha * x - beta * z)
 484+ C486              ; which can be simplified as:
 485+ C486              ;       1. K2 = y - alpha * x
 486+ C486              ;       2. z = z + beta * K2
 487+ C486              ;       3. y = K2 - beta * z
 488+ C486              ;       4. x = x + alpha * y
 489+ C486              ; 2 - we apply our patch and roll to the ship orientation
 490+ C486              ;      Roll calculations:
 491+ C486              ;
 492+ C486              ;        nosev_y = nosev_y - alpha * nosev_x_hi
 493+ C486              ;        nosev_x = nosev_x + alpha * nosev_y_hi
 494+ C486              ;      Pitch calculations:
 495+ C486              ;
 496+ C486              ;        nosev_y = nosev_y - beta * nosev_z_hi
 497+ C486              ;        nosev_z = nosev_z + beta * nosev_y_hi
 498+ C486
 499+ C486
 500+ C486                          INCLUDE "./Universe/Sun/SunApplyMyRollAndPitch.asm"
# file opened: ././Universe/Sun/SunApplyMyRollAndPitch.asm
   1++C486
   2++C486              ; Full version
   3++C486              ; 1. K2 = y - alpha * x
   4++C486              ; 2. z = z + beta * K2
   5++C486              ; 3. y = K2 - beta * z
   6++C486              ; 4. x = x + alpha * y
   7++C486
   8++C486
   9++C486
  10++C486              ; SunrollWork holds Alpha intermidate results
  11++C486 00 00 00     SunRollResult:          DS 3                    ; equivalent of K
  12++C489              SunRollResultp1         equ SunRollResult
  13++C489              SunRollResultp2         equ SunRollResult+1
  14++C489              SunRollResultp3         equ SunRollResult+2
  15++C489 00           SunRollResultp4         DB 0
  16++C48A              ;SunRollResult2:         DS 3                    ; do we need this? TODO
  17++C48A 00 00 00     SunZResult:             DS 3
  18++C48D              ;  1. K2 = y - alpha * x
  19++C48D              ;  2. z = z + beta * K2
  20++C48D              ;  3. y = K2 - beta * z
  21++C48D              ;  4. x = x + alpha * y
  22++C48D              ;.... or
  23++C48D              ;  2. z = z + (beta * (y - alpha * x))
  24++C48D              ;  3. y = (y - alpha * x) - (beta * z)
  25++C48D              ;  4. x = x + (alpha * y)
  26++C48D
  27++C48D
  28++C48D              ;----------------------------------------------------------------------------------------------------------------------------------
  29++C48D              ; Sun version of pitch and roll is a 24 bit calculation 1 bit sign + 23 bit value
  30++C48D 3A 7C 83     SunApplyMyRollAndPitch: ld      a,(ALPHA)                   ; no roll or pitch, no calc needed
  31++C490 21 6E 83                             ld      hl,BETA
  32++C493 B6                                   or      (hl)
  33++C494 E6 7F                                and     SignMask8Bit
  34++C496 CA 32 C5                             jp      z,.NoRotation
  35++C499              .CalcZ:                 ;break
  36++C499 3A 7C 83                             ld      a,(ALPHA)                   ; get roll magnitude
  37++C49C FE 00                                cp      0
  38++C49E 20 0B                                jr      nz,.ApplyAlpha
  39++C4A0 ED 5B 14 C0  .NoAlpha:               ld      de,(SBnKyhi)                ; here we have no roll so
  40++C4A4 3A 13 C0                             ld      a,(SBnKylo)                 ; store untouched in SunRollResult
  41++C4A7 6F                                   ld      l,a                         ; .
  42++C4A8 C3 C7 C4                             jp      .SaveResult1                ; .
  43++C4AB EE 80        .ApplyAlpha:            xor     SignOnly8Bit                ; d = -alpha (Q value)
  44++C4AD 57                                   ld      d,a                         ;
  45++C4AE 3A 10 C0                             ld      a,(SBnKxlo)                 ; HLE = x sgn, hi, lo
  46++C4B1 5F                                   ld      e,a                         ; .
  47++C4B2 2A 11 C0                             ld      hl,(SBnKxhi)                ; .
  48++C4B5 CD 31 94                             call    mulHLEbyDSigned             ; DELC = x * -alpha, so DEL = X * -alpha / 256 where d = sign byte
  49++C4B8 7A           .SkipAlphaMultiply:     ld      a,d
  50++C4B9 32 89 C4                             ld      (SunRollResultp4),a         ; save sign from result, ELC holds actual result
  51++C4BC 3A 13 C0     .CalcYPlusDEL:          ld      a,(SBnKylo)                 ; BCH = Y sgn, hi, lo, we loose the C from result
  52++C4BF 67                                   ld      h,a                         ; .
  53++C4C0 ED 4B 14 C0                          ld      bc,(SBnKyhi)                ; .
  54++C4C4 CD C4 91                             call    AddBCHtoDELsigned           ; DEL = Y - ( X *  alpha /256) (which is K2)
  55++C4C7 7A           .SaveResult1:           ld      a,d                         ; SunPitchWork = AHL = DEL
  56++C4C8 63                                   ld      h,e                         ;
  57++C4C9 32 88 C4     .CopyResultTo2:         ld      (SunRollResult+2),a         ; .
  58++C4CC 22 86 C4                             ld      (SunRollResult) ,hl         ; .
  59++C4CF 5D           .CalcY:                 ld      e,l                         ; HLE = result (K2)
  60++C4D0 6C                                   ld      l,h                         ; .
  61++C4D1 67                                   ld      h,a                         ; .
  62++C4D2 3A 6E 83                             ld      a,(BETA)                    ; get pitch
  63++C4D5 57                                   ld      d,a                         ; now D = BETA
  64++C4D6 CD 31 94                             call    mulHLEbyDSigned             ; DELC = (y - alpha * x /256 ) * Beta or K2 * beta
  65++C4D9 ED 4B 17 C0                          ld      bc,(SBnKzhi)                ; BCH = z
  66++C4DD 3A 16 C0                             ld      a,(SBnKzlo)                 ; .
  67++C4E0 67                                   ld      h,a                         ; .
  68++C4E1 CD C4 91                             call    AddBCHtoDELsigned           ; DEL = z + ((y - alpha * x /256 ) * Beta) /256
  69++C4E4 ED 53 8B C4  .SaveZResult:           ld      (SunZResult+1),de           ; We now have a z result which we save
  70++C4E8 ED 53 17 C0                          ld      (SBnKzhi),de                ; .
  71++C4EC 7D                                   ld      a,l                         ; .
  72++C4ED 32 8A C4                             ld      (SunZResult),a              ; .
  73++C4F0 32 16 C0                             ld      (SBnKzlo),a                 ; .
  74++C4F3 EB           .CalcMinusBetaMulZ:     ex      de,hl                       ; HLE = DEL = z post calculation
  75++C4F4                                      ; not needed bugld      e,l                         ; .
  76++C4F4 3A 6E 83                             ld      a,(BETA)                    ; d = - BETA
  77++C4F7 EE 80                                xor     SignOnly8Bit                ; .
  78++C4F9 57                                   ld      d,a                         ; .
  79++C4FA CD 31 94                             call    mulHLEbyDSigned             ; DELC = z * - BETA
  80++C4FD ED 4B 87 C4                          ld      bc, (SunRollResult+1)       ; BCH = (y - alpha * x) (or K2)
  81++C501 3A 86 C4                             ld      a,(SunRollResult)           ; .
  82++C504 67                                   ld      h,a                         ; .
  83++C505 CD C4 91                             call    AddBCHtoDELsigned           ; DEL = (y - alpha * x) - (Z * BETA) (K2+ (Z * -BETA)
  84++C508 ED 53 14 C0                          ld      (SBnKyhi),de                ; y = (y - alpha * x) - (Z * BETA)
  85++C50C 7D                                   ld      a,l                         ; .
  86++C50D 32 13 C0                             ld      (SBnKylo),a                 ; .
  87++C510 EB           .CalcX:                 ex      de,hl                       ; HLE = DEL = Y
  88++C511 5D                                   ld      e,l                         ; .
  89++C512 3A 7C 83                             ld      a,(ALPHA)                   ; D = alpha
  90++C515 FE 00                                cp      0                           ; if alpha is 0 then don't update x
  91++C517 CA 32 C5                             jp      z,.NoRotation
  92++C51A 57                                   ld      d,a                         ; .
  93++C51B CD 31 94                             call    mulHLEbyDSigned             ; DELC = Y * alpha
  94++C51E ED 4B 11 C0                          ld      bc,(SBnKxhi)                ; BCH = x
  95++C522 3A 10 C0                             ld      a,(SBnKxlo)                 ; .
  96++C525 67                                   ld      h,a                         ; .
  97++C526 CD C4 91                             call    AddBCHtoDELsigned           ; DEL = x + (alpha * y /256 )
  98++C529 ED 53 11 C0                          ld      (SBnKxhi),de                ; x = x + (alpha * y /256 )
  99++C52D 7C                                   ld      a,h                         ; .
 100++C52E 32 10 C0                             ld      (SBnKxlo),a                 ; .
 101++C531 C9                                   ret
 102++C532 3A 62 84     .NoRotation:            ld      a,(DELTA)                   ; BCH = - Delta
 103++C535 FE 00                                cp      0
 104++C537 C8                                   ret     z
 105++C538 0E 00                                ld      c,0                         ;
 106++C53A 67                                   ld      h,a                         ;
 107++C53B 06 80                                ld      b,$80                       ;
 108++C53D ED 5B 17 C0                          ld      de,(SBnKzhi)                ; DEL = z position
 109++C541 3A 16 C0                             ld      a,(SBnKzlo)                 ; .
 110++C544 6F                                   ld      l,a                         ; .
 111++C545 CD C4 91                             call    AddBCHtoDELsigned           ; update speed
 112++C548 ED 53 17 C0                          ld      (SBnKzhi),DE                ; write back to zpos
 113++C54C 7D                                   ld      a,l
 114++C54D 32 16 C0                             ld      (SBnKzlo),a                ;
 115++C550 C9                                   ret
 116++C551
 117++C551              ;
 118++C551              ;SunApplyMyRollAndPitch: ld      a,(ALPHA)                   ; no roll or pitch, no calc needed
 119++C551              ;                        ld      hl,BETA
 120++C551              ;                        or      (hl)
 121++C551              ;                        and     SignMask8Bit
 122++C551              ;                        ret     z
 123++C551              ;.CalcZ:                 ;break
 124++C551              ;                        ld      a,(ALPHA)                   ; get roll magnitude
 125++C551              ;                        xor     SignOnly8Bit                ; get Q = -alpha
 126++C551              ;                        ld      d,a                         ; d reg represents Q (abount to roll)
 127++C551              ;                        ld      a,(SBnKxlo)                 ; HLE = x sgn, hi, lo
 128++C551              ;                        ld      e,a                         ;
 129++C551              ;                        ld      hl,(SBnKxhi)                ;
 130++C551              ;                        call    mulHLEbyDSigned             ; DELC = x * -alpha, so DEL = X * -alpha / 256
 131++C551              ;                        ld      a,d
 132++C551              ;                        ld      (SunRollResultp4),a         ; save D (I guess we need the sign?)
 133++C551              ;.CalcYPlusDEL:          ld      a,(SBnKylo)                 ; BCH = Y sgn, hi, lo
 134++C551              ;                        ld      h,a
 135++C551              ;                        ld      bc,(SBnKyhi)
 136++C551              ;                        call    AddBCHtoDELsigned           ; DEL = Y - ( X *  alpha /256)
 137++C551              ;.SaveResult1:           ld      a,l                         ; SunPitchWork = DEL
 138++C551              ;                        ;ld      (SunRollResult), a          ; SunPitchWork + 0 = L
 139++C551              ;                        ex      de,hl                       ; SunPitchWork + 1 = E
 140++C551              ;.CopyResultTo2:         ld      (SunRollResult+1),a         ; SunPitchWork + 2 = D
 141++C551              ;                        ld      (SunRollResult+1) ,hl       ; Copy K to K2 (y - alpha * x)
 142++C551              ;                        ;ld      (SunRollResult2+1),hl       ; also HLA = result
 143++C551              ;                        ld      a,(SunRollResult)           ; .
 144++C551              ;                        ;ld      (SunRollResult2),a          ; .
 145++C551              ;.CalcY:                 ld      e,a                         ; so now HLE = result
 146++C551              ;                        ld      a,(BETA)                    ; get pitch
 147++C551              ;                        ld      d,a                         ; now D = BETA
 148++C551              ;                        call    mulHLEbyDSigned             ; DELC = (y - alpha * x /256 ) * Beta
 149++C551              ;                        ld      bc,(SBnKzhi)                ; BCH = z
 150++C551              ;                        ld      a,(SBnKzlo)                 ;
 151++C551              ;                        ld      h,a                         ;
 152++C551              ;                        call    AddBCHtoDELsigned           ; DEL = z + ((y - alpha * x /256 ) * Beta) /256
 153++C551              ;.SaveZResult:           ld      (SunZResult+1),de           ; We now have a z result which we save
 154++C551              ;                        ld      (SBnKzhi),de                ; .
 155++C551              ;                        ld      a,l                         ; .
 156++C551              ;                        ld      (SunZResult),a              ; .
 157++C551              ;                        ld      (SBnKzlo),a                 ; .
 158++C551              ;.CalcMinusBetaMulZ:     ex      de,hl                       ; HLE = DEL = z post calculation
 159++C551              ;                        ld      e,l                         ;
 160++C551              ;                        ld      a,(BETA)                    ; d = - BETA
 161++C551              ;                        ld      d,a                         ;
 162++C551              ;                        xor     SignOnly8Bit                ;
 163++C551              ;                        call    mulHLEbyDSigned             ; DELC = z * - BETA
 164++C551              ;                        ld      bc, (SunRollResult+1)       ; BCH = (y - alpha * x) (or K2)
 165++C551              ;                        ld      a,(SunRollResult)           ;
 166++C551              ;                        ld      h,a                         ;
 167++C551              ;                        call    AddBCHtoDELsigned           ; DEL = (y - alpha * x) - (Z * BETA)
 168++C551              ;                        ld      (SBnKyhi),de                ; y = (y - alpha * x) - (Z * BETA)
 169++C551              ;                        ld      a,l                         ;
 170++C551              ;                        ld      (SBnKylo),a                 ;
 171++C551              ;.CalcX:                 ex      de,hl                       ; HLE = DEL = Y
 172++C551              ;                        ld      e,l                         ;
 173++C551              ;                        ld      a,(ALPHA)
 174++C551              ;                        ld      d,a                         ; D = alpha
 175++C551              ;                        call    mulHLEbyDSigned             ; DELC = Y * alpha
 176++C551              ;                        ld      bc,(SBnKxhi)                ; BCH = x
 177++C551              ;                        ld      a,(SBnKxlo)                 ;
 178++C551              ;                        ld      h,a                         ;
 179++C551              ;                        call    AddBCHtoDELsigned           ; DEL = x + (alpha * y /256 )
 180++C551              ;                        ld      (SBnKxhi),de                ; x = x + (alpha * y /256 )
 181++C551              ;                        ld      a,h                         ;
 182++C551              ;                        ld      (SBnKxlo),a                 ;
 183++C551              ;                        ret
 184++C551              ;
# file closed: ././Universe/Sun/SunApplyMyRollAndPitch.asm
 501+ C551              ;            INCLUDE "./Universe/SunApplyShipRollAndPitch.asm"
 502+ C551
 503+ C551 00           SunOnScreen             DB 0
 504+ C552 00 00        cLineArrayPtr            DW 0
 505+ C554 00           LineCount               DB 0
 506+ C555 00           RaggedSize              DB 0
 507+ C556 00           MinYOffset              DB 0
 508+ C557 00           MaxYOffSet              DB 0
 509+ C558 00 00        SunScrnX                DW  0       ; signed
 510+ C55A 00 00        SunScrnY                DW  0       ; signed
 511+ C55C 00           SunRadius               DB  0       ; unsigned
 512+ C55D              ; draw circle
 513+ C55D
 514+ C55D              ;
 515+ C55D              ;DIVD3B2 K(3 2 1 0) = (A P+1 P) / (z_sign z_hi z_lo)
 516+ C55D
 517+ C55D 00 00 00 00  SunVarK                 DS 4
 518+ C561 00 00 00     SunVarP                 DS 3
 519+ C564 00           SunVarQ                 DS 1
 520+ C565 00           SunVarR                 DS 1
 521+ C566 00           SunVarS                 DS 1
 522+ C567 00           SunVarT                 DS 1
 523+ C568
 524+ C568              ; Needs tuning for registers vs memroy
 525+ C568 22 61 C5     SunKEquAHLDivCDE:       ld      (SunVarP),hl
 526+ C56B 32 63 C5                             ld      (SunVarP+2),a
 527+ C56E ED 53 64 C5                          ld      (SunVarQ),de
 528+ C572 79                                   ld      a,c
 529+ C573 32 66 C5                             ld      (SunVarS),a
 530+ C576 3A 61 C5     SunDivD3B:              ld      a,(SunVarP)                 ; Ensure P is at least 1
 531+ C579 F6 01                                or      1
 532+ C57B 32 61 C5                             ld      (SunVarP),a
 533+ C57E 3A 63 C5                             ld      a,(SunVarP+2)               ; T = Sign xor Sign
 534+ C581 21 66 C5                             ld      hl,SunVarS
 535+ C584 AE                                   xor     (hl)
 536+ C585 E6 80                                and     SignOnly8Bit
 537+ C587 32 67 C5                             ld      (SunVarT),a
 538+ C58A 06 00                                ld      b,0                         ; b = y counter
 539+ C58C 3A 63 C5                             ld      a,(SunVarP+2)               ; a = abs high byte of p
 540+ C58F E6 7F                                and     SignMask8Bit                ; .
 541+ C591 2A 61 C5                             ld      hl,(SunVarP)                ; shift P left
 542+ C594              .SunDVL9:               JumpIfAGTENusng   64, .SunDV14      ; if high p > 64 then go to DV14
 542+ C594 FE 40       >                        cp     64
 542+ C596 D2 A3 C5    >                        jp		nc,.SunDV14
 543+ C599                                      ShiftHLLeft1                        ;
 543+ C599 CB 25       >			   sla l
 543+ C59B CB 14       >			   rl  h
 544+ C59D CB 17                                rl      a                           ;
 545+ C59F 04                                   inc     b                           ; increase shift count
 546+ C5A0 C3 94 C5                             jp      .SunDVL9
 547+ C5A3 22 61 C5     .SunDV14:               ld      (SunVarP),hl                ; save off var P
 548+ C5A6 32 63 C5                             ld      (SunVarP+2),a
 549+ C5A9 3A 66 C5                             ld      a,(SunVarS)                 ; a= ABS varS
 550+ C5AC E6 7F                                and     SignMask8Bit
 551+ C5AE 2A 64 C5                             ld      hl,(SunVarQ)                ; HL = vars Q & R
 552+ C5B1 05           .SunDVL6:               dec     b                           ; reduce b counter by 1
 553+ C5B2                                      ShiftHLLeft1                        ; varQRA  shift left
 553+ C5B2 CB 25       >			   sla l
 553+ C5B4 CB 14       >			   rl  h
 554+ C5B6 CB 17                                rl      a                           ;
 555+ C5B8 F2 B1 C5                             jp      p, .SunDVL6                 ; keep shifting until bit 7 of a is set
 556+ C5BB 22 64 C5                             ld      (SunVarQ),hl                ; save QR
 557+ C5BE 32 66 C5     .SunDV9:                ld      (SunVarS),a                 ; save S
 558+ C5C1                                      ;ld      a,h
 559+ C5C1                                      ;ld      (varQ),a
 560+ C5C1 4F                                   ld      c,a
 561+ C5C2 3A 63 C5                             ld      a,(SunVarP+2)
 562+ C5C5 C5                                   push    bc                          ; save shift counter in b
 563+ C5C6 CD 9D 95                             call    DIV16Amul256dCUNDOC
 564+ C5C9                                      ;call    RequAmul256divQ
 565+ C5C9 79                                   ld      a, c
 566+ C5CA 32 67 84                             ld      (varR),a
 567+ C5CD C1                                   pop     bc                          ; retrieve shift counter
 568+ C5CE 21 00 00                             ld      hl,0                        ; set K to 0
 569+ C5D1 22 5D C5                             ld      (SunVarK),hl                ; .
 570+ C5D4 22 5F C5                             ld      (SunVarK+2),hl              ; .
 571+ C5D7 CB 78                                bit     7,b                         ; is counter positive
 572+ C5D9 28 32                                jr      z,.SunDV12                  ; .
 573+ C5DB 3A 67 84                             ld      a,(varR)                    ;
 574+ C5DE CB 27        .SunDVL8:               sla     a                           ; Shift K by 1 left
 575+ C5E0 21 5E C5                             ld      hl,SunVarK+1                ; .
 576+ C5E3 CB 16                                rl      (hl)                        ; .
 577+ C5E5 23                                   inc     hl                          ; .
 578+ C5E6 CB 16                                rl      (hl)                        ; .
 579+ C5E8 23                                   inc     hl                          ; .
 580+ C5E9 CB 16                                rl      (hl)                        ; .
 581+ C5EB 04                                   inc     b
 582+ C5EC 20 F0                                jr      nz,.SunDVL8                 ; loop until K is shifted
 583+ C5EE 32 5D C5                             ld      (SunVarK),a
 584+ C5F1 3A 60 C5                             ld      a,(SunVarK+3)
 585+ C5F4 21 67 C5                             ld      hl,SunVarT
 586+ C5F7 B6                                   or      (hl)
 587+ C5F8 32 60 C5                             ld      (SunVarK+3),a
 588+ C5FB C9                                   ret
 589+ C5FC 3A 67 84     .SunDV13:               ld      a,(varR)                    ; when we get here, shift is zero
 590+ C5FF 32 5D C5                             ld      (SunVarK),a
 591+ C602 3A 60 C5                             ld      a,(SunVarK+3)
 592+ C605 21 67 C5                             ld      hl,SunVarT
 593+ C608 B6                                   or      (hl)
 594+ C609 32 60 C5                             ld      (SunVarK+3),a
 595+ C60C C9                                   ret
 596+ C60D 78           .SunDV12:               ld      a,b
 597+ C60E A7                                   and     a
 598+ C60F 28 EB                                jr      z,.SunDV13
 599+ C611 3A 67 84                             ld      a,(varR)                    ; it probably is already R so need to test
 600+ C614 CB 2F        .SunDVL10:              sra     a                           ; Shift K by 1 left
 601+ C616 05                                   dec     b
 602+ C617 20 FB                                jr      nz,.SunDVL10
 603+ C619 32 5D C5                             ld      (SunVarK),a                 ; as original divide was onyl 8 bits K 1,2,3 don;t matter
 604+ C61C 3A 67 C5                             ld      a,(SunVarT)
 605+ C61F 32 60 C5                             ld      (SunVarK+3),a
 606+ C622 C9                                   ret
 607+ C623
 608+ C623
 609+ C623
 610+ C623              SunProcessVertex:       MACRO   vertlo, vertsgn
 611+ C623 ~            .SunProjectToEye:       ld      de,(SBnKzlo)                ; X Pos = X / Z
 612+ C623 ~                                    ld      a,(SBnKzsgn)                ; CDE = z
 613+ C623 ~                                    ld      c,a                         ;
 614+ C623 ~                                    ld      hl,(vertlo)                ; AHL = x
 615+ C623 ~                                    ld      a,(vertsgn)                ;
 616+ C623 ~                                    call    SunKEquAHLDivCDE            ; result in sunvarK to K + 3
 617+ C623 ~                                    ld      hl,(SunVarK)                ; result is in DEHL (high to low)
 618+ C623 ~                                    ld      de,(SunVarK+2)
 619+ C623 ~            .CheckPosOnScreenX:     ld      a,d                         ; a= abs highest byte (k+3)  or k+2
 620+ C623 ~                                    and     SignMask8Bit                ;
 621+ C623 ~                                    or      e                           ;
 622+ C623 ~                                    ret     nz                          ; off screen
 623+ C623 ~                                    ld      a,h                         ; a = k + 1 can do this as ABS
 624+ C623 ~                                    ReturnIfAGTEusng 4                  ; if > 1024 then return
 625+ C623 ~                                    ld      a,d                         ; get sign back
 626+ C623 ~                                    and     SignOnly8Bit                ; if positive then we are good
 627+ C623 ~                                    jr      z,.calculatedVert
 628+ C623 ~            .XIsNegative:           NegHL                               ; make 2's c as negative
 629+ C623 ~            .calculatedVert:
 630+ C623                                      ENDM
 631+ C623
 632+ C623              ; .........................................................................................................................
 633+ C623 ED 5B 16 C0  SunCalculateRadius:     ld      de,(SBnKzlo)
 634+ C627 3A 18 C0                             ld      a,(SBnKzsgn)
 635+ C62A 4F                                   ld      c,a
 636+ C62B 21 00 60                             ld      hl,$6000  ; was hl          ; planet radius at Z = 1 006000
 637+ C62E AF                                   xor     a
 638+ C62F CD 04 93                             call    Div24by24LeadSign           ; radius = AHL/CDE = 24576 / distance z
 639+ C632 7A                                   ld      a,d                         ; if high byte (d) = 0 then e contains radius
 640+ C633                                      JumpIfAIsZero  .SaveRadius
 640+ C633 A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
 640+ C634 CA 39 C6    >                        jp	z, .SaveRadius
 641+ C637 1E F8        .MaxRadius:             ld      e,248                       ;set radius to 248 as maxed out
 642+ C639 7B           .SaveRadius:            ld      a,e
 643+ C63A 32 5C C5                             ld      (SunRadius),a               ; save a copy of radius now for later
 644+ C63D C9                                   ret
 645+ C63E
 646+ C63E                                 ; could probabyl set a variable say "varGood", default as 1 then set to 0 if we end up with a good calulation?? may not need it as we draw here
 647+ C63E CD 8D C4     SunUpdateAndRender:     call    SunApplyMyRollAndPitch
 648+ C641 3A 18 C0     .CheckDrawable:         ld      a,(SBnKzsgn)
 649+ C644 E6 80                                and     SignOnly8Bit
 650+ C646 C0                                   ret     nz
 651+ C647              .CheckDist48:           ReturnIfAGTENusng 48                ; at a distance over 48 its too far away
 651+ C647 FE 30       >                        cp    48
 651+ C649 D0          >                        ret	 nc
 652+ C64A 21 17 C0                             ld      hl,SBnKzhi                  ; if the two high bytes are zero then its too close
 653+ C64D B6                                   or      (hl)
 654+ C64E                                      ReturnIfAIsZero
 654+ C64E A7          >                        and     a
 654+ C64F C8          >                        ret     z
 655+ C650              .calculateX:            SunProcessVertex SBnKxlo, SBnKxsgn
 655+ C650 ED 5B 16 C0 >.SunProjectToEye:       ld      de,(SBnKzlo)                ; X Pos = X / Z
 655+ C654 3A 18 C0    >                        ld      a,(SBnKzsgn)                ; CDE = z
 655+ C657 4F          >                        ld      c,a                         ;
 655+ C658 2A 10 C0    >                        ld      hl,(SBnKxlo)                ; AHL = x
 655+ C65B 3A 12 C0    >                        ld      a,(SBnKxsgn)                ;
 655+ C65E CD 68 C5    >                        call    SunKEquAHLDivCDE            ; result in sunvarK to K + 3
 655+ C661 2A 5D C5    >                        ld      hl,(SunVarK)                ; result is in DEHL (high to low)
 655+ C664 ED 5B 5F C5 >                        ld      de,(SunVarK+2)
 655+ C668 7A          >.CheckPosOnScreenX:     ld      a,d                         ; a= abs highest byte (k+3)  or k+2
 655+ C669 E6 7F       >                        and     SignMask8Bit                ;
 655+ C66B B3          >                        or      e                           ;
 655+ C66C C0          >                        ret     nz                          ; off screen
 655+ C66D 7C          >                        ld      a,h                         ; a = k + 1 can do this as ABS
 655+ C66E             >                        ReturnIfAGTEusng 4                  ; if > 1024 then return
 655+ C66E FE 04       >                        cp    4
 655+ C670 D0          >                        ret	 nc
 655+ C671 7A          >                        ld      a,d                         ; get sign back
 655+ C672 E6 80       >                        and     SignOnly8Bit                ; if positive then we are good
 655+ C674 28 06       >                        jr      z,.calculatedVert
 655+ C676             >.XIsNegative:           NegHL                               ; make 2's c as negative
 655+ C676 AF          >                    xor a
 655+ C677 95          >                    sub l
 655+ C678 6F          >                    ld l,a
 655+ C679 9F          >                    sbc a,a
 655+ C67A 94          >                    sub h
 655+ C67B 67          >                    ld h,a
 655+ C67C             >.calculatedVert:
 656+ C67C 1E 80        .calculatedX:           ld      e,ScreenCenterX
 657+ C67E 16 00                                ld      d,0
 658+ C680                                      ClearCarryFlag
 658+ C680 B7          >                        or a
 659+ C681 ED 5A                                adc     hl,de
 660+ C683                                      ;call    HL2cEquHLSgnPlusAusgn       ; correct to center of screen
 661+ C683 22 58 C5                             ld      (SunScrnX),hl               ; save projected X Position, 2's compliment
 662+ C686              .calculateY:            SunProcessVertex SBnKylo, SBnKysgn
 662+ C686 ED 5B 16 C0 >.SunProjectToEye:       ld      de,(SBnKzlo)                ; X Pos = X / Z
 662+ C68A 3A 18 C0    >                        ld      a,(SBnKzsgn)                ; CDE = z
 662+ C68D 4F          >                        ld      c,a                         ;
 662+ C68E 2A 13 C0    >                        ld      hl,(SBnKylo)                ; AHL = x
 662+ C691 3A 15 C0    >                        ld      a,(SBnKysgn)                ;
 662+ C694 CD 68 C5    >                        call    SunKEquAHLDivCDE            ; result in sunvarK to K + 3
 662+ C697 2A 5D C5    >                        ld      hl,(SunVarK)                ; result is in DEHL (high to low)
 662+ C69A ED 5B 5F C5 >                        ld      de,(SunVarK+2)
 662+ C69E 7A          >.CheckPosOnScreenX:     ld      a,d                         ; a= abs highest byte (k+3)  or k+2
 662+ C69F E6 7F       >                        and     SignMask8Bit                ;
 662+ C6A1 B3          >                        or      e                           ;
 662+ C6A2 C0          >                        ret     nz                          ; off screen
 662+ C6A3 7C          >                        ld      a,h                         ; a = k + 1 can do this as ABS
 662+ C6A4             >                        ReturnIfAGTEusng 4                  ; if > 1024 then return
 662+ C6A4 FE 04       >                        cp    4
 662+ C6A6 D0          >                        ret	 nc
 662+ C6A7 7A          >                        ld      a,d                         ; get sign back
 662+ C6A8 E6 80       >                        and     SignOnly8Bit                ; if positive then we are good
 662+ C6AA 28 06       >                        jr      z,.calculatedVert
 662+ C6AC             >.XIsNegative:           NegHL                               ; make 2's c as negative
 662+ C6AC AF          >                    xor a
 662+ C6AD 95          >                    sub l
 662+ C6AE 6F          >                    ld l,a
 662+ C6AF 9F          >                    sbc a,a
 662+ C6B0 94          >                    sub h
 662+ C6B1 67          >                    ld h,a
 662+ C6B2             >.calculatedVert:
 663+ C6B2 1E 60        .calculatedY:           ld      e,ScreenCenterY
 664+ C6B4 57                                   ld      d,a
 665+ C6B5 EB                                   ex      de,hl
 666+ C6B6                                      ClearCarryFlag
 666+ C6B6 B7          >                        or a
 667+ C6B7 ED 52                                sbc     hl,de
 668+ C6B9                                      ;call    HL2cEquHLSgnPlusAusgn       ; correct to center of screen
 669+ C6B9 22 5A C5                             ld      (SunScrnY),hl               ; save projected Y Position, 2's compliment
 670+ C6BC              ; .........................................................................................................................
 671+ C6BC CD 23 C6                             call    SunCalculateRadius
 672+ C6BF              ; .........................................................................................................................
 673+ C6BF 2A 58 C5     .CheckIfSunOnScreen:    ld      hl,(SunScrnX)               ; get x pixel position
 674+ C6C2 FD 26 00                             ld      iyh,0                       ; iyh holds draw status, 0= OK
 675+ C6C5 16 00                                ld      d,0                         ; e still holds radius
 676+ C6C7 7C                                   ld      a,h
 677+ C6C8                                      JumpOnLeadSignSet   h,.CheckXNegative
 677+ C6C8 7C          >                        ld      a,h
 677+ C6C9 E6 80       >                        and     SignOnly8Bit
 677+ C6CB C2 E1 C6    >                        jp      nz,.CheckXNegative
 678+ C6CE 7C           .CheckXPositive:        ld      a,h
 679+ C6CF                                      JumpIfAIsZero   .XOnScreen          ; if high byte of h is not zero its definitly on screen
 679+ C6CF A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
 679+ C6D0 CA EA C6    >                        jp	z, .XOnScreen
 680+ C6D3 16 00                                ld      d,0                         ; de = radius
 681+ C6D5                                      ClearCarryFlag
 681+ C6D5 B7          >                        or a
 682+ C6D6 ED 52                                sbc     hl,de
 683+ C6D8 FA EA C6                             jp      m   ,.XOnScreen             ; if result was negative then it spans screen
 684+ C6DB 7C                                   ld      a,h
 685+ C6DC                                      JumpIfAIsZero   .XOnScreen          ; if high byte of h is not zero then its partially on screen at least
 685+ C6DC A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
 685+ C6DD CA EA C6    >                        jp	z, .XOnScreen
 686+ C6E0 C9                                   ret                                 ; None of the X coordinates are on screen
 687+ C6E1 16 00        .CheckXNegative:        ld      d,0                         ; de = radius
 688+ C6E3                                      ClearCarryFlag
 688+ C6E3 B7          >                        or a
 689+ C6E4 ED 5A                                adc     hl,de                       ; so we have hl - de
 690+ C6E6 F2 EA C6                             jp      p,.XOnScreen                ; if result was positive then it spans screen so we are good
 691+ C6E9 C9                                   ret                                 ; else x is totally off the left side of the screen
 692+ C6EA              ; .........................................................................................................................
 693+ C6EA 2A 5A C5     .XOnScreen:             ld      hl,(SunScrnY)               ; now Check Y coordinate
 694+ C6ED                                      JumpOnLeadSignSet   h,.CheckYNegative
 694+ C6ED 7C          >                        ld      a,h
 694+ C6EE E6 80       >                        and     SignOnly8Bit
 694+ C6F0 C2 12 C7    >                        jp      nz,.CheckYNegative
 695+ C6F3 7C           .CheckYPositive:        ld      a,h
 696+ C6F4                                      JumpIfAIsNotZero   .PosYCheck2
 696+ C6F4 FE 00       >                        cp	0
 696+ C6F6 C2 FF C6    >                        jp	nz,.PosYCheck2
 697+ C6F9 7D                                   ld      a,l
 698+ C6FA E6 80                                and     %10000000
 699+ C6FC CA 1B C7                             jp      z,YOnScreen                ; at least 1 row is on screen as > 128
 700+ C6FF 16 00        .PosYCheck2:            ld      d,0                         ; de = radius
 701+ C701                                      ClearCarryFlag
 701+ C701 B7          >                        or a
 702+ C702 ED 52                                sbc     hl,de
 703+ C704 FA 1B C7                             jp      m,YOnScreen                ; so if its -ve then it spans screen
 704+ C707 7C                                   ld      a,h                         ; if h > 0 then off screen so did not span
 705+ C708                                      ReturnIfANotZero                    ; .
 705+ C708 A7          >                        and     a
 705+ C709 C0          >                        ret     nz
 706+ C70A 7D                                   ld      a,l                         ; if l > 128 then off screen so did not span
 707+ C70B E6 80                                and     %10000000                   ; .
 708+ C70D                                      ReturnIfANotZero                    ; .
 708+ C70D A7          >                        and     a
 708+ C70E C0          >                        ret     nz
 709+ C70F C3 1B C7                             jp      YOnScreen                  ; so Y at least spans
 710+ C712 16 00        .CheckYNegative:        ld      d,0                         ; de = radius
 711+ C714                                      ClearCarryFlag
 711+ C714 B7          >                        or a
 712+ C715 ED 5A                                adc     hl,de                       ; so we have hl - de
 713+ C717 F2 1B C7                             jp      p,YOnScreen                ; if result was positive then it spans screen so we are good
 714+ C71A C9                                   ret                                 ; else never gets above 0 so return
 715+ C71B              ; .........................................................................................................................
 716+ C71B 21 9F C0     YOnScreen:             ld      hl,SBnKLineArray            ; we load start and end as 0
 717+ C71E 11 00 01                             ld		de, SunLineArraySize        ; just if we get a 0,0 genuine we will not plot it
 718+ C721 3E 00                                ld		a,0
 719+ C723 CD 65 80                             call	memfill_dma
 720+ C726              ; .........................................................................................................................
 721+ C726 11 00 00     .SetRaggedEdgeMax:      ld      de,0
 722+ C729 3A 5C C5                             ld      a,(SunRadius)               ; get readius
 723+ C72C FE 60                                cp      96                          ; if > 96 then roll carry flag into e
 724+ C72E                                      FlipCarryFlag
 724+ C72E 3F          >                        ccf
 725+ C72F CB 13                                rl      e                           ; if > 40 then roll carry flag into e
 726+ C731 FE 28                                cp      40
 727+ C733                                      FlipCarryFlag
 727+ C733 3F          >                        ccf
 728+ C734 CB 13                                rl      e
 729+ C736 FE 10                                cp      16                          ; if > 16 then roll carry flag into e
 730+ C738                                      FlipCarryFlag
 730+ C738 3F          >                        ccf
 731+ C739 CB 13                                rl     e
 732+ C73B 7B                                   ld      a,e                         ; a = ragged size from %00000111 to %00000000
 733+ C73C 32 55 C5                             ld      (RaggedSize),a
 734+ C73F              ; .........................................................................................................................
 735+ C73F 21 9F C0     .SkipSetK:              ld      hl,SBnKLineArray            ; prep line array details ready for filling
 736+ C742 22 9F C1                             ld      (LineArrayPtr),hl
 737+ C745 AF                                   xor     a
 738+ C746 32 54 C5                             ld      (LineCount),a
 739+ C749              ; .........................................................................................................................
 740+ C749 2A 5A C5     .GetMinY:               ld      hl,(SunScrnY)               ; now calculate start Y position
 741+ C74C 3A 5C C5                             ld      a,(SunRadius)
 742+ C74F 5F                                   ld      e,a
 743+ C750 16 00                                ld      d,0
 744+ C752                                      ClearCarryFlag
 744+ C752 B7          >                        or a
 745+ C753 ED 52                                sbc     hl,de
 746+ C755 F2 5B C7                             jp      p,.DoneMinY
 747+ C758 21 00 00                             ld      hl,0                        ; if its negative then we start with 0 as it can only go up screen after radius
 748+ C75B              .DoneMinY:              ReturnIfRegNotZero h                ; if h > 0 then off the screen
 748+ C75B 7C          >                        ld      a, h
 748+ C75C A7          >                        and     a
 748+ C75D C0          >                        ret     nz
 749+ C75E 7D                                   ld      a,l                         ; check if l > 127
 750+ C75F E6 80                                and     SignOnly8Bit                ; .
 751+ C761 C0                                   ret     nz                          ; if bit is set then > 128
 752+ C762 7D           .SetMinY:               ld      a,l
 753+ C763 32 56 C5                             ld      (MinYOffset),a              ; so now we have Y top of screen
 754+ C766 2A 5A C5     .GetMaxY:               ld      hl,(SunScrnY)               ; get hl = Y + radius, note if we got here then this can never be a negative result but can go from -ve hl to +ve result
 755+ C769 3A 5C C5                             ld      a,(SunRadius)               ; hl = hl + radius
 756+ C76C 16 00                                ld      d,0                         ; .
 757+ C76E 5F                                   ld      e,a                         ; .
 758+ C76F                                      ClearCarryFlag                      ; .
 758+ C76F B7          >                        or a
 759+ C770 ED 5A                                adc     hl,de                       ; .
 760+ C772 7C                                   ld      a,h
 761+ C773 A7                                   and     a
 762+ C774 28 06                                jr      z,.YHiOK
 763+ C776 21 7F 00     .YHiGTE127:             ld      hl,127
 764+ C779 C3 85 C7                             jp      .SetMaxY
 765+ C77C 7D           .YHiOK:                 ld      a,l                         ; clamp at 127
 766+ C77D E6 80                                and     SignOnly8Bit                ; .
 767+ C77F CA 85 C7                             jp      z,.SetMaxY
 768+ C782 21 7F 00                             ld      hl,127
 769+ C785 7D           .SetMaxY                ld      a,l
 770+ C786 32 57 C5                             ld      (MaxYOffSet),a              ; so now we have min and max Y coordinates and SunScrnX & Y holds center
 771+ C789 CD 90 C7                             call    SunDrawCircle
 772+ C78C CD B9 C1                             call    SunDraw
 773+ C78F C9                                   ret
 774+ C790                                      ; b8 04 00 02 00 00 60 01 00 gives a 0.5 so we have the cal wrong as its +-1 so should be * result of divide by 128
 775+ C790              ;.. Now we caluclate the circle of the star
 776+ C790              ;.. its from MinY down the screen to MaxY center ProjX,ProjY.
 777+ C790              ;.. We can use the circle draw logic gtom Bressenham's algorithm
 778+ C790              ; so now there are the following conditions to consider
 779+ C790              ; y min = 0   y center is negative radius <= ABS (Y center)             => Don't draw
 780+ C790              ; y min = 0   y center is negative radius > ABS (Y center)+1            => Draw bottom half only
 781+ C790              ; y max = 127 y center is > 127    radius <= y center - 127             => Don't draw
 782+ C790              ; y max = 127 y center is > 127    radius > y center - 127              => Draw top half only
 783+ C790              ; y min >= 0  y center > y min     we don't need to worry about radius  => Draw both halves
 784+ C790              ; x center + radius < 0                                                 => Don't draw
 785+ C790              ; x center - radius > 255                                               => Don't draw
 786+ C790              ; we won't consider x more here as the driver is the y coordinate but we will check if x is vaiable
 787+ C790              ; x point = max (x point, 0)   on left
 788+ C790              ; x point = min (x point, 255) on right
 789+ C790
 790+ C790              SetIYPlusOffset:        MACRO   reg
 791+ C790 ~                                    push    hl,,iy                          ; save hl, then hl = iy
 792+ C790 ~                                    pop     hl                              ;
 793+ C790 ~                                    ld      a,reg
 794+ C790 ~                                    add     hl,a
 795+ C790 ~                                    add     hl,a
 796+ C790 ~                                    push    hl
 797+ C790 ~                                    pop     iy
 798+ C790 ~                                    pop     hl
 799+ C790                                      ENDM
 800+ C790
 801+ C790              SetIYMinusOffset:       MACRO   reg
 802+ C790 ~                                    push    de,,hl,,iy                      ; save hl, then hl = iy
 803+ C790 ~                                    pop     hl                              ;
 804+ C790 ~                                    ld      a,reg
 805+ C790 ~                                    add     a,a
 806+ C790 ~                                    ld      e,a
 807+ C790 ~                                    ld      d,0
 808+ C790 ~                                    ClearCarryFlag
 809+ C790 ~                                    sbc     hl,de
 810+ C790 ~                                    push    hl
 811+ C790 ~                                    pop     iy
 812+ C790 ~                                    pop     de,,hl
 813+ C790                                      ENDM
 814+ C790
 815+ C790
 816+ C790              ;;;-SunDrawCircle:          ld      a,(SunRadius)
 817+ C790              ;;;-.CheckRadius:           ReturnIfAIsZero                         ; elimiate zero or single pixel
 818+ C790              ;;;-                        JumpIfAEqNusng  1, SunCircleSinglePixel
 819+ C790              ;;;-                       ; JumpIfAGTENusng 127, SunFullScreen      ; if its covering whole then just make it yellow
 820+ C790              ;;;-; already done .MakeCentreX2C:         MemSignedTo2C SunScrnX                   ; convert 16 bit signed to 2's compliment
 821+ C790              ;;;-; already done .MakeCentreY2C:         MemSignedTo2C SunScrnY                   ; .
 822+ C790              ;;;-.BoundsCheck            ld      hl,(SunScrnY)
 823+ C790              ;;;-                        push    hl
 824+ C790              ;;;-                        ld      a,(SunRadius)
 825+ C790              ;;;-                        add     hl,a
 826+ C790              ;;;-                        bit     7,h
 827+ C790              ;;;-                        ret     nz                              ; if Y + radius is negative then off the screen
 828+ C790              ;;;-                        pop     hl
 829+ C790              ;;;-                        ld      d,0
 830+ C790              ;;;-                        ld      e,a
 831+ C790              ;;;-                        ClearCarryFlag
 832+ C790              ;;;-                        sbc     hl,de
 833+ C790              ;;;-                        ld      a,h
 834+ C790              ;;;-                        ReturnIfAGTENusng  1                     ; really shoudl be signed TODO
 835+ C790              ;;;-
 836+ C790              ;;;-                        ld      hl,(SunScrnX)
 837+ C790              ;;;-                        push    hl
 838+ C790              ;;;-                        ld      a,(SunRadius)
 839+ C790              ;;;-                        add     hl,a
 840+ C790              ;;;-                        bit     7,h
 841+ C790              ;;;-                        ret     nz                              ; if Y + radius is negative then off the screen
 842+ C790              ;;;-                        pop     hl
 843+ C790              ;;;-                        ld      d,0
 844+ C790              ;;;-                        ld      e,a
 845+ C790              ;;;-                        ClearCarryFlag
 846+ C790              ;;;-                        sbc     hl,de
 847+ C790              ;;;-                        ld      a,h
 848+ C790              ;;;-
 849+ C790              ;;;-                        ReturnIfAGTENusng 1                      ; really shoudl be signed TODO
 850+ C790              SunDrawCircle
 851+ C790                                      ; ** BNOTE Ptuichj abnd roll has a bug as piitch increases z axis value
 852+ C790              .PrepCircleData:       ; ld      ixl,0
 853+ C790                                     ; ld		(.Plot1+1),bc			        ; save origin into DE reg in code
 854+ C790 3A 5C C5                             ld      a,(SunRadius)
 855+ C793 DD 67                                ld		ixh,a							; ixh = radius
 856+ C795 DD 2E 00                             ld		ixl,0						    ; ixl = delta (y)
 857+ C798 26 00        .calcd:	                ld		h,0                             ; de = radius * 2
 858+ C79A 6F                                   ld		l,a                             ; .
 859+ C79B 29                                   add		hl,hl							; .
 860+ C79C EB                                   ex		de,hl							; .
 861+ C79D 21 03 00                             ld		hl,3                            ; hl = 3 - (r * 2)
 862+ C7A0 A7                                   and		a                               ; .
 863+ C7A1 ED 52                                sbc		hl,de							; .
 864+ C7A3 44                                   ld		b,h                             ; bc = 3 - (r * 2) : d = 3 - 2r
 865+ C7A4 4D                                   ld		c,l								; .
 866+ C7A5 21 01 00     .calcdelta:             ld		hl,1                            ; set hl to 1
 867+ C7A8 16 00                                ld		d,0                             ; de = ixl
 868+ C7AA DD 5D                                ld		e,ixl                           ;
 869+ C7AC                                      ClearCarryFlag                          ;
 869+ C7AC B7          >                        or a
 870+ C7AD ED 52                                sbc		hl,de                           ; hl = 1 - ixl
 871+ C7AF 11 01 00     .Setde1:                ld		de,1                            ; del = 1
 872+ C7B2 DD 7C        .CircleLoop:            ld		a,ixh                           ; if x = y then exit
 873+ C7B4 DD BD                                cp		ixl                             ;
 874+ C7B6 D8                                   ret		c                               ;
 875+ C7B7 D9           .ProcessLoop:	        exx                                     ; save out registers
 876+ C7B8              ; Process CY+Y CX+X & CY+Y CX-X..................................
 877+ C7B8 2A 5A C5     .Plot1:                 ld      hl, (SunScrnY)
 878+ C7BB DD 7C        .Get1YRow:              ld      a,ixh
 879+ C7BD ED 31                                add     hl,a                            ; Check to see if CY+Y (note is add hl ,a usginedf only??)
 880+ C7BF              .Check1YRowOnScreen:    CheckRowHLOnScreen .NoTopPixelPair
 880+ C7BF 7C          >                        ld      a,h                             ; is h byte set, i.e > 256 or < 0
 880+ C7C0 A7          >                        and     a                               ; .
 880+ C7C1 20 26       >                        jr      nz,.NoTopPixelPair                   ; h <> 0 so fails (covers <0 and > 255
 880+ C7C3 7D          >                        ld      a,l                             ; l bit 7 0?
 880+ C7C4 E6 80       >                        and     Bit7Only                        ; covers l > 127 (screen draw area is 0 to 192 / 3 * 2 (128)
 880+ C7C6 20 21       >                        jr      nz,.NoTopPixelPair                   ;
 881+ C7C8              .Write1YCoord:          SetIYPlusOffset ixh                     ; IY = IY + ixh
 881+ C7C8 E5 FD E5    >                        push    hl,,iy                          ; save hl, then hl = iy
 881+ C7CB E1          >                        pop     hl                              ;
 881+ C7CC DD 7C       >                        ld      a,ixh
 881+ C7CE ED 31       >                        add     hl,a
 881+ C7D0 ED 31       >                        add     hl,a
 881+ C7D2 E5          >                        push    hl
 881+ C7D3 FD E1       >                        pop     iy
 881+ C7D5 E1          >                        pop     hl
 882+ C7D6                                      IYEquRowN l                             ; IY = SBnkLineArray + (2 * l) - set up iy as target address
 882+ C7D6 7D          >                        ld      a,l
 882+ C7D7 21 9F C0    >                        ld      hl,SBnKLineArray
 882+ C7DA ED 31       >                        add     hl,a
 882+ C7DC ED 31       >                        add     hl,a
 882+ C7DE E5          >                        push    hl
 882+ C7DF FD E1       >                        pop     iy
 883+ C7E1 DD 7D                                ld      a,ixl
 884+ C7E3 CD B6 C8                             call    ProcessXRowA
 885+ C7E6 C3 E9 C7                             jp      .Plot2
 886+ C7E9              .NoTopPixelPair:        ;break
 887+ C7E9              ; Process CY-Y CX+X & CY-Y CX-X..................................
 888+ C7E9 2A 5A C5     .Plot2:                 ld      hl, (SunScrnY)
 889+ C7EC 16 00        .Get2YRow:              ld      d,0
 890+ C7EE DD 5C                                ld      e,ixh
 891+ C7F0                                      ClearCarryFlag
 891+ C7F0 B7          >                        or a
 892+ C7F1 ED 52                                sbc     hl,de
 893+ C7F3              .Check2YRowOnScreen:    CheckRowHLOnScreen .NoBottomPixelPair
 893+ C7F3 7C          >                        ld      a,h                             ; is h byte set, i.e > 256 or < 0
 893+ C7F4 A7          >                        and     a                               ; .
 893+ C7F5 20 2B       >                        jr      nz,.NoBottomPixelPair                   ; h <> 0 so fails (covers <0 and > 255
 893+ C7F7 7D          >                        ld      a,l                             ; l bit 7 0?
 893+ C7F8 E6 80       >                        and     Bit7Only                        ; covers l > 127 (screen draw area is 0 to 192 / 3 * 2 (128)
 893+ C7FA 20 26       >                        jr      nz,.NoBottomPixelPair                   ;
 894+ C7FC                                      SetIYMinusOffset ixh
 894+ C7FC D5 E5 FD E5 >                        push    de,,hl,,iy                      ; save hl, then hl = iy
 894+ C800 E1          >                        pop     hl                              ;
 894+ C801 DD 7C       >                        ld      a,ixh
 894+ C803 87          >                        add     a,a
 894+ C804 5F          >                        ld      e,a
 894+ C805 16 00       >                        ld      d,0
 894+ C807             >                        ClearCarryFlag
 894+ C807 B7          >                        or a
 894+ C808 ED 52       >                        sbc     hl,de
 894+ C80A E5          >                        push    hl
 894+ C80B FD E1       >                        pop     iy
 894+ C80D E1 D1       >                        pop     de,,hl
 895+ C80F              .Write2YCoord:          IYEquRowN l                             ; set up iy as target address
 895+ C80F 7D          >                        ld      a,l
 895+ C810 21 9F C0    >                        ld      hl,SBnKLineArray
 895+ C813 ED 31       >                        add     hl,a
 895+ C815 ED 31       >                        add     hl,a
 895+ C817 E5          >                        push    hl
 895+ C818 FD E1       >                        pop     iy
 896+ C81A DD 7D                                ld      a,ixl
 897+ C81C CD B6 C8                             call    ProcessXRowA
 898+ C81F C3 22 C8                             jp      .Plot3
 899+ C822              .NoBottomPixelPair:     ;break
 900+ C822              ; Process CY+X CX+Y & CY+X CX-Y..................................
 901+ C822 2A 5A C5     .Plot3:                 ld      hl, (SunScrnY)
 902+ C825 DD 7D        .Get3YRow:              ld      a,ixl
 903+ C827 ED 31                                add     hl,a                            ; Check to see if CY+Y
 904+ C829              .Check3YRowOnScreen:    CheckRowHLOnScreen .NoTop3PixelPair
 904+ C829 7C          >                        ld      a,h                             ; is h byte set, i.e > 256 or < 0
 904+ C82A A7          >                        and     a                               ; .
 904+ C82B 20 26       >                        jr      nz,.NoTop3PixelPair                   ; h <> 0 so fails (covers <0 and > 255
 904+ C82D 7D          >                        ld      a,l                             ; l bit 7 0?
 904+ C82E E6 80       >                        and     Bit7Only                        ; covers l > 127 (screen draw area is 0 to 192 / 3 * 2 (128)
 904+ C830 20 21       >                        jr      nz,.NoTop3PixelPair                   ;
 905+ C832                                      SetIYPlusOffset ixl
 905+ C832 E5 FD E5    >                        push    hl,,iy                          ; save hl, then hl = iy
 905+ C835 E1          >                        pop     hl                              ;
 905+ C836 DD 7D       >                        ld      a,ixl
 905+ C838 ED 31       >                        add     hl,a
 905+ C83A ED 31       >                        add     hl,a
 905+ C83C E5          >                        push    hl
 905+ C83D FD E1       >                        pop     iy
 905+ C83F E1          >                        pop     hl
 906+ C840              .Write3YCoord:          IYEquRowN l                             ; set up iy as target address
 906+ C840 7D          >                        ld      a,l
 906+ C841 21 9F C0    >                        ld      hl,SBnKLineArray
 906+ C844 ED 31       >                        add     hl,a
 906+ C846 ED 31       >                        add     hl,a
 906+ C848 E5          >                        push    hl
 906+ C849 FD E1       >                        pop     iy
 907+ C84B DD 7C                                ld      a,ixh
 908+ C84D CD B6 C8                             call    ProcessXRowA
 909+ C850 C3 53 C8                             jp      .Plot4
 910+ C853              .NoTop3PixelPair:       ;break
 911+ C853              ; Process CY-X CX+Y & CY-X CX-Y..................................
 912+ C853 2A 5A C5     .Plot4:                 ld      hl, (SunScrnY)
 913+ C856 16 00        .Get4YRow:              ld      d,0
 914+ C858 DD 5D                                ld      e,ixl
 915+ C85A                                      ClearCarryFlag
 915+ C85A B7          >                        or a
 916+ C85B ED 52                                sbc     hl,de
 917+ C85D              .Check4YRowOnScreen:    CheckRowHLOnScreen .NoBottom4PixelPair
 917+ C85D 7C          >                        ld      a,h                             ; is h byte set, i.e > 256 or < 0
 917+ C85E A7          >                        and     a                               ; .
 917+ C85F 20 28       >                        jr      nz,.NoBottom4PixelPair                   ; h <> 0 so fails (covers <0 and > 255
 917+ C861 7D          >                        ld      a,l                             ; l bit 7 0?
 917+ C862 E6 80       >                        and     Bit7Only                        ; covers l > 127 (screen draw area is 0 to 192 / 3 * 2 (128)
 917+ C864 20 23       >                        jr      nz,.NoBottom4PixelPair                   ;
 918+ C866                                      SetIYMinusOffset ixl
 918+ C866 D5 E5 FD E5 >                        push    de,,hl,,iy                      ; save hl, then hl = iy
 918+ C86A E1          >                        pop     hl                              ;
 918+ C86B DD 7D       >                        ld      a,ixl
 918+ C86D 87          >                        add     a,a
 918+ C86E 5F          >                        ld      e,a
 918+ C86F 16 00       >                        ld      d,0
 918+ C871             >                        ClearCarryFlag
 918+ C871 B7          >                        or a
 918+ C872 ED 52       >                        sbc     hl,de
 918+ C874 E5          >                        push    hl
 918+ C875 FD E1       >                        pop     iy
 918+ C877 E1 D1       >                        pop     de,,hl
 919+ C879              .Write4YCoord:          IYEquRowN l                             ; set up iy as target address
 919+ C879 7D          >                        ld      a,l
 919+ C87A 21 9F C0    >                        ld      hl,SBnKLineArray
 919+ C87D ED 31       >                        add     hl,a
 919+ C87F ED 31       >                        add     hl,a
 919+ C881 E5          >                        push    hl
 919+ C882 FD E1       >                        pop     iy
 920+ C884 DD 7C                                ld      a,ixh
 921+ C886 CD B6 C8                             call    ProcessXRowA
 922+ C889              .NoBottom4PixelPair:
 923+ C889              ; Completed one iteration........................................
 924+ C889 D9                                   exx
 925+ C88A CB 7C        .IncrementCircle:	    bit     7,h				; Check for Hl<=0
 926+ C88C 28 03                                jr z,   .draw_circle_1
 927+ C88E 19                                   add hl,de			; Delta=Delta+D1
 928+ C88F 18 05                                jr      .draw_circle_2		;
 929+ C891 09           .draw_circle_1:		    add     hl,bc			; Delta=Delta+D2
 930+ C892 03                                   inc     bc
 931+ C893 03                                   inc     bc				; D2=D2+2
 932+ C894 DD 25                                dec     ixh				; Y=Y-1
 933+ C896 03           .draw_circle_2:		    inc bc				    ; D2=D2+2
 934+ C897 03                                   inc bc
 935+ C898 13                                   inc de				    ; D1=D1+2
 936+ C899 13                                   inc de
 937+ C89A DD 2C                                inc ixl				    ; X=X+1
 938+ C89C C3 B2 C7                             jp      .CircleLoop
 939+ C89F 2A 58 C5     SunCircleSinglePixel:     ld      hl,(SunScrnX)
 940+ C8A2 7C                                   ld      a,h
 941+ C8A3 A7                                   and     a
 942+ C8A4 C0                                   ret     nz                  ; if the high byte is set then no pixel
 943+ C8A5 4D                                   ld      c,l
 944+ C8A6 2A 5A C5                             ld      hl,(SunScrnY)
 945+ C8A9 7C                                   ld      a,h
 946+ C8AA A7                                   and     a
 947+ C8AB C0                                   ret     nz                  ; if the high byte is set then no pixel
 948+ C8AC 7D                                   ld      a,l
 949+ C8AD CB 7F                                bit     7,a
 950+ C8AF C0                                   ret     nz                  ; if l > 127 then no pixel
 951+ C8B0 47                                   ld      b,a
 952+ C8B1 7B                                   ld		a,e
 953+ C8B2 CD 43 E1                             call	l2_plot_pixel_y_test
 954+ C8B5 C9                                   ret
 955+ C8B6
 956+ C8B6              ProcessXRowA:           ;break
 957+ C8B6 2A 58 C5                             ld      hl,(SunScrnX)                    ; get X Center
 958+ C8B9 F5                                   push    af                              ; save A (curent offset +/- value
 959+ C8BA ED 31                                add     hl,a                            ; Hl = HL + offset
 960+ C8BC 7C                                   ld      a,h                             ; is HL negative?, if so then set C to 0
 961+ C8BD CB 7F                                bit     7,a                             ;
 962+ C8BF 20 14                                jr      nz,.XCoordNegative              ; We can have this for non X + Radius i.e. the equater
 963+ C8C1 A7                                   and     a                               ; if H <> 0? (why by here must be +ve), set c to $FF
 964+ C8C2 20 16                                jr      nz,.XCoordMaxed                 ; .
 965+ C8C4 4D                                   ld      c,l                             ; else set c to l and do the -ve offset
 966+ C8C5 C5           .AddFuzz:               push    bc
 967+ C8C6 CD AD 88                             call    doRandom                        ; c = c - random AND ragged Size
 968+ C8C9 C1                                   pop     bc
 969+ C8CA 21 55 C5                             ld      hl,RaggedSize                   ;
 970+ C8CD A6                                   and     (hl)                            ;
 971+ C8CE 81                                   add     c                               ;
 972+ C8CF 4F                                   ld      c,a                             ;
 973+ C8D0 38 08                                jr      c,.XCoordMaxed                  ; has fuzz caused a carry, if so > 255 to make 255
 974+ C8D2 C3 DC C8                             jp      .ProcessSubtract                ;
 975+ C8D5 0E 00        .XCoordNegative:        ld      c,0                             ; if it was negative then 0
 976+ C8D7 C3 DC C8                             jp      .ProcessSubtract
 977+ C8DA 0E FF        .XCoordMaxed:           ld      c,255                           ; if it was +ve then 255
 978+ C8DC F1           .ProcessSubtract:       pop     af                              ; get offset back
 979+ C8DD 5F                                   ld      e,a                             ; but goes into DE as its a subtract
 980+ C8DE 16 00                                ld      d,0
 981+ C8E0 2A 58 C5                             ld      hl,(SunScrnX)                    ; so do subtract
 982+ C8E3                                      ClearCarryFlag                          ; .
 982+ C8E3 B7          >                        or a
 983+ C8E4 ED 52                                sbc     hl,de                           ; .
 984+ C8E6 FA 03 C9                             jp      m,.XCoordLeftNegative           ; again test for min max
 985+ C8E9 E5 C5        .AddFuzzSubtract:       push    hl,,bc
 986+ C8EB CD AD 88                             call    doRandom                        ; c = c - random AND ragged Size
 987+ C8EE C1                                   pop     bc
 988+ C8EF 21 55 C5                             ld      hl,RaggedSize                   ;
 989+ C8F2 A6                                   and     (hl)                            ;
 990+ C8F3 5F                                   ld      e,a
 991+ C8F4 E1                                   pop     hl
 992+ C8F5 ED 52                                sbc     hl,de
 993+ C8F7 FA 03 C9                             jp      m,.XCoordLeftNegative           ; again test for min max
 994+ C8FA 7C                                   ld      a,h
 995+ C8FB A7                                   and     a
 996+ C8FC C2 08 C9                             jp      nz,.XCordLeftMaxed
 997+ C8FF 45                                   ld      b,l
 998+ C900 C3 0A C9                             jp      .CompletedXCoords
 999+ C903 06 00        .XCoordLeftNegative:    ld      b,0
1000+ C905 C3 0A C9                             jp      .CompletedXCoords
1001+ C908 06 FF        .XCordLeftMaxed:        ld      b,255
1002+ C90A 78           .CompletedXCoords:      ld      a,b
1003+ C90B FD 77 00     .RowSaveIY1             ld      (iy+0),a                        ; iy holds current line array index
1004+ C90E 79                                   ld      a,c
1005+ C90F FD 77 01     .RowSaveIY3             ld      (iy+1),a
1006+ C912 C9                                   ret
1007+ C913
1008+ C913              ; .....................................................
1009+ C913              ; if the universe object is a planet or sun then do that instead
1010+ C913              ;;TODOProcessPlanet:          cp      129
1011+ C913              ;;TODO                        jr      nz, .ItsAPlanet
1012+ C913              ;;TODO.ItsAStar:              ld      a,(SBnKzsgn)
1013+ C913              ;;TODO                        cp      48                               ; if z > 48 (it must be positive to enter this routine)
1014+ C913
1015+ C913
1016+ C913              ; Square Root using tables
1017+ C913              ; DE = number to find
1018+ C913 21 33 CB     SunLookupSqrtDE:        ld      hl,SunSquareRootTable
1019+ C916 7A           .LookupCorseJump:       ld      a,d
1020+ C917 ED 31                                add     hl,a
1021+ C919 ED 31                                add     hl,a
1022+ C91B 7E                                   ld      a,(hl)
1023+ C91C 23                                   inc     hl
1024+ C91D 66                                   ld      h,(hl)
1025+ C91E 6F                                   ld      l,a
1026+ C91F 7E           .FineSearchLoop:        ld      a,(hl)
1027+ C920                                      JumpIfAEqNusng  e, .FoundByte
1027+ C920 BB          >                        cp     e
1027+ C921 CA 2D C9    >                        jp      z,.FoundByte
1028+ C924                                      JumpIfAGTENusng e, .PreviousByte
1028+ C924 BB          >                        cp     e
1028+ C925 D2 30 C9    >                        jp		nc,.PreviousByte
1029+ C928 23           .NotFound:              inc     hl
1030+ C929 23                                   inc     hl
1031+ C92A C3 1F C9                             jp      .FineSearchLoop
1032+ C92D 23           .FoundByte:             inc     hl
1033+ C92E 7E                                   ld      a,(hl)
1034+ C92F C9                                   ret
1035+ C930 2B           .PreviousByte:          dec     hl
1036+ C931 7E                                   ld      a,(hl)
1037+ C932 C9                                   ret
1038+ C933
1039+ C933 33 CB 45 CB  SunRootHighIndex:       DW SunSqr00,SunSqr01,SunSqr02,SunSqr03,SunSqr04,SunSqr05,SunSqr06,SunSqr07,SunSqr08,SunSqr09,SunSqr0A,SunSqr0B,SunSqr0C,SunSqr0D,SunSqr0E,SunSqr0F
1039+ C937 53 CB 5F CB
1039+ C93B 69 CB 71 CB
1039+ C93F 79 CB 81 CB
1039+ C943 89 CB 8F CB
1039+ C947 97 CB 9D CB
1039+ C94B A1 CB A7 CB
1039+ C94F AD CB B3 CB
1040+ C953 B9 CB BF CB                          DW SunSqr10,SunSqr11,SunSqr12,SunSqr13,SunSqr14,SunSqr15,SunSqr16,SunSqr17,SunSqr18,SunSqr19,SunSqr1A,SunSqr1B,SunSqr1C,SunSqr1D,SunSqr1E,SunSqr1F
1040+ C957 C5 CB CB CB
1040+ C95B D1 CB D5 CB
1040+ C95F D9 CB DB CB
1040+ C963 DF CB E3 CB
1040+ C967 E7 CB EB CB
1040+ C96B EF CB F3 CB
1040+ C96F F5 CB F9 CB
1041+ C973 FB CB FF CB                          DW SunSqr20,SunSqr21,SunSqr22,SunSqr23,SunSqr24,SunSqr25,SunSqr26,SunSqr27,SunSqr28,SunSqr29,SunSqr2A,SunSqr2B,SunSqr2C,SunSqr2D,SunSqr2E,SunSqr2F
1041+ C977 03 CC 05 CC
1041+ C97B 07 CC 0B CC
1041+ C97F 0D CC 0F CC
1041+ C983 13 CC 15 CC
1041+ C987 17 CC 19 CC
1041+ C98B 1D CC 1F CC
1041+ C98F 21 CC 25 CC
1042+ C993 29 CC 2D CC                          DW SunSqr30,SunSqr31,SunSqr32,SunSqr33,SunSqr34,SunSqr35,SunSqr36,SunSqr37,SunSqr38,SunSqr39,SunSqr3A,SunSqr3B,SunSqr3C,SunSqr3D,SunSqr3E,SunSqr3F
1042+ C997 31 CC 35 CC
1042+ C99B 37 CC 3B CC
1042+ C99F 3F CC 43 CC
1042+ C9A3 45 CC 49 CC
1042+ C9A7 4D CC 51 CC
1042+ C9AB 55 CC 59 CC
1042+ C9AF 5D CC 61 CC
1043+ C9B3 65 CC 69 CC                          DW SunSqr40,SunSqr41,SunSqr42,SunSqr43,SunSqr44,SunSqr45,SunSqr46,SunSqr47,SunSqr48,SunSqr49,SunSqr4A,SunSqr4B,SunSqr4C,SunSqr4D,SunSqr4E,SunSqr4F
1043+ C9B7 6D CC 71 CC
1043+ C9BB 75 CC 79 CC
1043+ C9BF 7D CC 81 CC
1043+ C9C3 85 CC 89 CC
1043+ C9C7 8D CC 91 CC
1043+ C9CB 95 CC 99 CC
1043+ C9CF 9D CC A1 CC
1044+ C9D3 A5 CC A7 CC                          DW SunSqr50,SunSqr51,SunSqr52,SunSqr53,SunSqr54,SunSqr55,SunSqr56,SunSqr57,SunSqr58,SunSqr59,SunSqr5A,SunSqr5B,SunSqr5C,SunSqr5D,SunSqr5E,SunSqr5F
1044+ C9D7 AB CC AF CC
1044+ C9DB B3 CC B7 CC
1044+ C9DF BB CC BF CC
1044+ C9E3 C3 CC C5 CC
1044+ C9E7 C9 CC CD CC
1044+ C9EB D1 CC D5 CC
1044+ C9EF D9 CC DB CC
1045+ C9F3 DF CC E3 CC                          DW SunSqr60,SunSqr61,SunSqr62,SunSqr63,SunSqr64,SunSqr65,SunSqr66,SunSqr67,SunSqr68,SunSqr69,SunSqr6A,SunSqr6B,SunSqr6C,SunSqr6D,SunSqr6E,SunSqr6F
1045+ C9F7 E7 CC EB CC
1045+ C9FB ED CC F1 CC
1045+ C9FF F5 CC F9 CC
1045+ CA03 FD CC FF CC
1045+ CA07 03 CD 07 CD
1045+ CA0B 0B CD 0D CD
1045+ CA0F 0F CD 13 CD
1046+ CA13 17 CD 1B CD                          DW SunSqr70,SunSqr71,SunSqr72,SunSqr73,SunSqr74,SunSqr75,SunSqr76,SunSqr77,SunSqr78,SunSqr79,SunSqr7A,SunSqr7B,SunSqr7C,SunSqr7D,SunSqr7E,SunSqr7F
1046+ CA17 1F CD 23 CD
1046+ CA1B 27 CD 2B CD
1046+ CA1F 2D CD 31 CD
1046+ CA23 35 CD 37 CD
1046+ CA27 3B CD 3F CD
1046+ CA2B 43 CD 45 CD
1046+ CA2F 49 CD 4D CD
1047+ CA33 51 CD 53 CD                          DW SunSqr80,SunSqr81,SunSqr82,SunSqr83,SunSqr84,SunSqr85,SunSqr86,SunSqr87,SunSqr88,SunSqr89,SunSqr8A,SunSqr8B,SunSqr8C,SunSqr8D,SunSqr8E,SunSqr8F
1047+ CA37 57 CD 59 CD
1047+ CA3B 5D CD 61 CD
1047+ CA3F 65 CD 67 CD
1047+ CA43 6B CD 6F CD
1047+ CA47 71 CD 75 CD
1047+ CA4B 79 CD 7B CD
1047+ CA4F 7F CD 83 CD
1048+ CA53 85 CD 89 CD                          DW SunSqr90,SunSqr91,SunSqr92,SunSqr93,SunSqr94,SunSqr95,SunSqr96,SunSqr97,SunSqr98,SunSqr99,SunSqr9A,SunSqr9B,SunSqr9C,SunSqr9D,SunSqr9E,SunSqr9F
1048+ CA57 8D CD 8F CD
1048+ CA5B 93 CD 97 CD
1048+ CA5F 99 CD 9D CD
1048+ CA63 A1 CD A3 CD
1048+ CA67 A7 CD AB CD
1048+ CA6B AD CD B1 CD
1048+ CA6F B5 CD B7 CD
1049+ CA73 BB CD BF CD                          DW SunSqrA0,SunSqrA1,SunSqrA2,SunSqrA3,SunSqrA4,SunSqrA5,SunSqrA6,SunSqrA7,SunSqrA8,SunSqrA9,SunSqrAA,SunSqrAB,SunSqrAC,SunSqrAD,SunSqrAE,SunSqrAF
1049+ CA77 C1 CD C5 CD
1049+ CA7B C7 CD CB CD
1049+ CA7F CF CD D1 CD
1049+ CA83 D5 CD D7 CD
1049+ CA87 DB CD DF CD
1049+ CA8B E1 CD E5 CD
1049+ CA8F E9 CD EB CD
1050+ CA93 ED CD EF CD                          DW SunSqrB0,SunSqrB1,SunSqrB2,SunSqrB3,SunSqrB4,SunSqrB5,SunSqrB6,SunSqrB7,SunSqrB8,SunSqrB9,SunSqrBA,SunSqrBB,SunSqrBC,SunSqrBD,SunSqrBE,SunSqrBF
1050+ CA97 F3 CD F7 CD
1050+ CA9B F9 CD FD CD
1050+ CA9F FF CD 03 CE
1050+ CAA3 07 CE 0B CE
1050+ CAA7 0D CE 0F CE
1050+ CAAB 13 CE 15 CE
1050+ CAAF 19 CE 1D CE
1051+ CAB3 1F CE 23 CE                          DW SunSqrC0,SunSqrC1,SunSqrC2,SunSqrC3,SunSqrC4,SunSqrC5,SunSqrC6,SunSqrC7,SunSqrC8,SunSqrC9,SunSqrCA,SunSqrCB,SunSqrCC,SunSqrCD,SunSqrCE,SunSqrCF
1051+ CAB7 25 CE 29 CE
1051+ CABB 2B CE 2F CE
1051+ CABF 33 CE 35 CE
1051+ CAC3 37 CE 39 CE
1051+ CAC7 3D CE 3F CE
1051+ CACB 43 CE 47 CE
1051+ CACF 49 CE 4D CE
1052+ CAD3 4F CE 53 CE                          DW SunSqrD0,SunSqrD1,SunSqrD2,SunSqrD3,SunSqrD4,SunSqrD5,SunSqrD6,SunSqrD7,SunSqrD8,SunSqrD9,SunSqrDA,SunSqrDB,SunSqrDC,SunSqrDD,SunSqrDE,SunSqrDF
1052+ CAD7 55 CE 59 CE
1052+ CADB 5B CE 5F CE
1052+ CADF 63 CE 65 CE
1052+ CAE3 69 CE 6B CE
1052+ CAE7 6F CE 71 CE
1052+ CAEB 75 CE 77 CE
1052+ CAEF 79 CE 7B CE
1053+ CAF3 7F CE 83 CE                          DW SunSqrE0,SunSqrE1,SunSqrE2,SunSqrE3,SunSqrE4,SunSqrE5,SunSqrE6,SunSqrE7,SunSqrE8,SunSqrE9,SunSqrEA,SunSqrEB,SunSqrEC,SunSqrED,SunSqrEE,SunSqrEF
1053+ CAF7 87 CE 8B CE
1053+ CAFB 8F CE 93 CE
1053+ CAFF 95 CE 99 CE
1053+ CB03 9D CE A1 CE
1053+ CB07 A3 CE A7 CE
1053+ CB0B A9 CE AB CE
1053+ CB0F AD CE B1 CE
1054+ CB13 B3 CE B5 CE                          DW SunSqrF0,SunSqrF1,SunSqrF2,SunSqrF3,SunSqrF4,SunSqrF5,SunSqrF6,SunSqrF7,SunSqrF8,SunSqrF9,SunSqrFA,SunSqrFB,SunSqrFC,SunSqrFD,SunSqrFE,SunSqrFF
1054+ CB17 B7 CE BB CE
1054+ CB1B BD CE C1 CE
1054+ CB1F C3 CE C7 CE
1054+ CB23 C9 CE CD CE
1054+ CB27 CF CE D3 CE
1054+ CB2B D5 CE D9 CE
1054+ CB2F DB CE DD CE
1055+ CB33
1056+ CB33              SunSquareRootTable:
1057+ CB33 00 00        SunSqr00:               DB $00,   0
1058+ CB35 04 02                                DB $04,   2
1059+ CB37 10 04                                DB $10,   4
1060+ CB39 24 06                                DB $24,   6
1061+ CB3B 40 08                                DB $40,   8
1062+ CB3D 64 0A                                DB $64,  10
1063+ CB3F 90 0C                                DB $90,  12
1064+ CB41 C4 0E                                DB $C4,  14
1065+ CB43 FF 0F                                DB $FF,  15
1066+ CB45 00 10        SunSqr01:               DB $00,  16
1067+ CB47 21 11                                DB $21,  17
1068+ CB49 44 12                                DB $44,  18
1069+ CB4B 69 13                                DB $69,  19
1070+ CB4D 90 14                                DB $90,  20
1071+ CB4F B9 15                                DB $B9,  21
1072+ CB51 FF 16                                DB $FF,  22
1073+ CB53 11 17        SunSqr02:               DB $11,  23
1074+ CB55 40 18                                DB $40,  24
1075+ CB57 71 19                                DB $71,  25
1076+ CB59 A4 1A                                DB $A4,  26
1077+ CB5B D9 1B                                DB $D9,  27
1078+ CB5D FF 1B                                DB $FF,  27
1079+ CB5F 10 1C        SunSqr03:               DB $10,  28
1080+ CB61 49 1D                                DB $49,  29
1081+ CB63 84 1E                                DB $84,  30
1082+ CB65 C1 1F                                DB $C1,  31
1083+ CB67 FF 1F                                DB $FF,  31
1084+ CB69 00 20        SunSqr04:               DB $00,  32
1085+ CB6B 41 21                                DB $41,  33
1086+ CB6D 84 22                                DB $84,  34
1087+ CB6F FF 23                                DB $FF,  35
1088+ CB71 10 24        SunSqr05:               DB $10,  36
1089+ CB73 59 25                                DB $59,  37
1090+ CB75 A4 26                                DB $A4,  38
1091+ CB77 FF 27                                DB $FF,  39
1092+ CB79 40 28        SunSqr06:               DB $40,  40
1093+ CB7B 91 29                                DB $91,  41
1094+ CB7D E4 2A                                DB $E4,  42
1095+ CB7F FF 2A                                DB $FF,  42
1096+ CB81 39 2B        SunSqr07:               DB $39,  43
1097+ CB83 90 2C                                DB $90,  44
1098+ CB85 E9 2D                                DB $E9,  45
1099+ CB87 FF 2D                                DB $FF,  45
1100+ CB89 44 2E        SunSqr08:               DB $44,  46
1101+ CB8B A1 2F                                DB $A1,  47
1102+ CB8D FF 2F                                DB $FF,  47
1103+ CB8F 00 30        SunSqr09:               DB $00,  48
1104+ CB91 61 31                                DB $61,  49
1105+ CB93 C4 32                                DB $C4,  50
1106+ CB95 FF 32                                DB $FF,  50
1107+ CB97 29 33        SunSqr0A:               DB $29,  51
1108+ CB99 90 34                                DB $90,  52
1109+ CB9B FF 35                                DB $FF,  53
1110+ CB9D 64 36        SunSqr0B:               DB $64,  54
1111+ CB9F FF 37                                DB $FF,  55
1112+ CBA1 40 38        SunSqr0C:               DB $40,  56
1113+ CBA3 B1 39                                DB $B1,  57
1114+ CBA5 FF 39                                DB $FF,  57
1115+ CBA7 24 3A        SunSqr0D:               DB $24,  58
1116+ CBA9 99 3B                                DB $99,  59
1117+ CBAB FF 3B                                DB $FF,  59
1118+ CBAD 10 3C        SunSqr0E:               DB $10,  60
1119+ CBAF 89 3D                                DB $89,  61
1120+ CBB1 FF 3D                                DB $FF,  61
1121+ CBB3 04 3E        SunSqr0F:               DB $04,  62
1122+ CBB5 81 3F                                DB $81,  63
1123+ CBB7 FF 3F                                DB $FF,  63
1124+ CBB9 00 40        SunSqr10:               DB $00,  64
1125+ CBBB 81 41                                DB $81,  65
1126+ CBBD FF 41                                DB $FF,  65
1127+ CBBF 04 42        SunSqr11:               DB $04,  66
1128+ CBC1 89 43                                DB $89,  67
1129+ CBC3 FF 43                                DB $FF,  67
1130+ CBC5 10 44        SunSqr12:               DB $10,  68
1131+ CBC7 99 45                                DB $99,  69
1132+ CBC9 FF 45                                DB $FF,  69
1133+ CBCB 24 46        SunSqr13:               DB $24,  70
1134+ CBCD B1 47                                DB $B1,  71
1135+ CBCF FF 47                                DB $FF,  71
1136+ CBD1 40 48        SunSqr14:               DB $40,  72
1137+ CBD3 FF 49                                DB $FF,  73
1138+ CBD5 64 4A        SunSqr15:               DB $64,  74
1139+ CBD7 FF 4B                                DB $FF,  75
1140+ CBD9 FF 4C        SunSqr16:               DB $FF,  76
1141+ CBDB C4 4D        SunSqr17:               DB $C4,  77
1142+ CBDD FF 4E                                DB $FF,  78
1143+ CBDF 61 4F        SunSqr18:               DB $61,  79
1144+ CBE1 FF 4F                                DB $FF,  79
1145+ CBE3 00 50        SunSqr19:               DB $00,  80
1146+ CBE5 FF 51                                DB $FF,  81
1147+ CBE7 44 52        SunSqr1A:               DB $44,  82
1148+ CBE9 FF 53                                DB $FF,  83
1149+ CBEB 90 54        SunSqr1B:               DB $90,  84
1150+ CBED FF 54                                DB $FF,  84
1151+ CBEF 39 55        SunSqr1C:               DB $39,  85
1152+ CBF1 FF 56                                DB $FF,  86
1153+ CBF3 FF 57        SunSqr1D:               DB $FF,  87
1154+ CBF5 40 58        SunSqr1E:               DB $40,  88
1155+ CBF7 FF 59                                DB $FF,  89
1156+ CBF9 FF 5A        SunSqr1F:               DB $FF,  90
1157+ CBFB 59 5B        SunSqr20:               DB $59,  91
1158+ CBFD FF 5B                                DB $FF,  91
1159+ CBFF 10 5C        SunSqr21:               DB $10,  92
1160+ CC01 FF 5D                                DB $FF,  93
1161+ CC03 FF 5E        SunSqr22:               DB $FF,  94
1162+ CC05 FF 5F        SunSqr23:               DB $FF,  95
1163+ CC07 00 60        SunSqr24:               DB $00,  96
1164+ CC09 FF 61                                DB $FF,  97
1165+ CC0B 84 62        SunSqr25:               DB $84,  98
1166+ CC0D 49 63        SunSqr26:               DB $49,  99
1167+ CC0F 10 64        SunSqr27:               DB $10, 100
1168+ CC11 FF 65                                DB $FF, 101
1169+ CC13 FF 66        SunSqr28:               DB $FF, 102
1170+ CC15 FF 67        SunSqr29:               DB $FF, 103
1171+ CC17 FF 68        SunSqr2A:               DB $FF, 104
1172+ CC19 11 69        SunSqr2B:               DB $11, 105
1173+ CC1B FF 6A                                DB $FF, 106
1174+ CC1D FF 6B        SunSqr2C:               DB $FF, 107
1175+ CC1F FF 6C        SunSqr2D:               DB $FF, 108
1176+ CC21 69 6D        SunSqr2E:               DB $69, 109
1177+ CC23 FF 6E                                DB $FF, 110
1178+ CC25 44 6E        SunSqr2F:               DB $44, 110
1179+ CC27 FF 6F                                DB $FF, 111
1180+ CC29 21 6F        SunSqr30:               DB $21, 111
1181+ CC2B FF 70                                DB $FF, 112
1182+ CC2D 00 70        SunSqr31:               DB $00, 112
1183+ CC2F FF 71                                DB $FF, 113
1184+ CC31 C4 72        SunSqr32:               DB $C4, 114
1185+ CC33 FF 72                                DB $FF, 114
1186+ CC35 FF 73        SunSqr33:               DB $FF, 115
1187+ CC37 90 74        SunSqr34:               DB $90, 116
1188+ CC39 FF 75                                DB $FF, 117
1189+ CC3B 79 75        SunSqr35:               DB $79, 117
1190+ CC3D FF 76                                DB $FF, 118
1191+ CC3F 64 76        SunSqr36:               DB $64, 118
1192+ CC41 64 77                                DB $64, 119
1193+ CC43 51 77        SunSqr37:               DB $51, 119
1194+ CC45 40 78        SunSqr38:               DB $40, 120
1195+ CC47 FF 79                                DB $FF, 121
1196+ CC49 31 79        SunSqr39:               DB $31, 121
1197+ CC4B FF 7A                                DB $FF, 122
1198+ CC4D 24 7A        SunSqr3A:               DB $24, 122
1199+ CC4F FF 7B                                DB $FF, 123
1200+ CC51 19 7B        SunSqr3B:               DB $19, 123
1201+ CC53 FF 7C                                DB $FF, 124
1202+ CC55 10 7C        SunSqr3C:               DB $10, 124
1203+ CC57 FF 7D                                DB $FF, 125
1204+ CC59 09 7D        SunSqr3D:               DB $09, 125
1205+ CC5B FF 7D                                DB $FF, 125
1206+ CC5D 04 7E        SunSqr3E:               DB $04, 126
1207+ CC5F FF 7E                                DB $FF, 126
1208+ CC61 01 7F        SunSqr3F:               DB $01, 127
1209+ CC63 FF 7F                                DB $FF, 127
1210+ CC65 00 80        SunSqr40:               DB $00, 128
1211+ CC67 FF 80                                DB $FF, 128
1212+ CC69 01 81        SunSqr41:               DB $01, 129
1213+ CC6B FF 82                                DB $FF, 130
1214+ CC6D 04 82        SunSqr42:               DB $04, 130
1215+ CC6F FF 83                                DB $FF, 131
1216+ CC71 09 83        SunSqr43:               DB $09, 131
1217+ CC73 FF 84                                DB $FF, 132
1218+ CC75 10 84        SunSqr44:               DB $10, 132
1219+ CC77 FF 85                                DB $FF, 133
1220+ CC79 19 85        SunSqr45:               DB $19, 133
1221+ CC7B FF 86                                DB $FF, 134
1222+ CC7D 24 86        SunSqr46:               DB $24, 134
1223+ CC7F FF 87                                DB $FF, 135
1224+ CC81 31 87        SunSqr47:               DB $31, 135
1225+ CC83 FF 88                                DB $FF, 136
1226+ CC85 40 88        SunSqr48:               DB $40, 136
1227+ CC87 FF 89                                DB $FF, 137
1228+ CC89 51 89        SunSqr49:               DB $51, 137
1229+ CC8B FF 8A                                DB $FF, 138
1230+ CC8D 64 8A        SunSqr4A:               DB $64, 138
1231+ CC8F FF 8A                                DB $FF, 138
1232+ CC91 79 8B        SunSqr4B:               DB $79, 139
1233+ CC93 FF 8B                                DB $FF, 139
1234+ CC95 90 8C        SunSqr4C:               DB $90, 140
1235+ CC97 FF 8C                                DB $FF, 140
1236+ CC99 A9 8D        SunSqr4D:               DB $A9, 141
1237+ CC9B FF 8D                                DB $FF, 141
1238+ CC9D C4 8E        SunSqr4E:               DB $C4, 142
1239+ CC9F FF 8E                                DB $FF, 142
1240+ CCA1 E1 8F        SunSqr4F:               DB $E1, 143
1241+ CCA3 FF 8F                                DB $FF, 143
1242+ CCA5 FF 8F        SunSqr50:               DB $FF, 143
1243+ CCA7 00 90        SunSqr51:               DB $00, 144
1244+ CCA9 FF 90                                DB $FF, 144
1245+ CCAB 21 91        SunSqr52:               DB $21, 145
1246+ CCAD FF 91                                DB $FF, 145
1247+ CCAF 44 92        SunSqr53:               DB $44, 146
1248+ CCB1 FF 92                                DB $FF, 146
1249+ CCB3 69 93        SunSqr54:               DB $69, 147
1250+ CCB5 FF 93                                DB $FF, 147
1251+ CCB7 90 94        SunSqr55:               DB $90, 148
1252+ CCB9 FF 94                                DB $FF, 148
1253+ CCBB B9 95        SunSqr56:               DB $B9, 149
1254+ CCBD FF 95                                DB $FF, 149
1255+ CCBF E4 96        SunSqr57:               DB $E4, 150
1256+ CCC1 FF 96                                DB $FF, 150
1257+ CCC3 FF 96        SunSqr58:               DB $FF, 150
1258+ CCC5 11 97        SunSqr59:               DB $11, 151
1259+ CCC7 FF 97                                DB $FF, 151
1260+ CCC9 40 98        SunSqr5A:               DB $40, 152
1261+ CCCB FF 98                                DB $FF, 152
1262+ CCCD 71 99        SunSqr5B:               DB $71, 153
1263+ CCCF FF 99                                DB $FF, 153
1264+ CCD1 A4 9A        SunSqr5C:               DB $A4, 154
1265+ CCD3 FF 9A                                DB $FF, 154
1266+ CCD5 D9 9B        SunSqr5D:               DB $D9, 155
1267+ CCD7 FF 9B                                DB $FF, 155
1268+ CCD9 FF 9B        SunSqr5E:               DB $FF, 155
1269+ CCDB 10 9C        SunSqr5F:               DB $10, 156
1270+ CCDD FF 9C                                DB $FF, 156
1271+ CCDF 49 9D        SunSqr60:               DB $49, 157
1272+ CCE1 FF 9D                                DB $FF, 157
1273+ CCE3 84 9E        SunSqr61:               DB $84, 158
1274+ CCE5 FF 9E                                DB $FF, 158
1275+ CCE7 C1 9F        SunSqr62:               DB $C1, 159
1276+ CCE9 FF 9F                                DB $FF, 159
1277+ CCEB FF 9F        SunSqr63:               DB $FF, 159
1278+ CCED 00 A0        SunSqr64:               DB $00, 160
1279+ CCEF FF A0                                DB $FF, 160
1280+ CCF1 41 A1        SunSqr65:               DB $41, 161
1281+ CCF3 FF A1                                DB $FF, 161
1282+ CCF5 84 A2        SunSqr66:               DB $84, 162
1283+ CCF7 FF A2                                DB $FF, 162
1284+ CCF9 C9 A3        SunSqr67:               DB $C9, 163
1285+ CCFB FF A3                                DB $FF, 163
1286+ CCFD FF A3        SunSqr68:               DB $FF, 163
1287+ CCFF 10 A4        SunSqr69:               DB $10, 164
1288+ CD01 FF A4                                DB $FF, 164
1289+ CD03 59 A5        SunSqr6A:               DB $59, 165
1290+ CD05 FF A5                                DB $FF, 165
1291+ CD07 A4 A6        SunSqr6B:               DB $A4, 166
1292+ CD09 FF A6                                DB $FF, 166
1293+ CD0B FF A7        SunSqr6C:               DB $FF, 167
1294+ CD0D FF A7        SunSqr6D:               DB $FF, 167
1295+ CD0F 40 A8        SunSqr6E:               DB $40, 168
1296+ CD11 FF A8                                DB $FF, 168
1297+ CD13 91 A9        SunSqr6F:               DB $91, 169
1298+ CD15 FF A9                                DB $FF, 169
1299+ CD17 E4 AA        SunSqr70:               DB $E4, 170
1300+ CD19 FF AA                                DB $FF, 170
1301+ CD1B 00 AA        SunSqr71:               DB $00, 170
1302+ CD1D FF AA                                DB $FF, 170
1303+ CD1F 39 AB        SunSqr72:               DB $39, 171
1304+ CD21 FF AB                                DB $FF, 171
1305+ CD23 90 AC        SunSqr73:               DB $90, 172
1306+ CD25 FF AC                                DB $FF, 172
1307+ CD27 E9 AD        SunSqr74:               DB $E9, 173
1308+ CD29 FF AD                                DB $FF, 173
1309+ CD2B FF AD        SunSqr75:               DB $FF, 173
1310+ CD2D 44 AE        SunSqr76:               DB $44, 174
1311+ CD2F FF AE                                DB $FF, 174
1312+ CD31 A1 AF        SunSqr77:               DB $A1, 175
1313+ CD33 FF AF                                DB $FF, 175
1314+ CD35 FF AF        SunSqr78:               DB $FF, 175
1315+ CD37 00 B0        SunSqr79:               DB $00, 176
1316+ CD39 FF B0                                DB $FF, 176
1317+ CD3B 61 B1        SunSqr7A:               DB $61, 177
1318+ CD3D FF B1                                DB $FF, 177
1319+ CD3F C4 B2        SunSqr7B:               DB $C4, 178
1320+ CD41 FF B2                                DB $FF, 178
1321+ CD43 FF B2        SunSqr7C:               DB $FF, 178
1322+ CD45 29 B3        SunSqr7D:               DB $29, 179
1323+ CD47 FF B3                                DB $FF, 179
1324+ CD49 90 B4        SunSqr7E:               DB $90, 180
1325+ CD4B FF B4                                DB $FF, 180
1326+ CD4D F9 B5        SunSqr7F:               DB $F9, 181
1327+ CD4F FF B5                                DB $FF, 181
1328+ CD51 FF B5        SunSqr80:               DB $FF, 181
1329+ CD53 64 B6        SunSqr81:               DB $64, 182
1330+ CD55 FF B6                                DB $FF, 182
1331+ CD57 D1 B7        SunSqr82:               DB $D1, 183
1332+ CD59 FF B7        SunSqr83:               DB $FF, 183
1333+ CD5B FF B7                                DB $FF, 183
1334+ CD5D 40 B8        SunSqr84:               DB $40, 184
1335+ CD5F FF B8                                DB $FF, 184
1336+ CD61 B1 B9        SunSqr85:               DB $B1, 185
1337+ CD63 FF B9                                DB $FF, 185
1338+ CD65 FF B9        SunSqr86:               DB $FF, 185
1339+ CD67 24 BA        SunSqr87:               DB $24, 186
1340+ CD69 FF BA                                DB $FF, 186
1341+ CD6B 99 BB        SunSqr88:               DB $99, 187
1342+ CD6D FF BB                                DB $FF, 187
1343+ CD6F FF BB        SunSqr89:               DB $FF, 187
1344+ CD71 10 BC        SunSqr8A:               DB $10, 188
1345+ CD73 FF BC                                DB $FF, 188
1346+ CD75 89 BD        SunSqr8B:               DB $89, 189
1347+ CD77 FF BD                                DB $FF, 189
1348+ CD79 FF BD        SunSqr8C:               DB $FF, 189
1349+ CD7B 04 BE        SunSqr8D:               DB $04, 190
1350+ CD7D FF BE                                DB $FF, 190
1351+ CD7F 81 BF        SunSqr8E:               DB $81, 191
1352+ CD81 FF BF                                DB $FF, 191
1353+ CD83 FF BF        SunSqr8F:               DB $FF, 191
1354+ CD85 00 C0        SunSqr90:               DB $00, 192
1355+ CD87 FF C0                                DB $FF, 192
1356+ CD89 81 C1        SunSqr91:               DB $81, 193
1357+ CD8B FF C1                                DB $FF, 193
1358+ CD8D FF C1        SunSqr92:               DB $FF, 193
1359+ CD8F 04 C2        SunSqr93:               DB $04, 194
1360+ CD91 FF C2                                DB $FF, 194
1361+ CD93 89 C3        SunSqr94:               DB $89, 195
1362+ CD95 FF C3                                DB $FF, 195
1363+ CD97 FF C3        SunSqr95:               DB $FF, 195
1364+ CD99 10 C4        SunSqr96:               DB $10, 196
1365+ CD9B FF C4                                DB $FF, 196
1366+ CD9D 99 C5        SunSqr97:               DB $99, 197
1367+ CD9F FF C5                                DB $FF, 197
1368+ CDA1 FF C5        SunSqr98:               DB $FF, 197
1369+ CDA3 24 C6        SunSqr99:               DB $24, 198
1370+ CDA5 FF C6                                DB $FF, 198
1371+ CDA7 B1 C7        SunSqr9A:               DB $B1, 199
1372+ CDA9 FF C7                                DB $FF, 199
1373+ CDAB FF C7        SunSqr9B:               DB $FF, 199
1374+ CDAD 40 C8        SunSqr9C:               DB $40, 200
1375+ CDAF FF C8                                DB $FF, 200
1376+ CDB1 D1 C9        SunSqr9D:               DB $D1, 201
1377+ CDB3 FF C9                                DB $FF, 201
1378+ CDB5 FF C9        SunSqr9E:               DB $FF, 201
1379+ CDB7 64 CA        SunSqr9F:               DB $64, 202
1380+ CDB9 FF CA                                DB $FF, 202
1381+ CDBB F9 CB        SunSqrA0:               DB $F9, 203
1382+ CDBD FF CB                                DB $FF, 203
1383+ CDBF FF CB        SunSqrA1:               DB $FF, 203
1384+ CDC1 90 CC        SunSqrA2:               DB $90, 204
1385+ CDC3 FF CC                                DB $FF, 204
1386+ CDC5 FF CC        SunSqrA3:               DB $FF, 204
1387+ CDC7 29 CD        SunSqrA4:               DB $29, 205
1388+ CDC9 FF CD                                DB $FF, 205
1389+ CDCB C4 CE        SunSqrA5:               DB $C4, 206
1390+ CDCD FF CE                                DB $FF, 206
1391+ CDCF FF CE        SunSqrA6:               DB $FF, 206
1392+ CDD1 61 CF        SunSqrA7:               DB $61, 207
1393+ CDD3 FF CF                                DB $FF, 207
1394+ CDD5 FF CF        SunSqrA8:               DB $FF, 207
1395+ CDD7 00 D0        SunSqrA9:               DB $00, 208
1396+ CDD9 FF D0                                DB $FF, 208
1397+ CDDB A1 D1        SunSqrAA:               DB $A1, 209
1398+ CDDD FF D1                                DB $FF, 209
1399+ CDDF FF D1        SunSqrAB:               DB $FF, 209
1400+ CDE1 44 D2        SunSqrAC:               DB $44, 210
1401+ CDE3 FF D2                                DB $FF, 210
1402+ CDE5 E9 D3        SunSqrAD:               DB $E9, 211
1403+ CDE7 FF D3                                DB $FF, 211
1404+ CDE9 FF D3        SunSqrAE:               DB $FF, 211
1405+ CDEB 90 D4        SunSqrAF:               DB $90, 212
1406+ CDED FF D4        SunSqrB0:               DB $FF, 212
1407+ CDEF 39 D5        SunSqrB1:               DB $39, 213
1408+ CDF1 FF D5                                DB $FF, 213
1409+ CDF3 E4 D6        SunSqrB2:               DB $E4, 214
1410+ CDF5 FF D6                                DB $FF, 214
1411+ CDF7 FF D6        SunSqrB3:               DB $FF, 214
1412+ CDF9 91 D7        SunSqrB4:               DB $91, 215
1413+ CDFB FF D7                                DB $FF, 215
1414+ CDFD FF D7        SunSqrB5:               DB $FF, 215
1415+ CDFF 40 D8        SunSqrB6:               DB $40, 216
1416+ CE01 FF D8                                DB $FF, 216
1417+ CE03 F1 D9        SunSqrB7:               DB $F1, 217
1418+ CE05 FF D9                                DB $FF, 217
1419+ CE07 FF D9        SunSqrB8:               DB $FF, 217
1420+ CE09 FF D9                                DB $FF, 217
1421+ CE0B A4 DA        SunSqrB9:               DB $A4, 218
1422+ CE0D FF DA        SunSqrBA:               DB $FF, 218 ; we can reuse SunSeqrBA as  $FF for B9 terminator as well as they have the same target
1423+ CE0F 59 DB        SunSqrBB:               DB $59, 219
1424+ CE11 FF DB                                DB $FF, 219
1425+ CE13 FF DB        SunSqrBC:               DB $FF, 219
1426+ CE15 10 DC        SunSqrBD:               DB $10, 220
1427+ CE17 FF DC                                DB $FF, 220
1428+ CE19 C9 DD        SunSqrBE:               DB $C9, 221
1429+ CE1B FF DD                                DB $FF, 221
1430+ CE1D FF DD        SunSqrBF:               DB $FF, 221
1431+ CE1F 84 DE        SunSqrC0:               DB $84, 222
1432+ CE21 FF DE                                DB $FF, 222
1433+ CE23 FF DE        SunSqrC1:               DB $FF, 222
1434+ CE25 41 DF        SunSqrC2:               DB $41, 223
1435+ CE27 FF DF                                DB $FF, 223
1436+ CE29 FF DF        SunSqrC3:               DB $FF, 223
1437+ CE2B 00 E0        SunSqrC4:               DB $00, 224
1438+ CE2D FF E0                                DB $FF, 224
1439+ CE2F C1 E1        SunSqrC5:               DB $C1, 225
1440+ CE31 FF E1                                DB $FF, 225
1441+ CE33 FF E1        SunSqrC6:               DB $FF, 225
1442+ CE35 84 E2        SunSqrC7:               DB $84, 226
1443+ CE37 FF E2        SunSqrC8:               DB $FF, 226
1444+ CE39 49 E3        SunSqrC9:               DB $49, 227
1445+ CE3B FF E3                                DB $FF, 227
1446+ CE3D FF E4        SunSqrCA:               DB $FF, 228
1447+ CE3F 10 E4        SunSqrCB:               DB $10, 228
1448+ CE41 FF E4                                DB $FF, 228
1449+ CE43 D9 E5        SunSqrCC:               DB $D9, 229
1450+ CE45 FF E5                                DB $FF, 229
1451+ CE47 FF E5        SunSqrCD:               DB $FF, 229
1452+ CE49 A4 E6        SunSqrCE:               DB $A4, 230
1453+ CE4B FF E6                                DB $FF, 230
1454+ CE4D FF E6        SunSqrCF:               DB $FF, 230
1455+ CE4F 71 E7        SunSqrD0:               DB $71, 231
1456+ CE51 FF E7                                DB $FF, 231
1457+ CE53 FF E7        SunSqrD1:               DB $FF, 231
1458+ CE55 40 E8        SunSqrD2:               DB $40, 232
1459+ CE57 FF E8                                DB $FF, 232
1460+ CE59 FF E8        SunSqrD3:               DB $FF, 232
1461+ CE5B 11 E9        SunSqrD4:               DB $11, 233
1462+ CE5D FF E9                                DB $FF, 233
1463+ CE5F E4 EA        SunSqrD5:               DB $E4, 234
1464+ CE61 FF EA                                DB $FF, 234
1465+ CE63 FF EA        SunSqrD6:               DB $FF, 234
1466+ CE65 B9 EB        SunSqrD7:               DB $B9, 235
1467+ CE67 FF EB                                DB $FF, 235
1468+ CE69 FF EB        SunSqrD8:               DB $FF, 235
1469+ CE6B 90 EC        SunSqrD9:               DB $90, 236
1470+ CE6D FF EC                                DB $FF, 236
1471+ CE6F FF EC        SunSqrDA:               DB $FF, 236
1472+ CE71 69 ED        SunSqrDB:               DB $69, 237
1473+ CE73 FF ED                                DB $FF, 237
1474+ CE75 FF ED        SunSqrDC:               DB $FF, 237
1475+ CE77 44 EE        SunSqrDD:               DB $44, 238
1476+ CE79 FF EE        SunSqrDE:               DB $FF, 238
1477+ CE7B 21 EF        SunSqrDF:               DB $21, 239
1478+ CE7D FF EF                                DB $FF, 239
1479+ CE7F 00 F0        SunSqrE0:               DB $00, 240
1480+ CE81 FF F0                                DB $FF, 240
1481+ CE83 00 F0        SunSqrE1:               DB $00, 240
1482+ CE85 FF F0                                DB $FF, 240
1483+ CE87 E1 F1        SunSqrE2:               DB $E1, 241
1484+ CE89 FF F1                                DB $FF, 241
1485+ CE8B E1 F1        SunSqrE3:               DB $E1, 241
1486+ CE8D FF F1                                DB $FF, 241
1487+ CE8F C4 F2        SunSqrE4:               DB $C4, 242
1488+ CE91 FF F2                                DB $FF, 242
1489+ CE93 FF F2        SunSqrE5:               DB $FF, 242
1490+ CE95 A9 F3        SunSqrE6:               DB $A9, 243
1491+ CE97 FF F3                                DB $FF, 243
1492+ CE99 FF F3        SunSqrE7:               DB $FF, 243
1493+ CE9B FF F3                                DB $FF, 243
1494+ CE9D 90 F3        SunSqrE8:               DB $90, 243
1495+ CE9F FF F4                                DB $FF, 244
1496+ CEA1 FF F4        SunSqrE9:               DB $FF, 244
1497+ CEA3 79 F5        SunSqrEA:               DB $79, 245
1498+ CEA5 FF F5                                DB $FF, 245
1499+ CEA7 FF F5        SunSqrEB:               DB $FF, 245
1500+ CEA9 64 F6        SunSqrEC:               DB $64, 246
1501+ CEAB FF F6        SunSqrED:               DB $FF, 246
1502+ CEAD 51 F7        SunSqrEE:               DB $51, 247
1503+ CEAF FF F7                                DB $FF, 247
1504+ CEB1 FF F7        SunSqrEF:               DB $FF, 247
1505+ CEB3 40 F8        SunSqrF0:               DB $40, 248
1506+ CEB5 FF F8        SunSqrF1:               DB $FF, 248
1507+ CEB7 31 F9        SunSqrF2:               DB $31, 249
1508+ CEB9 FF F9                                DB $FF, 249
1509+ CEBB FF F9        SunSqrF3:               DB $FF, 249
1510+ CEBD 24 FA        SunSqrF4:               DB $24, 250
1511+ CEBF FF FA                                DB $FF, 250
1512+ CEC1 FF FA        SunSqrF5:               DB $FF, 250
1513+ CEC3 19 FB        SunSqrF6:               DB $19, 251
1514+ CEC5 FF FB                                DB $FF, 251
1515+ CEC7 FF FB        SunSqrF7:               DB $FF, 251
1516+ CEC9 10 FC        SunSqrF8:               DB $10, 252
1517+ CECB FF FC                                DB $FF, 252
1518+ CECD FF FC        SunSqrF9:               DB $FF, 252
1519+ CECF 09 FD        SunSqrFA:               DB $09, 253
1520+ CED1 FF FD                                DB $FF, 253
1521+ CED3 FF FD        SunSqrFB:               DB $FF, 253
1522+ CED5 04 FE        SunSqrFC:               DB $04, 254
1523+ CED7 FF FE                                DB $FF, 254
1524+ CED9 FF FE        SunSqrFD:               DB $FF, 254
1525+ CEDB 01 FF        SunSqrFE:               DB $01, 255
1526+ CEDD FF FF        SunSqrFF:               DB $FF, 255
1527+ CEDF
1528+ CEDF
1529+ CEDF
1530+ CEDF              SunBankSize  EQU $ - StartOfSun
1531+ CEDF
1532+ CEDF
# file closed: ./Universe/Sun/sun_data.asm
 295  CEDF
 296  CEDF                  SAVENEX OPEN "sunDrawTst.nex", $8000 , $7F00
 297  CEDF                  SAVENEX CFG  0,0,0,1
 298  CEDF                  SAVENEX AUTO
 299  CEDF                  SAVENEX CLOSE
 300  CEDF
# file closed: sunDrawTst.asm
